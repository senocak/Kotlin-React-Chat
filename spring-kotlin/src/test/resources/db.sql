CREATE TABLE `categories` (
    `id` varchar(255) NOT NULL,
    `name` varchar(255) NOT NULL,
    `slug` varchar(255) DEFAULT NULL,
    `image` longtext,
    `created_at` datetime DEFAULT NULL,
    `updated_at` datetime DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
INSERT INTO `categories` (`id`, `name`, `slug`, `image`, `created_at`, `updated_at`) VALUES
('34d807ce-a348-4f18-bbf6-99ba090bf012', 'Spring Boot', 'spring-boot', 'image', '2022-09-09 10:40:44', '2022-09-09 10:40:44'),
('34d807ce-a348-4f18-bbf6-99ba090bf013', 'Java', 'java', 'image', '2022-09-09 10:40:44', '2022-09-09 10:40:44'),
('34d807ce-a348-4f18-bbf6-99ba090bf014', 'Design Pattern', 'design-pattern', 'image', '2022-09-09 10:40:45', '2022-09-09 10:40:45'),
('d6c92028-73e0-4b1d-8c1f-56898adec767', 'Legacy Security Liaison', 'Legacy-Security-Liaison', 'image', '2022-09-10 09:27:45', '2022-09-10 09:27:45');

-- --------------------------------------------------------
-- Table structure for table `comments`
CREATE TABLE `comments` (
    `id` varchar(255) NOT NULL,
    `body` varchar(255) DEFAULT NULL,
    `email` varchar(255) DEFAULT NULL,
    `name` varchar(255) DEFAULT NULL,
    `post_id` varchar(255) DEFAULT NULL,
    `approved` bit(1) DEFAULT b'0',
    `created_at` datetime DEFAULT NULL,
    `updated_at` datetime DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
INSERT INTO `comments` (`id`, `body`, `email`, `name`, `post_id`, `approved`, `created_at`, `updated_at`) VALUES
('19284c52-8544-403a-866a-b9d21811520b', 'After all this time? Always.', 'amparo.von@hotmail.com', 'Karina', '1cb9374e-4e52-4142-a1af-10000ef4a271', b'1', '2022-09-09 10:40:45', '2022-09-09 10:40:45');
-- --------------------------------------------------------

-- Table structure for table `posts`
CREATE TABLE `posts` (
    `id` varchar(255) NOT NULL,
    `body` longtext NOT NULL,
    `slug` varchar(255) NOT NULL,
    `title` varchar(255) NOT NULL,
    `user_id` varchar(255) DEFAULT NULL,
    `created_at` datetime DEFAULT NULL,
    `updated_at` datetime DEFAULT NULL,
    `tags` varchar(255) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
INSERT INTO `posts` (`id`, `body`, `slug`, `title`, `user_id`, `created_at`, `updated_at`, `tags`) VALUES
('1cb9374e-4e52-4142-a1af-10000ef4a271', '<h2>Ama&ccedil;</h2>\n\n<p>Kullanıcı, API Gateway&#39;e tek bir istek yapar ve Gateway&nbsp;daha sonra ilgili her mikro servisi &ccedil;ağırır.</p>\n\n<h2>A&ccedil;ıklama</h2>\n\n<p>Microservices pattern&#39;i ile, bir m&uuml;şteri birden &ccedil;ok farklı mikroservis&nbsp;verilerine&nbsp;ihtiya&ccedil; duyabilir. Eğer client her servisi&nbsp;doğrudan &ccedil;ağırırsa,&nbsp;&ccedil;ağrılan her servis&nbsp;i&ccedil;in bir ağ isteği yapması gerekeceğinden, cevap&#39;a ulaşmak daha uzun s&uuml;rebilir. Ayrıca, m&uuml;şterinin her mikro servisi &ccedil;ağırması (istemciyi doğrudan bu mikro servise bağlar) mikro serislerin dahili uygulamaları değişirse (&ouml;rneğin, gelecekte iki mikro servis birleştirilirse) veya bir mikro hizmetin konumu&nbsp;değişirse, ardından bu mikro servisi kullanan her istemci g&uuml;ncellenmelidir.</p>\n\n<p>Bu modelinin amacı, bu sorunlardan bazılarını hafifletmektir. Api Gateway deseninde, istemci ile mikro servisler arasına ek bir k&ouml;pr&uuml;&nbsp;vardır. Bu gateway&#39;in&nbsp;işi, mikro servislere yapılan &ccedil;ağrıları toplamaktır. Her mikroservis&#39;i&nbsp;ayrı ayrı &ccedil;ağıran client yerine, Api Gateway endpoint&#39;i tek bir kez &ccedil;ağırılır.</p>\n\n<p><strong>&Ouml;rnek</strong></p>\n\n<p>Bu uygulama, bir e-ticaret sitesi i&ccedil;in Api Gateway modelinin nasıl g&ouml;r&uuml;nebileceğini g&ouml;sterir. <code>ApiGateway</code>, <code>ImageClientImpl</code> ve <code>PriceClientImpl&#39;i</code> sırasıyla kullanarak Image ve Price mikroservislerine&nbsp;istek atar. Siteyi bir masa&uuml;st&uuml; cihazda g&ouml;r&uuml;nt&uuml;leyen m&uuml;şteriler, bir &uuml;r&uuml;n&uuml;n hem fiyat bilgilerini hem de g&ouml;r&uuml;nt&uuml;s&uuml;n&uuml; g&ouml;rebilir, b&ouml;ylece Api Gateway, hem mikroservisleri&nbsp;&ccedil;ağırır hem de <code>DesktopProduct</code> modelindeki verileri toplar. Ancak, mobil kullanıcılar yalnızca fiyat bilgilerini g&ouml;r&uuml;r, &uuml;r&uuml;n resmini g&ouml;rm&uuml;yorlar. Mobil kullanıcılar i&ccedil;in Api Gateway, yalnızca <code>MobileProduct</code>&#39;ı doldurmak i&ccedil;in kullandığı fiyat bilgilerini alır.</p>\n\n<p>Image mikroservis&#39;in&nbsp;uygulaması;</p>\n\n<div class=\"highlighter-rouge language-java\">\n<pre>\n<code class=\"language-java\">public interface ImageClient {\n  String getImagePath();\n}\n\npublic class ImageClientImpl implements ImageClient {\n  @Override\n  public String getImagePath() {\n    var httpClient = HttpClient.newHttpClient();\n    var httpGet = HttpRequest.newBuilder()\n        .GET()\n        .uri(URI.create(\"http://localhost:50005/image-path\"))\n        .build();\n    try {\n      var httpResponse = httpClient.send(httpGet, BodyHandlers.ofString());\n      return httpResponse.body();\n    } catch (IOException | InterruptedException e) {\n      e.printStackTrace();\n    }\n    return null;\n  }\n}</code></pre>\n</div>\n\n<p>Price mikroservis&#39;in&nbsp;uygulaması;</p>\n\n<div class=\"highlighter-rouge language-java\">\n<pre>\n<code class=\"language-java\">public interface PriceClient {\n  String getPrice();\n}\n\npublic class PriceClientImpl implements PriceClient {\n  @Override\n  public String getPrice() {\n    var httpClient = HttpClient.newHttpClient();\n    var httpGet = HttpRequest.newBuilder()\n        .GET()\n        .uri(URI.create(\"http://localhost:50006/price\"))\n        .build();\n    try {\n      var httpResponse = httpClient.send(httpGet, BodyHandlers.ofString());\n      return httpResponse.body();\n    } catch (IOException | InterruptedException e) {\n      e.printStackTrace();\n    }\n    return null;\n  }\n}</code></pre>\n</div>\n\n<p>Burada API Gateway&#39;in istekleri mikroservislere nasıl ilettiğini g&ouml;rebiliriz.</p>\n\n<pre>\n<code class=\"language-java\">public class ApiGateway {\n  @Resource\n  private ImageClient imageClient;\n\n  @Resource\n  private PriceClient priceClient;\n\n  @RequestMapping(path = \"/desktop\", method = RequestMethod.GET)\n  public DesktopProduct getProductDesktop() {\n    var desktopProduct = new DesktopProduct();\n    desktopProduct.setImagePath(imageClient.getImagePath());\n    desktopProduct.setPrice(priceClient.getPrice());\n    return desktopProduct;\n  }\n\n  @RequestMapping(path = \"/mobile\", method = RequestMethod.GET)\n  public MobileProduct getProductMobile() {\n    var mobileProduct = new MobileProduct();\n    mobileProduct.setPrice(priceClient.getPrice());\n    return mobileProduct;\n  }\n}</code></pre>', 'api-gateway-pattern', 'API Gateway Pattern', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'cloud distributed;decoupling;microservices;architectural'),
('1cb9374e-4e52-4142-a1af-10001ef4a271', '<h2>Ama&ccedil;</h2>\n\n<p>Tip g&uuml;venliği desteğini kaybetmeden nesne ağacına anında yeni &ouml;zelliklerin eklenebildiği, g&uuml;&ccedil;l&uuml; bir şekilde yazılmış bir dildeki bileşenler arasında y&uuml;ksek derecede esneklik elde etmek</p>\n\n<h2>A&ccedil;ıklama</h2>\n\n<p>Statik olmayan ek &ouml;zelliklerin ele alınmasını sağlar. Bu model, tip g&uuml;venliğini sağlamak ve farklı sınıfların &ouml;zelliklerini aray&uuml;zler k&uuml;mesine ayırmak i&ccedil;in &ouml;zellikler kavramını kullanır. Genel olarak bu ihtiya&ccedil;lar i&ccedil;in kullanılıyor;</p>\n\n<ul>\n	<li>Anında yeni &ouml;zellikler eklenmek istendiğinde,</li>\n	<li>Daha gevşek bağlı sistem(loosely coupled system) istendiğinde</li>\n</ul>\n\n<p>&ouml;rnek</p>\n\n<blockquote>\n<p>Birden &ccedil;ok par&ccedil;adan oluşan bir araba d&uuml;ş&uuml;n&uuml;n. Ancak, belirli bir arabanın ger&ccedil;ekten t&uuml;m par&ccedil;alara mı yoksa sadece bir kısmına mı sahip olduğunu bilmiyoruz. Arabalarımız dinamik ve son derece esnektir.</p>\n</blockquote>\n\n<p>&Ouml;nce <code>Document</code> ve <code>AbstractDocument</code> temel sınıfları tanımlayalım. Temel olarak nesnenin bir &ouml;zellik haritası ve herhangi bir miktarda alt nesne tutmasını sağlarlar.</p>\n\n<div class=\"highlighter-rouge language-java\">\n<pre>\n<code class=\"language-java\">public interface Document {\n  Void put(String key, Object value);\n  Object get(String key);\n  &lt;T&gt; Stream&lt;T&gt; children(String key, Function&lt;Map&lt;String, Object&gt;, T&gt; constructor);\n}\n\npublic abstract class AbstractDocument implements Document {\n\n  private final Map&lt;String, Object&gt; properties;\n\n  protected AbstractDocument(Map&lt;String, Object&gt; properties) {\n    Objects.requireNonNull(properties, \"properties map is required\");\n    this.properties = properties;\n  }\n\n  @Override\n  public Void put(String key, Object value) {\n    properties.put(key, value);\n    return null;\n  }\n\n  @Override\n  public Object get(String key) {\n    return properties.get(key);\n  }\n\n  @Override\n  public &lt;T&gt; Stream&lt;T&gt; children(String key, Function&lt;Map&lt;String, Object&gt;, T&gt; constructor) {\n    return Stream.ofNullable(get(key))\n        .filter(Objects::nonNull)\n        .map(el -&gt; (List&lt;Map&lt;String, Object&gt;&gt;) el)\n        .findAny()\n        .stream()\n        .flatMap(Collection::stream)\n        .map(constructor);\n  }\n  ...\n}</code></pre>\n</div>\n\n<p>Daha sonra bir enum Property ile tip, fiyat, model ve par&ccedil;alar i&ccedil;in bir dizi aray&uuml;z tanımlarız. Bu, Car sınıfımıza statik g&ouml;r&uuml;n&uuml;ml&uuml; aray&uuml;z oluşturmamızı sağlar.</p>\n\n<div class=\"highlighter-rouge language-java\">\n<pre>\n<code class=\"language-java\">public enum Property {\n  PARTS, TYPE, PRICE, MODEL\n}\n\npublic interface HasType extends Document {\n  default Optional&lt;String&gt; getType() {\n    return Optional.ofNullable((String) get(Property.TYPE.toString()));\n  }\n}\n\npublic interface HasPrice extends Document {\n  default Optional&lt;Number&gt; getPrice() {\n    return Optional.ofNullable((Number) get(Property.PRICE.toString()));\n  }\n}\n\npublic interface HasModel extends Document {\n  default Optional&lt;String&gt; getModel() {\n    return Optional.ofNullable((String) get(Property.MODEL.toString()));\n  }\n}\n\npublic interface HasParts extends Document {\n  default Stream&lt;Part&gt; getParts() {\n    return children(Property.PARTS.toString(), Part::new);\n  }\n}</code></pre>\n</div>\n\n<p>Şimdi Car&#39;ı tanıtmaya hazırız.</p>\n\n<div class=\"highlighter-rouge language-java\">\n<pre>\n<code class=\"language-java\">public class Car extends AbstractDocument implements HasModel, HasPrice, HasParts {\n  public Car(Map&lt;String, Object&gt; properties) {\n    super(properties);\n  }\n}</code></pre>\n</div>\n\n<p>Car&#39;ı tanımlayıp kullanma &ouml;rneğimiz,</p>\n\n<pre>\n<code class=\"language-java\">LOGGER.info(\"Constructing parts and car\");\n\nvar wheelProperties = Map.of(\n    Property.TYPE.toString(), \"wheel\",\n    Property.MODEL.toString(), \"15C\",\n    Property.PRICE.toString(), 100L);\n\nvar doorProperties = Map.of(\n    Property.TYPE.toString(), \"door\",\n    Property.MODEL.toString(), \"Lambo\",\n    Property.PRICE.toString(), 300L);\n\nvar carProperties = Map.of(\n    Property.MODEL.toString(), \"300SL\",\n    Property.PRICE.toString(), 10000L,\n    Property.PARTS.toString(), List.of(wheelProperties, doorProperties));\n\nvar car = new Car(carProperties);\n\nLOGGER.info(\"Here is our car:\");\nLOGGER.info(\"-&gt; model: {}\", car.getModel().orElseThrow());\nLOGGER.info(\"-&gt; price: {}\", car.getPrice().orElseThrow());\nLOGGER.info(\"-&gt; parts: \");\ncar.getParts().forEach(p -&gt; LOGGER.info(\"\\t{}/{}/{}\",\n    p.getType().orElse(null),\n    p.getModel().orElse(null),\n    p.getPrice().orElse(null))\n);\n\n// Constructing parts and car\n// Here is our car:\n// model: 300SL\n// price: 10000\n// parts:\n// wheel/15C/100\n// door/Lambo/300</code></pre>', 'abstract-document-pattern', 'Abstract Document Pattern', '3cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'extensibility;structural'),
('1cb9374e-4e52-4142-a1af-10002ef4a271', '<p>Amacı bazı durumlarda bir sınıftan birden fazla nesne oluşturulmasına gerek yoktur. &Ouml;rneğin; uygulama katmanımızın veri tabanına bağlantısını y&ouml;neten sınıftan birden fazla nesne oluşturmaya gerek yoktur. Her &ccedil;ağıran i&ccedil;in bu sınıftan ayrı ayrı nesne oluşturmak uygulama verimliliğini d&uuml;ş&uuml;recektir. İşte singleton deseni bize bu konuda yardımcı oluyor. Bu tasarım deseni ile ilgili sınıftan birden fazla nesne oluşturulmasının &ouml;n&uuml;ne ge&ccedil;miş oluruz.</p>\n\n<p>Bir sınıfı singleton prensibine uyarlamak i&ccedil;in yapılandırıcısının erişim belirtecini private yapmamız yeterlidir.</p>\n\n<p><strong>Tek &ouml;ğeli bir enum t&uuml;r&uuml;, bir singleton uygulamanın en iyi yoludur</strong></p>\n\n<pre>\n<code class=\"language-java\">public enum EnumIvoryTower {\n  INSTANCE\n}\n\nvar enumIvoryTower1 = EnumIvoryTower.INSTANCE;\nvar enumIvoryTower2 = EnumIvoryTower.INSTANCE;\nassertEquals(enumIvoryTower1, enumIvoryTower2); // true</code></pre>\n\n<p>&Ouml;rnek</p>\n\n<pre>\n<code class=\"language-java\">public class Nesne {\n    private static Nesne nesne = null;\n\n    private Nesne(){}\n\n    public static Nesne getInstance(){\n        return nesne == null ? new Nesne() : nesne;\n    }\n}\npublic class MainClass {\n    public static void main(String[] args) {\n        final Nesne instance = Nesne.getInstance();\n        //Nesne instance1 = new Nesne(); Hatalı Kullanım\n    }\n}</code></pre>\n\n<h3><strong>Uygulanabilirlik</strong></h3>\n\n<p>Singleton&nbsp;modelini;</p>\n\n<ul>\n	<li>Bir sınıfın tam olarak bir &ouml;rneği olmalı ve iyi bilinen bir erişim noktasından istemciler tarafından erişilebilir olmalı olduğunda,</li>\n	<li>Tek &ouml;rnek alt sınıflandırma yoluyla genişletilebilir olduğunda ve istemciler, kodlarını değiştirmeden genişletilmiş bir &ouml;rnek kullanmak istediğinde kullanılmalıdır.</li>\n</ul>\n\n<h3><strong>Tipik Kullanım Durumu</strong></h3>\n\n<ul>\n	<li>Loglama sınıflarında,</li>\n	<li>Veritabanı bağlantı y&ouml;netmede,</li>\n	<li>Dosya y&ouml;netmede</li>\n</ul>\n\n<h3><strong>Ger&ccedil;ek &ouml;rnekler</strong></h3>\n\n<ul>\n	<li>java.lang.Runtime#getRuntime()</li>\n	<li>java.awt.Desktop#getDesktop()</li>\n	<li>java.lang.System#getSecurityManager()</li>\n</ul>\n\n<h3><strong>Sonu&ccedil;lar</strong></h3>\n\n<ul>\n	<li>Kendi yaratımını ve yaşam d&ouml;ng&uuml;s&uuml;n&uuml; kontrol ederek Tek Sorumluluk İlkesini (Single Responsibility Principle / SRP) ihlal ediyor.</li>\n	<li>Bu nesne tarafından kullanılan bir nesnenin ve kaynakların serbest bırakılmasını &ouml;nleyen genel bir paylaşılan &ouml;rnek kullanmayı teşvik eder.</li>\n	<li>Sıkıca bağlı(tightly coupled) kod oluşturur. Singleton client&#39;ların&nbsp;testi zorlaşır.</li>\n	<li>Bir Singleton&#39;ı alt sınıflara ayırmayı neredeyse imkansız hale getirir.</li>\n</ul>\n\n<h4><strong>Single Responsibility Principle</strong></h4>\n\n<p>Her sınıfın bir sorumluluğu, tek bir amacı olması gerektiğini belirtir. Bu, bir sınıfın yalnızca bir iş yapacağı anlamına gelir ve bu da bizi, değişmesi&nbsp;i&ccedil;in <strong>tek</strong> bir nedene sahip olması gerektiği sonucuna g&ouml;t&uuml;r&uuml;r.</p>', 'singleton-pattern', 'Singleton Pattern', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Singleton'),
('1cb9374e-4e52-4142-a1af-10003ef4a271', '<p>Bazen projelerimizde nesnelerimize ait bir&ccedil;ok &ouml;zellik olabilir ve bu nesnelerimizi farklı farklı &ouml;zellikler ile oluşturmak isteriz. Dolayısıyla bazen &ccedil;alıştığımız sınıflar i&ccedil;erisinde &ccedil;ok fazla parametre alan metodlar ve yapılandırıcılar kullanabiliyoruz. Bu kullanılabilirliği ve okunabilirliği olduk&ccedil;a zorlaştıran bir durum. Bazen aynı methodu &ccedil;ok fazla kez overload edip, kendimize iş y&uuml;k&uuml; doğurabiliyoruz. İşte bu kısımda yardımımıza&nbsp;<strong>Builder Design Pattern</strong>&nbsp;yetişiyor.</p>\n\n<p><strong>Nesne sınıfımız</strong></p>\n\n<pre>\n<code class=\"language-java\">// Lombok olduğunu varsayalım\n@Getter\n@Setter\n@NoArgsConstructor\n@AllArgsConstructor\n@ToString\npublic class Computer {\n    private String brand;\n    private String price;\n    private String cpu;\n    private String ram;\n}</code></pre>\n\n<p><strong>Builder sınıfımız</strong></p>\n\n<pre>\n<code class=\"language-java\">// Lombok olduğunu varsayalım\n@Setter\npublic class ComputerBuilder {\n    private String brand;\n    private String price;\n    private String cpu;\n    private String ram;\n\n    public Computer buildComputer() {\n        return new Computer(brand, price, cpu, ram);\n    }\n}</code></pre>\n\n<p><strong>Test sınıfımız</strong></p>\n\n<pre>\n<code class=\"language-java\">public class MainClass {\n	public static void main(String[] args) {\n		final ComputerBuilder computerBuilder = new ComputerBuilder();\n\n		final Computer computer1 = computerBuilder.setBrand(\"ASUS\").setCpu(\"2,40 GHZ\").setPrice(\"1500 $\").setRam(\"8 GB\").buildComputer();\n		System.out.println(computer1);\n\n		final Computer computer2 = computerBuilder.setBrand(\"APPLE\").setCpu(\"2,60 GHZ\").setPrice(\"3500 $\").setRam(\"16 GB\").buildComputer();\n		System.out.println(computer2);\n	}\n}</code></pre>\n\n<h3><strong>Uygulanabilirlik</strong></h3>\n\n<p>Builder pattern&#39;i</p>\n\n<ul>\n	<li>Karmaşık bir nesne oluşturma algoritması, nesneyi oluşturan par&ccedil;alardan ve bunların nasıl birleştirildiğinden bağımsız olmalıdır.</li>\n	<li>Yapım s&uuml;reci, inşa edilen nesne i&ccedil;in farklı temsillere izin vermelidir.</li>\n</ul>\n\n<h3><strong>&Ouml;rnekleri</strong></h3>\n\n<ul>\n	<li>java.lang.StringBuilder</li>\n	<li>java.nio.ByteBuffer(FloatBuffer, IntBuffer ve benzeri gibi benzer arabelleklerin yanı sıra.)</li>\n	<li>java.lang.StringBuffer</li>\n	<li>java.lang.Appendable&#39;in t&uuml;m implementleri</li>\n	<li>Apache Camel builders</li>\n	<li>Apache Commons Option.Builder</li>\n</ul>', 'builder-pattern', 'Builder Pattern', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'builder'),
('1cb9374e-4e52-4142-a1af-10004ef4a271', '<p>Verileri &ouml;nceden y&uuml;klemek mi yoksa kullanırken mi istediğinize bağlı olarak optimum cache&#39;leme, okuma işlemleri ve veri alımını ayarlar.&nbsp;<code>Cache Aside</code> modeli, doğru kullanılırsa, verileri &ouml;nbellekte cache&#39;leyerek&nbsp;performansı iyileştirir.</p>\n\n<p>Okuma işlemleri i&ccedil;in, &ouml;nce bir anahtar kullanılarak verilerin kullanılabilirliği i&ccedil;in &ouml;nbellek&nbsp;kontrol edilir. Veri varsa, okuma &ccedil;ağrısı verileri cache&#39;ten d&ouml;nd&uuml;r&uuml;r ve işlemi tamamlar. Verilerin cache&#39;te bulunmadığı bir durumda, verileri almak i&ccedil;in temel alınan veri deposuna(database) gidilir&nbsp;ve response d&ouml;nd&uuml;rmeden &ouml;nce bir key ile cache&#39;e yazılır. Bu yeni oluşturulan cache, cache&#39;ten alınan aynı veriler i&ccedil;in sonraki okuma işlemlerini yapacak, b&ouml;ylece yanıt s&uuml;resini kısaltacak ve verimi artıracaktır.</p>\n\n<p><img alt=\"cacheaside\" src=\"/upload/files/cacheaside.png\" style=\"height:221px; width:800px\" title=\"Image: 1.a\" /></p>\n\n<p>Spring&#39;de, aşağıdaki şekilde implement edilebilir; burada <code>getRecordForSearch</code>&nbsp;&ccedil;ağrıldığında, varsa &ouml;nbellekten otomatik olarak alınır, aksi takdirde, veri deposundan alınacaktır.</p>\n\n<pre>\n<code class=\"language-java\">@Cacheable(\"default\", key=\"#search.keyword)\npublic Record getRecordForSearch(Search search)</code></pre>\n\n<h3><strong>Veri g&uuml;ncellemesi</strong></h3>\n\n<p>Arabirim uygulaması, veri deposundaki verileri g&uuml;ncelleyebiliyorsa ve bu veriler &ouml;nbellekte mevcutsa, &ouml;nbelleğin de g&uuml;ncellemeyi yansıtması gerekir. Senkronizasyon sorununu aşmak ve veri alımı i&ccedil;in veri tutarlılığı ve performansını sağlamak i&ccedil;in gereksinimlere bağlı olarak iki strateji kullanılabilir.</p>\n\n<h4><strong>Veri G&uuml;ncellemelerinde Cache Eviction</strong></h4>\n\n<p>Bu durumda, veri deposundaki verileri g&uuml;ncellemek i&ccedil;in bir metod &ccedil;ağrıldığında, anahtarı kullanarak &ouml;nbellek girişini de ge&ccedil;ersiz kılar. Bu yaklaşımda, &ouml;nbellek girişi yalnızca g&uuml;ncellemeden sonra yeniden istendiğinde y&uuml;klenir. Spring, bunu aşağıdaki gibi yapılabilir:</p>\n\n<pre>\n<code class=\"language-java\">@CacheEvict(\"default\", key=\"#search.keyword)\npublic Record updateRecordForSearch(Search search)</code></pre>\n\n<h4><strong>Veri G&uuml;ncellemelerinde Cache G&uuml;ncellemeleri</strong></h4>\n\n<p>Cache dataları, tek seferde daha hızlı veri alma ve tutarlılık elde etmek i&ccedil;in verileri veri deposunda g&uuml;ncellendiğinde de g&uuml;ncellenebilir. Spring, aşağıdakileri yaparak başarılabilir:</p>\n\n<pre>\n<code class=\"language-java\">@CachePut(\"default\", key=\"#search.keyword)\npublic Record updateRecordForSearch(Search search)</code></pre>\n\n<p>Veri ihtiyacına ve t&uuml;r&uuml;ne bağlı olarak, farklı &ouml;nbellek y&uuml;kleme stratejileri benimsenebilir.</p>\n\n<ul>\n	<li>\n	<p><strong>Hareket halindeyken verileri y&uuml;kleyin</strong>: İlk istek onu veri deposundan getirir, ancak sonraki istekler verileri &ouml;nbellekten alır.</p>\n	</li>\n	<li>\n	<p><strong>&Ouml;nbelleği &ouml;nceden y&uuml;kle</strong>: Uygulamanın başlangıcında y&uuml;klenen veriler i&ccedil;in kullanılır, &uuml;lke listesi, para birimi, &ouml;nemli tarihler vb. gibi referans verileri i&ccedil;in en iyisidir. Bu, &ccedil;ok sık değişmeyen veriler i&ccedil;in idealdir.</p>\n	</li>\n</ul>', 'cache-aside-pattern', 'Cache Aside Pattern', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'cache'),
('1cb9374e-4e52-4142-a1af-10005ef4a271', '<p>Amacı işin tanımlanması ile işin y&uuml;r&uuml;t&uuml;lmesi&#39;ni ayırarak &Uuml;retici ve T&uuml;ketici arasındaki bağlantıyı azaltan klasik bir eşzamanlılık modelidir. Bu tasarım deseninde, akışı kontrol etmek i&ccedil;in paylaşılan bir kuyruk kullanılır ve bu ayrım, &uuml;retici ve t&uuml;keticiyi ayrı ayrı kodlamanıza olanak tanır. Ayrıca, &ouml;ğelerin &uuml;retilmesi veya t&uuml;ketilen &ouml;ğelerin farklı zamanlama gereksinimleri konusunu da ele alır. Hem &Uuml;retici hem de T&uuml;ketici Konusu farklı hızlarda &ccedil;alışabilir.</p>\n\n<h3><strong>&Ouml;rnek</strong></h3>\n\n<p>Bu model ger&ccedil;ek hayatta her yerdedir ve koordinasyon ve işbirliğini tasvir eder. Bir kişi yemek hazırlarken(&Uuml;retici), diğeri yemek servisi yapıyor(T&uuml;ketici) gibi, ikisi de yemek tabaklarını koymak ve yemek tabaklarını almak i&ccedil;in ortak bir masa kullanacak.</p>\n\n<p>Eğer masa doluysa T&uuml;ketici, boş ise &Uuml;retici bekleyecektir. Masa burada paylaşılan bir nesnedir. Java kitaplığında, <code>Executor</code> <code>framework</code>, g&ouml;revin eklenmesi ve y&uuml;r&uuml;t&uuml;lmesinin sorumluluğunu ayıran <code>Producer Consumer</code> tasarım modelini uygular.</p>\n\n<h3><strong>Faydaları</strong></h3>\n\n<p>Ger&ccedil;ekten de kullanışlı bir tasarım kalıbıdır ve en yaygın olarak &ccedil;ok iş par&ccedil;acıklı veya eşzamanlı kod yazarken kullanılır. İşte faydalarının birka&ccedil;ıdır:</p>\n\n<ol>\n	<li>&Uuml;retici T&uuml;ketici Modeli basit geliştirme. <code>Producer</code> ve <code>Consumer</code>&nbsp;bağımsız olarak ve Eşzamanlı olarak yapabilirsiniz, yalnızca paylaşılan nesneyi bilmeleri gerekir.</li>\n	<li><code>Producer</code> ve <code>Consumer</code>&#39;ın kim olduğunu veya ka&ccedil; &uuml;retici ve t&uuml;ketici olduğunu bilmesine gerek yoktur.</li>\n	<li><code>Producer</code> ve <code>Consumer</code>&nbsp;farklı hızlarda &ccedil;alışabilir. Aslında, producer hızını izleyerek, daha iyi kullanım i&ccedil;in daha fazla producer eklenebilir.</li>\n	<li><code>Producer</code> ve <code>Consumer</code>&nbsp;işlevlerinin ayrılması, daha temiz, okunabilir ve y&ouml;netilebilir kod sağlar.</li>\n</ol>\n\n<h3><strong>Multi-threading Problem </strong></h3>\n\n<p>Kuyruk doluysa Producer&#39;ın beklemesi ve kuyruk boşsa Consumer&#39;ın beklemesi i&ccedil;in <code>Producer</code> ve <code>Consumer</code> tasarım modelini uygulamasını istediği pop&uuml;ler bir java problemidir.</p>\n\n<p>Bu problem Java&#39;da farklı yollarla uygulanabilir veya &ccedil;&ouml;z&uuml;lebilir, klasik yol, <code>Producer</code> ve <code>Consumer</code> iş par&ccedil;acığı arasında iletişim kurmak i&ccedil;in <em><span style=\"font-size:small\"><span data-darkreader-inline-color=\"\" style=\"--darkreader-inline-color:#d8d4cf; color:#e8e6e3\"><span style=\"font-family:&quot;Trebuchet MS&quot;,Verdana,Arial,sans-serif\"><span style=\"font-size:9pt\"><span data-darkreader-inline-color=\"\" style=\"--darkreader-inline-color:#e8e6e3; color:black\"><span style=\"font-family:arial\">wait ve&nbsp;notify method</span></span></span></span></span></span></em> kullanmak ve her birini kuyruk dolu mu boş mu gibi koşullarda eklenmesidir.</p>\n\n<p>Java 5&#39;te&nbsp;<code>BlockingQueue</code> veri yapısının tanıtılmasıyla artık &ccedil;ok daha basittir,&nbsp;&ccedil;&uuml;nk&uuml; <code>BlockingQueue</code>, <code>put()</code> ve <code>take()&nbsp;</code>y&ouml;ntemlerini tanıtarak bu kontrol&uuml; implicitly olarak sağlar. Artık&nbsp;<code>Producer</code>&nbsp;ve&nbsp;<code>Consumer</code>&nbsp;arasında iletişim kurmak i&ccedil;in wait ve notify &ouml;zelliğini kullanmamıza gerek yok. BlockingQueue put() y&ouml;ntemi, sınırlı kuyruk durumunda kuyruk doluysa ve kuyruk boşsa take() y&ouml;ntemi engeller. Bir sonraki b&ouml;l&uuml;mde, <code>Producer</code> ve <code>Consumer</code>&nbsp;tasarım deseninin bir kod &ouml;rneğini g&ouml;receğiz.</p>\n\n<h3><strong>Producer Consumer Modelini uygulamak i&ccedil;in Blocking Queue Kullanma</strong></h3>\n\n<p><code>BlockingQueue</code>, put() ve take()&#39;de engelleme desteği sağlayarak <code>Producer</code>&nbsp;ve&nbsp;<code>Consumer</code>&nbsp;tasarım modelinin uygulanmasını basitleştirir. Geliştiricinin, iletişimi uygulamak i&ccedil;in kafa karıştırıcı ve kritik bir wait-notify kodu yazması gerekmez. <code>BlockingQueue</code> bir interfacedir ve Java 5,&nbsp;<code>ArrayBlockingQueue</code> ve <code>LinkedBlockingQueue</code> gibi farklı implantasyon sağlar, her ikisi de FIFO d&uuml;zenini uygular, <code>ArrayLinkedQueue</code> doğası gereği sınırlıdır, <code>LinkedBlockingQueue</code> isteğe bağlı olarak sınırlıdır.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        BlockingQueue&lt;Integer&gt; sharedQueue = new LinkedBlockingQueue&lt;&gt;();\n\n        Thread prodThread = new Thread(new Producer(sharedQueue));\n        Thread consThread = new Thread(new Consumer(sharedQueue));\n        prodThread.start();\n        consThread.start();\n    }\n}\n\nclass Producer implements Runnable {\n    private final BlockingQueue&lt;Integer&gt; sharedQueue;\n\n    public Producer(BlockingQueue&lt;Integer&gt; sharedQueue) {\n        this.sharedQueue = sharedQueue;\n    }\n\n    @Override\n    public void run() {\n        for(int i=0; i&lt;10; i++){\n            try {\n                System.out.println(\"Produced: \" + i);\n                sharedQueue.put(i);\n            } catch (InterruptedException ex) {\n                Logger.getLogger(Producer.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n}\nclass Consumer implements Runnable{\n    private final BlockingQueue&lt;?&gt; sharedQueue;\n\n    public Consumer (BlockingQueue&lt;?&gt; sharedQueue) {\n        this.sharedQueue = sharedQueue;\n    }\n\n    @Override\n    public void run() {\n        while(true){\n            try {\n                System.out.println(\"Consumed: \"+ sharedQueue.take());\n            } catch (InterruptedException ex) {\n                Logger.getLogger(Consumer.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n}\n</code></pre>\n\n<pre>\n<code class=\"language-bash\">Produced: 0\nProduced: 1\nConsumed: 0\nProduced: 2\nProduced: 3\nProduced: 4\nProduced: 5\nConsumed: 1\nConsumed: 2\nProduced: 6\nConsumed: 3\nProduced: 7\nConsumed: 4\nProduced: 8\nProduced: 9\nConsumed: 5\nConsumed: 6\nConsumed: 7\nConsumed: 8\nConsumed: 9</code></pre>\n\n<p>&Uuml;retilen Producer Thread numarasını g&ouml;r&uuml;yoruz ve Consumer iş par&ccedil;acığı bunu FIFO sırasına g&ouml;re t&uuml;ketiyor &ccedil;&uuml;nk&uuml; blocking kuyruğu FIFO&#39;da &ouml;ğelere erişilmesine izin veriyor.</p>', 'producer-consumer-pattern', 'Producer Consumer Pattern', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Producer;Consumer'),
('1cb9374e-4e52-4142-a1af-10006ef4a271', '<p><code><strong>Single responsibility principle</strong></code>: Bir sınıfın değişmesi i&ccedil;in yalnızca bir nedeni olmalıdır.</p>\n\n<p><code>K&ouml;t&uuml; Kod;</code></p>\n\n<pre>\n<code class=\"language-java\">@Getter\n@Setter\npublic class Book {\n	private String author;\n	private String text;\n	private String name;\n\n	public void print(){\n		System.out.println(text);\n	}\n}</code></pre>\n\n<p><code><strong>Open-Closed principle</strong></code>:&nbsp;Sınıf&#39;lar genişletmeye a&ccedil;ık, ancak değişiklik i&ccedil;in kapalı olmalıdır.</p>\n\n<p><code>K&ouml;t&uuml; Kod;</code></p>\n\n<pre>\n<code class=\"language-java\">@Getter\n@Setter\npublic class Product {\n	private String name;\n	private double price;\n	private String type;\n}\n\npublic class ShoppingCartService {\n	public double calculateTotalOrder(List&lt;Product&gt; products){\n		double orderTotal = 0;\n		for (Product product : products) {\n			if(\"FOOD\".equals(product.getType())){\n				orderTotal += product.getPrice()+ product.getPrice()*0.08;\n			}else if(\"CAR\".equals(product.getType())){\n				orderTotal += product.getPrice()*1.60*1.18;\n			}else if(\"Electronics\".equals(product.getType())){\n				orderTotal += product.getPrice()*1.18;\n			}\n		}\n		return orderTotal;\n	}\n}</code></pre>\n\n<p><code><strong>Liskov Substitution Principle</strong></code>:&nbsp;Alt sınıflar, &uuml;st sınıf t&uuml;r&uuml; tanımlarını asla bozmamalıdır.</p>\n\n<ul>\n</ul>\n\n<p><code>K&ouml;t&uuml; Kod;</code></p>\n\n<pre>\n<code class=\"language-java\">@Getter\n@Setter\npublic class Rectangle {\n	private double width;\n	private double height;\n\n	public double area(){\n		return width*height;\n	}\n}\n\npublic class Square extends Rectangle{\n	@Override\n	public void setHeight(double height) {\n		super.setHeight(height);\n		super.setWidth(height);\n	}\n	@Override\n	public void setWidth(double width) {\n		super.setHeight(width);\n		super.setWidth(width);\n	}\n}</code></pre>\n\n<p><code><strong>Interface Segregation Principle</strong></code>: Hi&ccedil;bir client, kullanmadığı metodlara bağımlı olmaya zorlanmamalıdır. Aray&uuml;zde bağımlı sınıf tarafından g&ouml;r&uuml;lebilen &uuml;ye sayısı en aza indirilmelidir. B&uuml;y&uuml;k sınıflar, işlevleri kullanımlarına g&ouml;re gruplayan birden &ccedil;ok daha k&uuml;&ccedil;&uuml;k aray&uuml;z uygulamalıdır.</p>\n\n<ul>\n</ul>\n\n<p><code>K&ouml;t&uuml; Kod;</code></p>\n\n<pre>\n<code class=\"language-java\">public interface Component {\n	public void mouseover(String event);\n	public void touch(String event);\n	public void swipe(String event);\n	public void validate();\n}\n\npublic class AndroidComponent implements Component {\n	public void mouseover(String event) {\n		throw new UnsupportedOperationException(\"mouse click not supported\");\n	}\n	public void touch(String event) {\n		System.out.println(\"Touch Event Fired\");\n	}\n	public void swipe(String event) {\n		System.out.println(\"Swipe Event Fired\");\n	}\n	public void validate() {\n		System.out.println(\"All UI is valid\");\n	}\n}\n\npublic class DesktopComponent implements Component {\n	public void mouseover(String event) {\n		System.out.println(\"Mouse click Event Fired\");\n	}\n	public void touch(String event) {\n		throw new UnsupportedOperationException(\"touch not supported\");\n	}\n	public void swipe(String event) {\n		throw new UnsupportedOperationException(\"swipe not supported\");\n	}\n	public void validate() {\n		System.out.println(\"All UI is valid\");\n	}\n}</code></pre>\n\n<p><code><strong>Dependency inversion principle</strong></code>: Y&uuml;ksek seviyeli mod&uuml;ller, d&uuml;ş&uuml;k seviyeli mod&uuml;llere bağlı olmamalıdır. Her ikisi de soyutlamalara dayanmalıdır. Soyutlamalar ayrıntılara bağlı olmamalıdır.</p>\n\n<ul>\n</ul>\n\n<p><code>K&ouml;t&uuml; Kod;</code></p>\n\n<pre>\n<code class=\"language-java\">@Getter\n@Setter\npublic class DotMatrixPrinterPrinter {\n	private String inc;\n	public void print(String text){\n		System.out.println(text);\n	}\n}\n\npublic class PrinterDesk {\n	private DotMatrixPrinterPrinter printer;\n	public PrinterDesk(DotMatrixPrinterPrinter printer) {\n		super();\n		this.printer = printer;\n	}\n	public void printFile(){\n		printer.print(\"File Content\");\n	}\n}</code></pre>\n\n<p>&nbsp;</p>', 'solid', 'S.O.L.I.D', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Single responsibility;Open\\/Closed;Liskov Substitution;Interface Segregation;Dependency inversion'),
('1cb9374e-4e52-4142-a1af-20000ef4a271', '<p>JUnit 5, Java 8 kodlama stilini uyarlamayı ve JUnit 4&#39;ten daha sağlam ve esnek olmayı ama&ccedil;lamaktadır.</p>\n\n<h3><strong>Annotations</strong></h3>\n\n<table border=\"1\" style=\"width:1076px\">\n	<tbody>\n		<tr>\n			<th style=\"width:624px\">&nbsp;</th>\n			<th style=\"width:230px\">JUNIT 4</th>\n			<th style=\"width:198px\">JUNIT 5</th>\n		</tr>\n		<tr>\n			<td style=\"width:624px\">Test metodu tanımlama</td>\n			<td style=\"width:230px\"><code>@Test</code></td>\n			<td style=\"width:198px\"><code>@Test</code></td>\n		</tr>\n		<tr>\n			<td style=\"width:624px\">Varolan sınıfta t&uuml;m testleri &ccedil;alıştırmadan &ouml;nce &ccedil;alışacak</td>\n			<td style=\"width:230px\"><code>@BeforeClass</code></td>\n			<td style=\"width:198px\"><code>@BeforeAll</code></td>\n		</tr>\n		<tr>\n			<td style=\"width:624px\">Varolan sınıfta t&uuml;m testleri &ccedil;alıştırdıktan sonra &ccedil;alışacak</td>\n			<td style=\"width:230px\"><code>@AfterClass</code></td>\n			<td style=\"width:198px\"><code>@AfterAll</code></td>\n		</tr>\n		<tr>\n			<td style=\"width:624px\">Her testten &ouml;nce &ccedil;alışacak</td>\n			<td style=\"width:230px\"><code>@Before</code></td>\n			<td style=\"width:198px\"><code>@BeforeEach</code></td>\n		</tr>\n		<tr>\n			<td style=\"width:624px\">Her testten sonra &ccedil;alışacak</td>\n			<td style=\"width:230px\"><code>@After</code></td>\n			<td style=\"width:198px\"><code>@AfterEach</code></td>\n		</tr>\n		<tr>\n			<td style=\"width:624px\">Test&#39;i disable etmek</td>\n			<td style=\"width:230px\"><code>@Ignore</code></td>\n			<td style=\"width:198px\"><code>@Disabled</code></td>\n		</tr>\n		<tr>\n			<td style=\"width:624px\">Dinamik testler i&ccedil;in Test factory</td>\n			<td style=\"width:230px\">NA</td>\n			<td style=\"width:198px\"><code>@TestFactory</code></td>\n		</tr>\n		<tr>\n			<td style=\"width:624px\">Nested testler</td>\n			<td style=\"width:230px\">NA</td>\n			<td style=\"width:198px\"><code>@Nested</code></td>\n		</tr>\n		<tr>\n			<td style=\"width:624px\">Etiketleme ve filtreleme</td>\n			<td style=\"width:230px\"><code>@Category</code></td>\n			<td style=\"width:198px\"><code>@Tag</code></td>\n		</tr>\n		<tr>\n			<td style=\"width:624px\">Custm uzantıları etkinleştirme</td>\n			<td style=\"width:230px\">NA</td>\n			<td style=\"width:198px\"><code>@ExtendWith</code></td>\n		</tr>\n	</tbody>\n</table>\n\n<h3><strong>Architecture</strong></h3>\n\n<ul>\n	<li>JUnit 4, tek bir jar dosyasında paketlenmiş her şeye sahiptir.</li>\n	<li>Junit 5, JUnit Platform, JUnit Jupiter ve JUnit Vintage olmak &uuml;zere 3 alt projeden oluşmaktadır.\n	<ul>\n		<li><code>JUnit Platform</code>: Platformda &ccedil;alışan yeni test frameworkleri geliştirmek i&ccedil;in <code>TestEngine</code> API&#39;sini tanımlar.</li>\n		<li><code>JUnit J&uuml;piter</code>: Bu ek a&ccedil;ıklamalarla yazılmış testleri &ccedil;alıştırmak i&ccedil;in t&uuml;m yeni junit ek a&ccedil;ıklamalarına ve <code>TestEngine</code> uygulamasına sahiptir.</li>\n		<li><code>JUnit Vintage</code>: JUnit 5 platformunda JUnit 3 ve JUnit 4 yazılı testlerinin &ccedil;alıştırılmasını desteklemek i&ccedil;in.</li>\n	</ul>\n	</li>\n</ul>\n\n<h3><strong>Required JDK Version</strong></h3>\n\n<ul>\n	<li>Junit 4, Java 5 veya daha &uuml;zeri,</li>\n	<li>Junit 5, Java 8 veya &uuml;zeri versiyonlara ihtiya&ccedil; duyar.</li>\n</ul>\n\n<h3><strong>Assertion</strong></h3>\n\n<p>Junit 4&#39;te, <code>org.junit.Assert</code>, beklenen ve elde edilen sonu&ccedil;ları doğrulamak i&ccedil;in t&uuml;m assert y&ouml;ntemlerine sahiptir. Y&ouml;ntem imzasında İLK arg&uuml;man olarak hata mesajı i&ccedil;in ekstra parametre kabul ederler.</p>\n\n<pre>\n<code class=\"language-java\">public static void assertEquals(long expected, long actual)\npublic static void assertEquals(String message, long expected, long actual)</code></pre>\n\n<p>JUnit 5&#39;te, <code>org.junit.jupiter.Assertions</code>, ek olarak <code>assertThrows()</code> ve <code>assertAll()</code> y&ouml;ntemleri dahil, &ccedil;oğu assert y&ouml;ntemini i&ccedil;erir.</p>\n\n<p>JUnit 5 assertion y&ouml;ntemleri ayrıca, testin başarısız olması durumunda yazdırılacak hata mesajını iletmeyi desteklemek i&ccedil;in aşırı y&uuml;klenmiş y&ouml;ntemlere sahiptir;</p>\n\n<pre>\n<code class=\"language-java\">public static void assertEquals(long expected, long actual)\npublic static void assertEquals(long expected, long actual, String message)\npublic static void assertEquals(long expected, long actual, Supplier messageSupplier)</code></pre>\n\n<h3><strong>Assumptions</strong></h3>\n\n<p>Junit 4&#39;te, <code>org.junit.Assume</code>, bir testin anlamlı olduğu koşullar hakkında varsayımları belirtmek i&ccedil;in metodlar i&ccedil;erir.</p>\n\n<ol>\n	<li>assumeFalse()</li>\n	<li>assumeNoException()</li>\n	<li>assumeNotNull()</li>\n	<li>assumeThat()</li>\n	<li>assumeTrue()</li>\n</ol>\n\n<p>Junit 5&#39;te,&nbsp;<code>org.junit.jupiter.api.Assumptions</code>, bir testin anlamlı olduğu koşullarla ilgili varsayımları belirtmek i&ccedil;in y&ouml;ntemler i&ccedil;erir.</p>\n\n<ol>\n	<li>assumeFalse()</li>\n	<li>assumingThat​()</li>\n	<li>assumeTrue()</li>\n</ol>\n\n<h3><strong>Etiketleme ve filtreleme</strong></h3>\n\n<ul>\n	<li>Junit 4&#39;te,&nbsp;<code>@category</code>&nbsp;annotation&#39;ı</li>\n	<li>Junit 5&#39;te,&nbsp;<code>@tag</code>&nbsp;annotation&#39;ı kullanılır.</li>\n</ul>\n\n<h3><strong>3rd Party Integration</strong></h3>\n\n<ul>\n	<li>Junit 4&#39;te 3. taraf eklentiler ve IDE&#39;ler i&ccedil;in entegrasyon desteği yoktur. Reflection&#39;lara g&uuml;venmek zorundalar.</li>\n	<li>JUnit 5, bu ama&ccedil; i&ccedil;in, yani JUnit Platformu i&ccedil;in &ouml;zel bir alt projeye sahiptir. Platformda &ccedil;alışan bir test &ccedil;er&ccedil;evesi geliştirmek i&ccedil;in <code>TestEngine</code>&nbsp;API&#39;sini tanımlar.</li>\n</ul>', 'junit-5-vs-junit-4', 'JUnit 5 vs JUnit 4', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'JUnit5;JUnit4'),
('1cb9374e-4e52-4142-a1af-20001ef4a271', '<p>Bu, tıpkı bir mock işlemlerde yaptığımız gibi, her etkileşimi izlemeye devam ederken nesnenin t&uuml;m normal metodlarını &ccedil;ağırmamıza izin verecektir.&nbsp;Ger&ccedil;ek nesnenin sadece belirtilen metodları mock kodu tarafından override edilir.</p>\n\n<pre>\n<code class=\"language-java\">@Spy\nList&lt;String&gt; spiedList = new ArrayList&lt;&gt;();\n\n@Test\nvoid whenUseSpyAnnotation_thenSpyIsInjectedCorrectly() {\n	// List&lt;String&gt; spiedList = Mockito.spy(new ArrayList&lt;&gt;());\n	// Bu şekilde de kullanılabilir\n	spiedList.add(\"one\");\n	Mockito.verify(spiedList).add(\"one\");\n	assertEquals(1, spiedList.size());\n\n	Mockito.doReturn(100).when(spiedList).size();\n	assertEquals(100, spiedList.size());\n}</code></pre>\n\n<p>&nbsp;</p>', 'mockito-at-spy', 'Mockito: @Spy', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'spy'),
('1cb9374e-4e52-4142-a1af-20002ef4a271', '<p>Mockito&#39;da, bir metod &ccedil;ağrıldığında ne d&ouml;nd&uuml;r&uuml;leceğini belirtebiliriz. Bu, mevcut sınıfları değiştirmemiz gerekmediğinden unit testleri&nbsp;kolaylaştırır. Mockito, bunu yapmanın iki yolunu destekler: <code>when-thenReturn</code> ve <code>doReturn-when</code>. &Ccedil;oğu durumda, <code>when-thenReturn</code> kullanılır ve daha iyi okunabilirliğe sahiptir.</p>\n\n<pre>\n<code class=\"language-java\">User user = Mockito.mock(User.class);\nwhen(user.getName()).thenReturn(\"John\");</code></pre>\n\n<p>Ancak, bazen farklı davranışlar olduğu i&ccedil;in <code>doReturn-when</code>&nbsp;kullanmayı d&uuml;ş&uuml;nmemiz gerekir.</p>\n\n<h3><strong>Tip g&uuml;venliği</strong></h3>\n\n<p><code>doReturn</code>&nbsp;parametresi,&nbsp;<code>thenReturn</code>&#39;den farklı olarak <code>Object</code>&#39;tir. Bu nedenle, derleme zamanında t&uuml;r denetimi yoktur. &Ccedil;alışma zamanında t&uuml;r eşleşmediğinde, bir <code>WrongTypeOfReturnValue</code>&nbsp;exception fırlatır.</p>\n\n<pre>\n<code class=\"language-java\">doReturn(true).when(user).getName());</code></pre>\n\n<p><code>when-thenReturn</code>&#39;&uuml;n m&uuml;mk&uuml;nse daha iyi bir se&ccedil;enek olmasının ana nedeni budur.</p>\n\n<h3><strong>Yan etkisi</strong></h3>\n\n<p>Tip g&uuml;venliği olmamasına rağmen <code>doReturn-when</code>&#39;ın avantajı yan etkisi olmamasıdır. <em>Mockito&#39;da, ger&ccedil;ek y&ouml;ntem &ccedil;ağrısına bir yan etki olur.</em> Bunu anlamak i&ccedil;in, ger&ccedil;ek bir metot &ccedil;ağırmanın ne zaman ger&ccedil;ekleştiğini bilmemiz gerekir.</p>\n\n<p>Genellikle, bir d&ouml;n&uuml;ş değeri belirtmeden &ouml;nce <code>Mockito.mock</code> ile bir mock nesne oluşturmamız gerekir. Mock nesnenin bir y&ouml;ntemini &ccedil;ağırdığımızda, belirtilen bir değer d&ouml;nd&uuml;r&uuml;r ancak sınıfta tanımladığınız hi&ccedil;bir şeyi yapmaz. Hi&ccedil;bir yan etkisi yoktur, bu nedenle <code>when-thenReturn</code> ve <code>doReturn-when</code>&#39;&uuml;n bir t&uuml;r g&uuml;venliği olması dışında hemen hemen aynı şekilde davranır.</p>\n\n<pre>\n<code class=\"language-java\">User user = Mockito.mock(User.class);\nwhen(user.getName()).thenReturn(\"Lorem\");\ndoReturn(true).when(user).getName());</code></pre>\n\n<p>Fark, <code>Mockito.spy</code> ile bir spy oluşturduğunuzda ortaya &ccedil;ıkar. Bir spy nesne ger&ccedil;ek bir nesneye bağlanır. Bu nedenle, bir y&ouml;ntemi &ccedil;ağırdığınızda ger&ccedil;ek bir y&ouml;ntem &ccedil;ağrısı vardır. Bu, <code>when-thenReturn</code> yaptığımızda bile ge&ccedil;erlidir. Bunun nedeni <code>when</code>&nbsp;parametresidir ve bir y&ouml;ntemi &ccedil;ağırmanın bir yolunu i&ccedil;erir. &Ouml;rneğin; <code>user.getName()</code>. Buna karşılık, <code>doReturn-when</code> kullandığınızda <code>when</code>&nbsp;parametresi yalnızca user olduğunda ge&ccedil;erlidir.</p>\n\n<pre>\n<code class=\"language-java\">User user = Mockito.spy(new User());</code></pre>\n\n<p>Bir yan etki her zaman olmaz, ancak olağan durumlar şunlardır:</p>\n\n<ol>\n	<li>Bir y&ouml;ntem, &ouml;n koşul denetimiyle bir exception atar.</li>\n	<li>Birim testi yaparken bir y&ouml;ntem istemediğinizi yapar. &Ouml;rneğin, ağ veya disk erişimi.</li>\n</ol>\n\n<p>&Ouml;rneğin, liste daha k&uuml;&ccedil;&uuml;kse <code>List#get()</code> bir istisna atar. doReturn, istisna olmadan bir değer belirtebilir.</p>\n\n<pre>\n<code class=\"language-java\">List list = new LinkedList();\nList spy = spy(list);\n\n// Problem: gerçek yöntem spy.get(0) olarak adlandırılır ve IndexOutOfBoundsException\'ı atar (liste henüz boş)\nwhen(spy.get(0)).thenReturn(\"foo\");\n\n// Stubbing için doReturn() kullanmalıyız\ndoReturn(\"foo\").when(spy).get(0);</code></pre>\n\n<p>Başka bir &ouml;rnek, birim testi i&ccedil;in bir sınıf davranışını değiştirmektir. <code>AccountService</code>, test edilecek bir hedeftir, bu nedenle mocklanamaz. <code>Mocktio.spy</code> ve <code>doReturn</code>(), ağ erişimi olmadan birim testi yapabilirsiniz.</p>\n\n<pre>\n<code class=\"language-java\">public class AccountService extends IntentService {\n    @Override\n    protected void onHandleIntent(Intent intent) {\n        if(\"DELETE\".equals(intent.getAction())) {\n            sendDeleteRequest();\n        }\n    }\n    protected void sendDeleteRequest() {\n        // Network access\n    }\n}</code></pre>\n\n<pre>\n<code class=\"language-java\">@RunWith(RobolectricTestRunner.class)\npublic class AccountServiceTest {\n\n    @Test\n    public void shouldSendDeleteRequest_whenDeleteAction() {\n        AccountService accountService = spy(new AccountService(\"Account\"));\n        doNothing().when(accountService).sendDeleteRequest();\n\n        accountService.onHandleIntent(new Intent(\"DELETE\"));\n\n        verify(accountService).sendDeleteRequest();\n    }\n}</code></pre>\n\n<blockquote>\n<p>Herhangi bir yan etki yoksa, spy nesnesi i&ccedil;in <code>when-thenReturn</code>&#39;&uuml; kullanabiliriz.</p>\n</blockquote>\n\n<pre>\n<code class=\"language-java\">User user = Mockito.spy(new User());\nwhen(user.getName()).thenReturn(\"John\");</code></pre>\n\n<ul>\n	<li><code>when(...) thenReturn(...)</code>, belirtilen değer d&ouml;nd&uuml;r&uuml;lmeden hemen &ouml;nce ger&ccedil;ek bir metod &ccedil;ağrısı yapar. Yani &ccedil;ağrılan metod bir exception atarsa, onunla uğraşmamız gerekir.</li>\n	<li><code>doReturn(...) when(...)</code>, metod &ccedil;ağrısı yapmaz.</li>\n</ul>\n\n<pre>\n<code class=\"language-java\">public class TestClass {\n     protected String testEdilecekMetod() {\n          throw new NullPointerException();\n     }\n}</code></pre>\n\n<pre>\n<code class=\"language-java\">@Spy\nTestClass testClass;\n\n// metodu çağırmadığı için çalışır\ndoReturn(\"test\").when(testClass).testEdilecekMetod();\n\n// metod\'u çağırdığı için NullPointerException fırlatır\nwhen(testClass.testEdilecekMetod()).thenReturn(\"test\");</code></pre>\n\n<h3><strong>Sonu&ccedil;</strong></h3>\n\n<p><code>doReturn-when</code>, spy yapılan bir nesne &uuml;zerinde bir yan etki yaratmadan bir d&ouml;n&uuml;ş değeri belirtmek i&ccedil;in kullanabiliriz. Yararlıdır, ancak nadiren kullanılmalıdır. MVP, MVVM ve dependency injection gibi daha iyi bir kalıbınız ne kadar fazlaysa, <code>Mockito.spy</code>&#39;ı kullanma şansınız o kadar az olur. Ardından, daha g&uuml;venli ve okunabilir olan&nbsp;<code>Mockito.mock</code> kullanabilirsiniz.</p>', 'mockito-doreturn-vs-thenreturn', 'Mockito: doReturn vs thenReturn', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Mockito;Spy'),
('1cb9374e-4e52-4142-a1af-20003ef4a271', '<h3><strong>Comparable Nedir?</strong></h3>\n\n<p>Kendisini başka bir nesneyle karşılaştırmak i&ccedil;in kullanılan bir nesnedir. &Ouml;zel nesnelerin listesini sıralamaya yardımcı olur. <code>java.lang.Comparable</code> interface&#39;ini&nbsp;nesneleri karşılaştırmak i&ccedil;in implement etmeliyiz. Bu interface&#39;i uygulayan nesneler, <code>Arrays.sort</code> ve <code>Collections.sort</code> y&ouml;ntemleriyle otomatik olarak sıralanır.&nbsp;Orijinal sınıfı etkiler. yani, ger&ccedil;ek sınıf değiştirilir. API&#39;de sık sık uygulanır: Calendar, Wrapper sınıfları, Date ve String. T&uuml;m wrapper sınıfları ve String sınıfı, bu interface&#39;i uygular</p>\n\n<h4><code>CompareTo()</code>: String &uuml;zerinde doğal(Natural) sıralama yapmak i&ccedil;in kullanılır. Doğal sıralamanın anlamı, nesneye uygulanan sıralama d&uuml;zenidir, &ouml;rneğin tamsayıları sıralamak i&ccedil;in sayısal d&uuml;zen, String i&ccedil;in alfabetik sıra vb.</h4>\n\n<pre>\n<code class=\"language-java\">int compareTo(T obj)</code></pre>\n\n<p><code>T</code>, karşılaştıracağınız nesnelerin t&uuml;r&uuml;n&uuml; belirtir. Bu metod,&nbsp;nesneyi <code>T</code> nesnesiyle karşılaştırır.</p>\n\n<ul>\n	<li>Değerler eşitse 0 d&ouml;nd&uuml;r&uuml;r.</li>\n	<li>Nesnenin daha k&uuml;&ccedil;&uuml;k bir değere sahip olması durumunda, bu y&ouml;ntem negatif bir değer d&ouml;nd&uuml;r&uuml;r.</li>\n	<li>Nesne daha y&uuml;ksek bir değere sahipse, pozitif bir değer d&ouml;nd&uuml;r&uuml;r.</li>\n</ul>\n\n<pre>\n<code class=\"language-java\">class OrnekSinif {\n    public static void main(String[] args) {\n        String str_Sample = \"a\";\n        System.out.println(\"Compare To \'a\' b is : \" + str_Sample.compareTo(\"b\"));\n        str_Sample = \"b\";\n        System.out.println(\"Compare To \'b\' a is : \" + str_Sample.compareTo(\"a\"));\n        str_Sample = \"b\";\n        System.out.println(\"Compare To \'b\' b is : \" + str_Sample.compareTo(\"b\"));\n    }\n}\n/*\nCompare To \'a\' b is : -1\nCompare To \'b\' a is : 1\nCompare To \'b\' b is : 0\n*/</code></pre>\n\n<p>Alfabetik olarak &quot;a&quot; karakteri &quot;b&quot;den &ouml;nce gelir. Bu nedenle, ilk &ccedil;ıktı -1&#39;dir. &quot;b&quot; karakteri alfabetik olarak &quot;a&quot;dan sonra gelir. Dolayısıyla &ccedil;ıktı ikinci 1&#39;dir. Son &ccedil;ıktı değerler eşit olduğu i&ccedil;in 0&#39;dır.</p>\n\n<h3><strong><code>Comparator Nedir?</code></strong></h3>\n\n<p>Farklı sınıfların farklı nesnelerini karşılaştırmak i&ccedil;in kullanılan bir nesnedir. Kullanıcı tanımlı sınıfların nesnelerini d&uuml;zenlemek i&ccedil;in de kullanılır. <code>compare </code>(Object obj1, Object obj2) ve <code>equals </code>(Object element) olarak bilinen iki &ouml;nemli karşılaştırıcı arabirim y&ouml;ntemini i&ccedil;erir.&nbsp;<code>java.util</code> paketinde bulunur.&nbsp;Sıralamak istenilen sınıf&nbsp;bir comparator interface uygulamasına gerek yoktur.&nbsp;Orijinal sınıfı etkilemez, yani ger&ccedil;ek sınıf değiştirilmez.&nbsp;Uygulanan tek Comparator sınıfları, Collator ve RuleBasedColator&#39;dır.</p>\n\n<p><code>Compare()</code>:&nbsp;nesneleri sıralamamızı sağlar. Bunu yapmak i&ccedil;in comparator interface&#39;i uygulayan bir sınıf oluşturmanız gerekir. Bundan sonra, karşılaştırma y&ouml;ntemini ge&ccedil;ersiz kılmanız gerekir.</p>\n\n<pre>\n<code class=\"language-java\">compare(Object obj1, Object obj2)</code></pre>\n\n<p>Yukarıdaki s&ouml;z diziminde obj1 ve obj2, <em>compare()</em> y&ouml;ntemini kullanarak karşılaştırmanız gereken iki nesnedir.</p>\n\n<ul>\n	<li>İlk arg&uuml;man ikinciden k&uuml;&ccedil;&uuml;kse negatif bir tamsayı d&ouml;nd&uuml;r&uuml;r.</li>\n	<li>İlk arg&uuml;man ve ikinci arg&uuml;man eşitse sıfır d&ouml;nd&uuml;r&uuml;r.</li>\n	<li>Bu y&ouml;ntem, ilk arg&uuml;manın ikinciden b&uuml;y&uuml;k olması durumunda pozitif bir tamsayı d&ouml;nd&uuml;rebilir.</li>\n</ul>\n\n<p>İlişkinin ge&ccedil;işli olduğundan emin olmalısınız. &Ouml;rneğin, ((compare(a, b)&gt;0) &amp;&amp; (compare(b, c)&gt;0)) ise compare(a, c)&gt;0 anlamına gelir.</p>\n\n<pre>\n<code class=\"language-java\">class OrnekSinif {\n    public static void main(String[] args) {\n        int x = 20;\n        int y = 30;\n        System.out.println(Integer.compare(x, y));\n\n        int p = 40;\n        int q = 40;\n        System.out.println(Integer.compare(p, q));\n\n        int r = 20;\n        int s = 7;\n        System.out.println(Integer.compare(r, s));\n    }\n}\n/*\n-1\n0\n1\n*/</code></pre>\n\n<p><code>Equals()</code>:&nbsp;Sayı nesnesinin, argument olarak iletilen nesneye eşit olup olmadığını doğrular.</p>\n\n<pre>\n<code class=\"language-java\">public boolean equals(Object o)</code></pre>\n\n<pre>\n<code class=\"language-java\">class OrnekSinif {\n    public static void main(String[] args) {\n        Integer p = 5;\n        Integer q = 20;\n        Integer r =5;\n        Short s = 5;\n\n        System.out.println(p.equals(q));\n        System.out.println(p.equals(r));\n        System.out.println(p.equals(s));\n    }\n}\n/*\nfalse\ntrue\nfalse\n*/</code></pre>\n\n<p><strong>Comparator ve Comparable&nbsp;Ana Farklılıklar:</strong></p>\n\n<ul>\n	<li>Comparable, Java&#39;daki &ouml;ğeleri sıralamak i&ccedil;in <code>compareTo()</code> y&ouml;ntemini sağlarken, Comparator, Java&#39;daki &ouml;ğeleri sıralamak i&ccedil;in <code>compare()</code> y&ouml;ntemini sağlar.</li>\n	<li>Comparable <code>java.lang</code> paketinde bulunurken, Comparator <code>java.util</code> paketinde bulunur.</li>\n	<li>Comparable tek sıralama dizisi sağlarken, Comparator birden &ccedil;ok sıralama dizisi sağlar.</li>\n	<li>Comparable, orijinal sınıfı etkilerken, Comparator orijinal sınıfı etkilemez.</li>\n</ul>\n\n<p><strong>Comparator ve Comparable Best Praktikler;</strong></p>\n\n<ul>\n	<li>Karşılaştırma, belirli bir sınıf i&ccedil;in standart olduğunda comparable&nbsp;kullanabiliriz.</li>\n	<li>Lambdaları comparator ile kullanabiliriz.</li>\n	<li>Mevcut bir&ccedil;ok core sınıflar, comparable uygular.</li>\n	<li>TreeSet ve TreeMap&#39;i veya sıralarken Set veya Map kullanmak m&uuml;mk&uuml;nd&uuml;r.</li>\n	<li>CompareTo() y&ouml;ntemi, comparator olduğu kadar comparable ile de &ccedil;alışır.</li>\n	<li>Comparator&#39;i yalnızca &quot;&lt;&quot; esnekliğine&nbsp;ihtiyacımız olduğunda kullanabiliriz.</li>\n	<li>compareTo() y&ouml;ntemi, ilk nesne diğerinden b&uuml;y&uuml;kse pozitif bir tamsayı, daha d&uuml;ş&uuml;kse negatif ve her ikisi de aynıysa sıfır d&ouml;nd&uuml;r&uuml;r.</li>\n</ul>', 'comparable-vs-comparator', 'Comparable vs Comparator', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Comparable;Comparator'),
('1cb9374e-4e52-4142-a1af-20004ef4a271', '<p>Java&#39;da functional programlama uygulamak i&ccedil;in Java 8&#39;den beri tanıtılan <code>java.util.function</code> paketinin bir par&ccedil;asıdır. Bir arg&uuml;manı alan ve bir sonu&ccedil; &uuml;reten bir işlevi temsil eder.</p>\n\n<p>Dolayısıyla, 2 generic&nbsp;parametre alır:</p>\n\n<ul>\n	<li><strong>T</strong>: giriş arg&uuml;manının t&uuml;r&uuml;n&uuml; belirtir</li>\n	<li><strong>R</strong>: işlevin d&ouml;n&uuml;ş t&uuml;r&uuml;n&uuml; belirtir.</li>\n</ul>\n\n<p>Function t&uuml;r&uuml;ndeki bir nesneye atanan lambda ifadesi, verilen işlevi bağımsız değişkene uygulayan <code>apply()</code> &ouml;ğesini tanımlamak i&ccedil;in kullanılır.</p>\n\n<h3><strong>Fonksiyon Aray&uuml;z&uuml;nde Y&ouml;ntemler</strong></h3>\n\n<p>Aşağıdaki 4 y&ouml;ntemden oluşur:</p>\n\n<h4><code><strong>apply()</strong></code></h4>\n\n<p>Bu y&ouml;ntem, verilen işlevi tek arg&uuml;manına uygular.</p>\n\n<pre>\n<code class=\"language-java\">R apply(T t)</code></pre>\n\n<p><strong>Parametreler</strong>: Bu y&ouml;ntem, işlev arg&uuml;manı olan yalnızca bir <code><strong>t</strong></code> parametresini alır.</p>\n\n<p><strong>Return</strong>: Bu y&ouml;ntem, <code>R</code> t&uuml;r&uuml;ndeki function sonucunu d&ouml;nd&uuml;r&uuml;r.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.function.Function;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        Function&lt;Integer, Double&gt; half = a -&gt; a / 2.0;\n        System.out.println(half.apply(10));\n    }\n}\n// 5.0</code></pre>\n\n<p><code><strong>andThen()</strong></code></p>\n\n<p>Parametreli işlevin ilkinden sonra y&uuml;r&uuml;t&uuml;leceği oluşturulmuş bir işlev d&ouml;nd&uuml;r&uuml;r. Herhangi bir fonksiyonun değerlendirilmesi bir hata verirse, oluşturulan fonksiyonun &ccedil;ağıranına iletilir.</p>\n\n<pre>\n<code class=\"language-java\">default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after)</code></pre>\n\n<p>burada <code><strong>V</strong></code>, fonksiyondan sonra&nbsp;oluşturulan işlevin &ccedil;ıktı tipidir.</p>\n\n<p><strong>Parametreler</strong>: Bu y&ouml;ntem, ge&ccedil;erli olandan sonra uygulanacak olan bir parametreyi kabul eder.</p>\n\n<p><strong>Return Değeri</strong>: Bu y&ouml;ntem, &ouml;nce ge&ccedil;erli işlevi, ardından sonraki işlevi uygulayan birleştirilmiş bir işlev(<strong>composed function</strong>) d&ouml;nd&uuml;r&uuml;r.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.function.Function;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        Function&lt;Integer, Double&gt; half = a -&gt; a / 2.0;\n        half = half.andThen(a -&gt; 3 * a);\n        System.out.println(half.apply(10));\n    }\n}\n// 15.0</code></pre>\n\n<p><strong>Exception</strong>: After işlevi boşsa, bu y&ouml;ntem <strong>NullPointerException</strong>&nbsp;&ouml;ğesini atar.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.function.Function;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        Function&lt;Integer, Double&gt; half = a -&gt; a / 2.0;\n        try {\n            half = half.andThen(null);\n        } catch (Exception e) {\n            System.out.println(\"Exception thrown while passing null: \" + e);\n        }\n    }\n}\n// Exception thrown while passing null: java.lang.NullPointerException</code></pre>\n\n<p><code><strong>compose()</strong></code></p>\n\n<p>Parametreli işlevin &ouml;nce y&uuml;r&uuml;t&uuml;leceği, ardından ilk bulunanın&nbsp;y&uuml;r&uuml;t&uuml;leceği bir işlev d&ouml;nd&uuml;r&uuml;r. Herhangi bir fonksiyonun değerlendirilmesi bir hata verirse, oluşturulan fonksiyonun &ccedil;ağıranına iletilir.</p>\n\n<pre>\n<code class=\"language-java\">default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before)</code></pre>\n\n<p>burada <code><strong>V</strong></code>, &ouml;nceki işlevin ve oluşturulan işlevin girdi tipidir.</p>\n\n<p><strong>Parametreler</strong>: Bu y&ouml;ntem, &ouml;nce uygulanacak olanı sonra da ge&ccedil;erli olan bir parametreyi kabul eder.</p>\n\n<p><strong>Return Değeri</strong>: Bu y&ouml;ntem, parametreleştirilmiş işlevden sonra ge&ccedil;erli işlevi uygulayan composed function d&ouml;nd&uuml;r&uuml;r.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.function.Function;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        Function&lt;Integer, Double&gt; half = a -&gt; a / 2.0;\n        half = half.compose(a -&gt; 3 * a);\n        System.out.println(half.apply(5));\n    }\n}\n// 7.5</code></pre>\n\n<p><strong>Exception</strong>: Before işlevi boşsa, bu y&ouml;ntem <strong>NullPointerException</strong>&nbsp;&ouml;ğesini atar.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.function.Function;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        Function&lt;Integer, Double&gt; half = a -&gt; a / 2.0;\n        try {\n            half = half.compose(null);\n        } catch (Exception e) {\n            System.out.println(\"Exception thrown while passing null: \" + e);\n        }\n    }\n}\n// Exception thrown while passing null: java.lang.NullPointerException</code></pre>\n\n<p><code><strong>identity()</strong></code></p>\n\n<p>Bu y&ouml;ntem, tek arg&uuml;manını d&ouml;nd&uuml;ren bir işlev d&ouml;nd&uuml;r&uuml;r.</p>\n\n<pre>\n<code class=\"language-java\">static &lt;T&gt; Function&lt;T, T&gt; identity()</code></pre>\n\n<p>burada <strong>T</strong>, arg&uuml;manın t&uuml;r&uuml;n&uuml; ve d&ouml;nd&uuml;r&uuml;lecek değeri belirtir</p>\n\n<p><strong>Return:</strong>&nbsp;Bu y&ouml;ntem, kendi bağımsız değişkenini d&ouml;nd&uuml;ren bir <strong>function</strong>&nbsp;d&ouml;nd&uuml;r&uuml;r.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.function.Function;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        Function i = Function.identity();\n        System.out.println(i);\n    }\n}\n// java.util.function.Function$$Lambda$1/1910163204@7d6f77cc</code></pre>', 'function-interface', 'Function Interface', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Function Interface'),
('1cb9374e-4e52-4142-a1af-20005ef4a271', '<p>String ile setlenmiş değişkenler daha sonradan değiştirilemez, bu ne demek eğer değişken&#39;in i&ccedil;eriği sonradan değiştirilirse artık bu aynı obje olamayacaktır.</p>\n\n<pre>\n<code class=\"language-java\">class OrnekSinif {\n    public static void main(String[] args) {\n        String s = \"bir\";\n        System.out.println(s.hashCode());\n        s = \"iki\";\n        System.out.println(s.hashCode());\n    }\n}\n// 97547\n// 104327</code></pre>\n\n<p>&Ccedil;ıktıya bakılınca ikisi farklı objeyi refer ediyor. Peki objeyi yeniden yaratmadan i&ccedil;eriğini nasıl değiştiririz?</p>\n\n<h3><strong>StringBuffer</strong></h3>\n\n<p>Thread-safe ve&nbsp;değiştirilebilir bir karakter dizisidir. String gibidir, ancak değiştirilebilir. Dizinin uzunluğu ve i&ccedil;eriği belirli metodlar ile değiştirilebilir.</p>\n\n<p>String Buffer, birden &ccedil;ok iş par&ccedil;acığı tarafından kullanım i&ccedil;in g&uuml;venlidir. Metodlar gerektiğinde senkronize edilir, b&ouml;ylece herhangi bir belirli instance&#39;daki&nbsp;t&uuml;m işlemler, ilgili her bir iş par&ccedil;acığı tarafından yapılan y&ouml;ntem &ccedil;ağrılarının sırası ile tutarlı olan bir seri sırayla ger&ccedil;ekleşiyormuş gibi davranır.</p>\n\n<p>Bir <code>StringBuffer</code>&nbsp;&uuml;zerindeki temel işlemler, herhangi bir t&uuml;rden veriyi kabul etmek&nbsp;<code>append</code>&nbsp;ve <code>insert</code>&nbsp;y&ouml;ntemleri vardır. Her biri, belirli bir veriyi bir dizgeye etkili bir şekilde d&ouml;n&uuml;şt&uuml;r&uuml;p&nbsp;ardından o dizginin karakterlerini string&#39;in&nbsp;arabelleğine ekler. <code>append</code>&nbsp;y&ouml;ntemi her zaman bu karakterleri arabelleğin sonuna ekler; <code>insert</code>&nbsp;y&ouml;ntemi, karakterleri belirtilen bir noktada ekler.</p>\n\n<p>&Ouml;rneğin, <code>z</code>, i&ccedil;eriği &quot;<code>start</code>&quot; olan bir string buffer nesnesine referans ediyorsa, <code>z.append(&quot;le&quot;)</code> y&ouml;ntem &ccedil;ağrısı dize arabelleğinin &quot;<code>startle</code>&quot; i&ccedil;ermesine neden olurken, <code>z.insert(4, &quot;le&quot;)</code> dize arabelleğini &quot;<code>starlet</code>&quot; i&ccedil;erecek şekilde değiştirir.</p>\n\n<p>Genel olarak, sb bir <code>StringBuffer</code>&nbsp;&ouml;rneğine refer ediyorsa, <code>sb.append(x)</code>, <code>sb.insert(sb.length(),&nbsp;x)</code> ile aynı etkiye sahiptir.</p>\n\n<p>Her <code>StringBuffer</code>&#39;ın kapasitesi vardır. StringBuffer&#39;da bulunan karakter dizisinin uzunluğu kapasiteyi aşmadığı s&uuml;rece, yeni bir dahili arabellek dizisi tahsis etmek gerekli değildir. Dahili arabellek taşarsa, otomatik olarak b&uuml;y&uuml;t&uuml;l&uuml;r.</p>\n\n<h3><strong>StringBuilder</strong></h3>\n\n<p>Değişken bir karakter dizisidir. Bu sınıf, <code>StringBuffer</code>&nbsp;ile uyumlu bir API sağlar, ancak senkronizasyon garantisi yoktur. Bu sınıf, <code>StringBuffer</code>&#39;ın tek bir iş par&ccedil;acığı tarafından kullanıldığı yerlerde&nbsp;<code>StringBuffer</code>&nbsp;i&ccedil;in bir yedek olarak kullanılmak &uuml;zere tasarlanmıştır. M&uuml;mk&uuml;n olduğunda, &ccedil;oğu uygulamada daha hızlı olacağı i&ccedil;in bu sınıfın <code>StringBuffer</code>&nbsp;yerine kullanılması &ouml;nerilir.</p>\n\n<p>Bir <code>StringBuilder</code>&nbsp;&uuml;zerindeki temel işlemler, herhangi bir t&uuml;rden veriyi kabul etmek i&ccedil;in aşırı y&uuml;klenen <code>append</code>&nbsp;ve <code>insert</code>&nbsp;y&ouml;ntemleridir. Her biri, belirli bir veriyi bir dizgeye etkili bir şekilde d&ouml;n&uuml;şt&uuml;r&uuml;r ve ardından bu dizgenin karakterlerini string builder&#39;a ekler. <code>append</code>&nbsp;y&ouml;ntemi her zaman bu karakterleri oluşturucunun sonuna ekler; <code>insert</code>&nbsp;y&ouml;ntemi, karakterleri belirtilen bir noktada ekler.</p>\n\n<p>&Ouml;rneğin, <code>z</code>, i&ccedil;eriği &quot;<code>start</code>&quot; olan bir eleman, string builder nesnesine referans ediyorsa, <code>z.append(&quot;le&quot;)</code> metodu, string builder&#39;ı&nbsp;&quot;<code>startle</code>&quot; i&ccedil;ermesine neden olurken, <code>z.insert(4, &quot;le&quot;)</code>,&nbsp;&quot;<code>starlet</code>&quot; olacak şekilde değiştirir.</p>\n\n<p>Genel olarak, sb bir <code>StringBuilder</code>&#39;ı refer ediyorsa, <code>sb.append(x)</code>, <code>sb.insert(sb.length(),&nbsp;x)</code> ile aynı etkiye sahiptir. Her <code>StringBuilder</code>&#39;ın bir kapasitesi vardır. String Builder&#39;da bulunan karakter dizisinin uzunluğu kapasiteyi aşmadığı s&uuml;rece, yeni bir dahili arabellek tahsis etmek gerekli değildir. Dahili arabellek taşarsa, otomatik olarak b&uuml;y&uuml;t&uuml;l&uuml;r. StringBuilder &ouml;rnekleri, birden &ccedil;ok iş par&ccedil;acığı tarafından kullanım i&ccedil;in g&uuml;venli değildir. B&ouml;yle bir senkronizasyon gerekliyse, StringBuffer kullanılması tavsiye edilir.</p>\n\n<ul>\n	<li><strong>StringBuffer</strong>, Java 1.4, <strong>StringBuilder&nbsp;</strong>Java&nbsp;1.5 s&uuml;r&uuml;mlerinde tanıtıldı.</li>\n	<li><strong>StringBuffer</strong> sınıfının senkronize edilmiş bir y&ouml;ntemi vardır, ancak <strong>StringBuilder</strong> sınıfının senkronize edilmiş bir y&ouml;ntemi yoktur.</li>\n	<li><strong>StringBuffer</strong> thread-safe&#39;dir ancak <strong>StringBuilder&nbsp;</strong>değildir.</li>\n	<li><strong>StringBuffer</strong> sınıfı, <strong>StringBuilder&nbsp;</strong>sınıfından daha yavaştır.</li>\n</ul>\n\n<pre>\n<code class=\"language-java\">class OrnekSinif {\n    public static void main(String[] args) {\n        long startTime = System.currentTimeMillis();\n        StringBuffer strbuffer = new StringBuffer(\"Hello\");\n        for (int i = 0; i &lt; 10000; i++) {\n            strbuffer.append(i);\n        }\n        System.out.println(\"StringBuffer Geçen Süre: \" + (System.currentTimeMillis() - startTime) + \"ms\");\n\n        startTime = System.currentTimeMillis();\n        StringBuilder strbuilder = new StringBuilder(\"Hello\");\n        for (int i = 0; i &lt; 10000; i++) {\n            strbuilder.append(i);\n        }\n        System.out.println(\"StringBuilder Geçen Süre: \" + (System.currentTimeMillis() - startTime) + \"ms\");\n    }\n}\n// StringBuffer Geçen Süre: 4ms\n// StringBuilder Geçen Süre: 2ms</code></pre>', 'stringbuilder-vs-stringbuffer', 'StringBuilder vs StringBuffer', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'StringBuilder;StringBuffer'),
('1cb9374e-4e52-4142-a1af-20006ef4a271', '<p>Adı olmayan ve kendisi i&ccedil;in yalnızca tek bir nesnenin oluşturulduğu bir i&ccedil; sınıftır. An anonymous inner class, bir sınıfın veya arabirimin aşırı y&uuml;kleme y&ouml;ntemleri gibi belirli &quot;ekstralar&quot; ile bir nesnenin &ouml;rneğini, aslında bir sınıfı alt sınıflamaya gerek kalmadan oluştururken yararlı olabilir. 2 şekilde oluşturulur:</p>\n\n<ul>\n	<li>Sınıf (soyut veya somut olabilir)</li>\n	<li>Interface</li>\n</ul>\n\n<p><code>S&ouml;zdizimi</code>: Bir kod bloğunda yer alan bir sınıf tanımı olması dışında, bir constructor&#39;ın &ccedil;ağrılması gibidir.</p>\n\n<pre>\n<code class=\"language-java\">// Test interface,abstract/concrete class olabilir\nTest t = new Test() {\n   // implement edilecek metodlar veya veriler\n   public void test_method() {\n      ...\n    }\n};</code></pre>\n\n<pre>\n<code class=\"language-java\">class OrnekSinif {\n    public static void main(String[] args) {\n        Sinif obj=new Sinif();\n        obj.getYas();\n    }\n}\ninterface Yas {\n    int yas = 21;\n    void getYas();\n}\nclass Sinif implements Yas {\n    @Override\n    public void getYas() {\n        System.out.print(\"Yaş: \" + yas);\n    }\n}\n</code></pre>\n\n<p>Programda <code>getYas()</code> metodu ve <code>yas=21</code> ile <code>Yas</code>&nbsp;aray&uuml;z&uuml; oluşturulur. <code>Sinif</code>, <code>Yas</code>&nbsp;arabiriminin uygulama sınıfı olarak yazılmıştır. Programda olduğu gibi ayrı bir <code>Sinif</code> &uuml;retmeye gerek yoktur. Bunun yerine, burada g&ouml;sterildiği gibi <code>Sinif</code> kodunu doğrudan bu parametreye kopyalayalım:</p>\n\n<pre>\n<code class=\"language-java\">class OrnekSinif {\n    public static void main(String[] args) {\n        Yas yas = new Yas() {\n            @Override\n            public void getYas() {\n                System.out.print(\"Yaş: \" + yas);\n            }\n        };\n        yas.getYas();\n    }\n}\ninterface Yas {\n    int yas = 21;\n    void getYas();\n}</code></pre>\n\n<p><code>T&uuml;rleri</code> : Bildirim ve davranışa g&ouml;re 3 t&uuml;r vardır:</p>\n\n<p><strong>Bir sınıfı extends eden</strong>: Bir &Ouml;rneğin, bir Thread sınıfını extend ederek bir iş par&ccedil;acığı oluşturabiliriz. Diyelim ki acil bir iş par&ccedil;acığına ihtiyacımız var, ancak Thread sınıfını her zaman genişleten bir sınıf oluşturmak istemiyoruz. Bu t&uuml;r Anonymous Inner sınıfının yardımıyla hazır bir iş par&ccedil;acığını aşağıdaki gibi tanımlayabiliriz:</p>\n\n<pre>\n<code class=\"language-java\">class OrnekSinif {\n    public static void main(String[] args) {\n        Thread t = new Thread() {\n            public void run() {\n                System.out.println(\"Child Thread\");\n            }\n        };\n        t.start();\n        System.out.println(\"Main Thread\");\n    }\n}\n// Main Thread\n// Child Thread</code></pre>\n\n<p><strong>Bir interface&#39;i implement eden</strong>: &Ouml;rneğin, Runnable arabirimini uygulayarak bir Thread oluşturabileceğimizi de biliyoruz. Burada bir arabirim uygulayan anonim İ&ccedil; sınıf kullanıyoruz.</p>\n\n<pre>\n<code class=\"language-java\">class OrnekSinif {\n    public static void main(String[] args) {\n        Runnable r = new Runnable() {\n            public void run() {\n                System.out.println(\"Child Thread\");\n            }\n        };\n        Thread t = new Thread(r);\n        t.start();\n        System.out.println(\"Main Thread\");\n    }\n}\n// Main Thread\n// Child Thread</code></pre>\n\n<p><strong>Metod/constructor i&ccedil;inde bağımsız değişkenini tanımlayan</strong>: Genellikle grafik kullanıcı arabirimi(GUI) uygulamalarında kullanılır.</p>\n\n<pre>\n<code class=\"language-java\">class OrnekSinif {\n    public static void main(String[] args) {\n        Thread t = new Thread(new Runnable() {\n            public void run() {\n                System.out.println(\"Child Thread\");\n            }\n        });\n        t.start();\n        System.out.println(\"Main Thread\");\n    }\n}\n// Main Thread\n// Child Thread</code></pre>\n\n<p><strong>Normal class vs Anonymous Inner class</strong></p>\n\n<ul>\n	<li>Normal bir sınıf herhangi bir sayıda interface uygulayabilir, ancak anonymous&nbsp;inner sınıf aynı anda yalnızca bir interface uygulayabilir.</li>\n	<li>Normal bir sınıf, bir sınıfı genişletebilir ve aynı anda herhangi bir sayıda interface uygulayabilir. Ancak anonymous&nbsp;inner sınıf, bir sınıfı genişletebilir veya bir interface uygulayabilir, ancak her ikisini birden uygulayamaz.</li>\n	<li>Normal sınıf i&ccedil;in herhangi bir sayıda yapıcı yazabiliriz, ancak anonymous&nbsp;inner sınıf i&ccedil;in herhangi bir yapıcı metod yazamayız &ccedil;&uuml;nk&uuml; anonymous&nbsp;sınıfın herhangi bir adı yoktur ve yapıcı sınıfı tanımlarken yapıcı sınıf adı ile yapıcı adı aynı olmalıdır.</li>\n</ul>', 'anonymous-inner-class', 'Anonymous Inner Class', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Anonymous;Inner'),
('1cb9374e-4e52-4142-a1af-20007ef4a271', '<p>Java regex, resmi Java d&uuml;zenli ifade API&#39;sidir. <em>Java regex</em> ifadesi, <em>Java regular expression</em> kısaltmasıdır. Java 1.4&#39;ten beri standart Java&#39;nın (JSE) par&ccedil;ası olan <code>java.util.regex</code> paketinde bulunur.</p>\n\n<h3><strong>D&uuml;zenli İfadeler</strong></h3>\n\n<p>Metinde arama yapmak i&ccedil;in kullanılan bir metin kalıbıdır.</p>\n\n<ul>\n	<li><code>true</code>&nbsp;/&nbsp;<code>false:&nbsp;</code>Normal ifadenin metinle eşleşip eşleşmediğini belirtir.</li>\n	<li>Bir eşleşme k&uuml;mesi: Metinde bulunan normal ifadenin her oluşumu i&ccedil;in bir eşleşme.</li>\n</ul>\n\n<p>&Ouml;rneğin, bir string&#39;te&nbsp;e-posta adresleri, URL&#39;ler, telefon numaraları, tarihler vb. i&ccedil;in aramak i&ccedil;in normal bir ifade kullanabilirsiniz. Bu, Dize ile farklı normal ifadeleri eşleştirerek yapılabilir. Her normal ifadeyi Dize ile eşleştirmenin sonucu, bir eşleşme seti olacaktır - her bir normal ifade i&ccedil;in bir eşleşme seti (her normal ifade birden fazla kez eşleşebilir).</p>\n\n<h3><strong>Core Sınıfları</strong></h3>\n\n<ul>\n	<li><code>Pattern</code>&nbsp;(<code>java.util.regex.Pattern</code>)</li>\n	<li><code>Matcher</code>&nbsp;(<code>java.util.regex.Matcher</code>)</li>\n</ul>\n\n<p><code>Pattern</code>&nbsp;sınıfı, pattern(normal ifadeler) oluşturmak i&ccedil;in kullanılır. Bir kalıp, kendisini bir metinle eşleştirebilen, nesne bi&ccedil;iminde &ouml;nceden derlenmiş d&uuml;zenli ifadedir.</p>\n\n<p><code>Matcher</code>&nbsp;sınıfı, belirli bir normal ifadeyi bir metinle birden &ccedil;ok kez eşleştirmek i&ccedil;in kullanılır. Başka bir deyişle, metinde normal ifadenin birden &ccedil;ok &ouml;rneğini aramak.</p>\n\n<h3><strong>Pattern &Ouml;rnek</strong></h3>\n\n<p>Bir metnin&nbsp;<code>http://</code>&nbsp;alt dizesini i&ccedil;erip i&ccedil;ermediğini kontrol etmek i&ccedil;in normal bir ifade kullanan basit bir Java regex &ouml;rneği;</p>\n\n<pre>\n<code class=\"language-java\">import java.util.regex.Pattern;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        String text = \"This is the text to be searched for occurrences of the http:// pattern.\";\n        String regex = \".*http://.*\";\n        boolean matches = Pattern.matches(regex, text);\n        System.out.println(\"matches = \" + matches);\n    }\n}\n</code></pre>\n\n<pre>\n<code class=\"language-apache\">matches = true</code></pre>\n\n<p><code>text</code>&nbsp;değişkeni, normal ifadeyle kontrol edilecek metni i&ccedil;erir.</p>\n\n<p><code>pattern</code>&nbsp;değişkeni, bir <code>String</code>&nbsp;olarak normal ifadeyi i&ccedil;erir.</p>\n\n<p>Normal ifade, bir veya daha fazla karakter (.*) ve ardından <code>http://</code> metni ve ardından bir veya daha fazla karakter (.*) i&ccedil;eren t&uuml;m metinlerle eşleşir.</p>\n\n<p>&Uuml;&ccedil;&uuml;nc&uuml; satır, normal ifadenin (pattern) metinle eşleşip eşleşmediğini kontrol etmek i&ccedil;in <code>Pattern.matches()</code> statik y&ouml;ntemini kullanır. Normal ifade metinle eşleşirse, <code>Pattern.matches()</code> true değerini d&ouml;nd&uuml;r&uuml;r. Normal ifade metinle eşleşmiyorsa <code>Pattern.matches()</code> false d&ouml;nd&uuml;r&uuml;r.</p>\n\n<p>&Ouml;rnek, bulunan <code>http://</code> dizesinin alan adı ve sonek (.com, .net vb.) ile ge&ccedil;erli bir URL&#39;nin par&ccedil;ası olup olmadığını ger&ccedil;ekten kontrol etmez. Normal ifade yalnızca <code>http://</code> dizesinin olup olmadığını kontrol eder.</p>\n\n<h3><strong>Matcher &Ouml;rneği</strong></h3>\n\n<p>Bir metin i&ccedil;inde &#39;is&#39; alt dizesinin birden &ccedil;ok &ouml;rneğini bulmak i&ccedil;in Matcher sınıfını kullanan başka bir Java regex &ouml;rneği:</p>\n\n<pre>\n<code class=\"language-java\">import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        String text = \"This is the text which is to be searched for occurrences of the word \'is\'.\";\n\n        String regex = \"is\";\n\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(text);\n\n        int count = 0;\n        while(matcher.find()) {\n            count++;\n            System.out.println(\"found: \" + count + \" : \" + matcher.start() + \" - \" + matcher.end());\n        }\n    }\n}\n</code></pre>\n\n<pre>\n<code class=\"language-apache\">found: 1 : 2 - 4\nfound: 2 : 5 - 7\nfound: 3 : 23 - 25\nfound: 4 : 70 - 72</code></pre>\n\n<p><code>Pattern</code>&nbsp;&ouml;rneğinden bir <code>Matcher</code>&nbsp;&ouml;rneği elde edilir. &Ouml;rnek, bu <code>Matcher</code>&nbsp;&ouml;rneği aracılığıyla, metindeki normal ifadenin t&uuml;m oluşumlarını bulur.</p>\n\n<h3><strong>Syntax</strong></h3>\n\n<p>Normal ifadelerin &ouml;nemli bir y&ouml;n&uuml;, normal ifade s&ouml;zdizimidir. Java, d&uuml;zenli ifadeleri destekleyen tek programlama dili değildir. &Ccedil;oğu modern programlama dili d&uuml;zenli ifadeleri destekler. Normal ifadeleri tanımlayan her dilde kullanılan s&ouml;zdizimi tam olarak aynı değildir. Bu nedenle programlama dilinizin kullandığı s&ouml;z dizimini &ouml;ğrenmeniz gerekecektir.</p>\n\n<h4><strong>Eşleşen Karakterler</strong></h4>\n\n<p>Bakılması gereken ilk şey, belirli bir metne karşı karakterleri eşleştiren normal bir ifadenin nasıl yazılacağıdır.</p>\n\n<pre>\n<code class=\"language-java\">String regex = \"http://\";</code></pre>\n\n<p><code>http://</code>&#39;den &ouml;nce veya sonra hi&ccedil;bir karakter olamaz veya normal ifade metinle eşleşmeyecektir.&nbsp;&Ouml;rneğin, yukarıdaki normal ifade bu metinle eşleşecektir:</p>\n\n<pre>\n<code class=\"language-java\">String text1 = \"http://\";</code></pre>\n\n<p>Ama bu metin değil:</p>\n\n<pre>\n<code class=\"language-java\">String text2 = \"The URL is: http://mydomain.com\";</code></pre>\n\n<p>İkinci dize, eşleşen <code>http://</code>&#39;den &ouml;nce ve sonra gelen karakterleri i&ccedil;erir.</p>\n\n<h3><strong>Meta Karakterler</strong></h3>\n\n<p>Meta karakterler, &ouml;zel anlamlara sahip olarak yorumlanan normal bir ifadedeki karakterlerdir. Bu meta karakterler şunlardır:</p>\n\n<pre>\n<code class=\"language-apache\">&lt; &gt; ( ) [ ] { } \\ ^ - = $ ! | ? * + .</code></pre>\n\n<h3><strong>Escape Karakterler</strong></h3>\n\n<p>Meta karakterlerin &ouml;zel bir anlamı vardır. Bu karakterleri meta karakter anlamlarıyla değil, ger&ccedil;ek bi&ccedil;imleriyle ger&ccedil;ekten eşleştirmek istendiğinde, eşleştirmek istenilen&nbsp;meta karakterden &quot;ka&ccedil;manız/escaped&quot; gerekir. Bir meta karakterden ka&ccedil;mak i&ccedil;in Java normal ifade ka&ccedil;ış karakterini - ters eğik &ccedil;izgi karakterini kullanırız. Bir karakterden ka&ccedil;mak, &ouml;n&uuml;ne ters eğik &ccedil;izgi karakteri koymak anlamına gelir. &Ouml;rneğin, bunun gibi:</p>\n\n<pre>\n<code class=\"language-apache\">\\.</code></pre>\n\n<h3><strong>Herhangi Bir Karakter ile Eşleşme</strong></h3>\n\n<p>Şimdiye kadar sadece &quot;h&quot;, &quot;t&quot;, &quot;p&quot; gibi belirli karakterlerin nasıl eşleştirileceğini g&ouml;rd&uuml;k. Ancak, hangi karakter olduğuna bakılmaksızın herhangi bir karakteri de eşleştirebilirsiniz. Java d&uuml;zenli ifade s&ouml;zdizimi, bunu <code>.</code> karakter (nokta).</p>\n\n<pre>\n<code class=\"language-java\">String regex = \".\";</code></pre>\n\n<p>Bu normal ifade, hangi karakter olursa olsun tek bir karakterle eşleşir. . karakter, daha gelişmiş d&uuml;zenli ifadeler oluşturmak i&ccedil;in diğer karakterlerle birleştirilebilir.</p>\n\n<pre>\n<code class=\"language-java\">String regex = \"H.llo\";</code></pre>\n\n<p>Bu normal ifade, &quot;H&quot; karakterlerini ve ardından herhangi bir karakteri ve ardından &quot;llo&quot; karakterlerini i&ccedil;eren herhangi bir dize ile eşleşir. B&ouml;ylece, bu normal ifade &quot;Hello&quot;, &quot;Merhaba&quot;, &quot;Hallo&quot;, &quot;Hxllo&quot;, &quot;Hullo&quot; vb. t&uuml;m dizelerle eşleşecektir.</p>\n\n<h3><strong>Bir Karakter Setinden Herhangi Biri ile Eşleşme</strong></h3>\n\n<p>Karakter sınıfları olarak adlandırılanları kullanarak belirli bir karakter k&uuml;mesinden herhangi biriyle eşleşmeyi destekler.</p>\n\n<pre>\n<code class=\"language-java\">String regex = \"H[ae]llo\";</code></pre>\n\n<p>Karakter sınıfı (eşleşecek karakter k&uuml;mesi) k&ouml;şeli parantez i&ccedil;ine alınır - başka bir deyişle, normal ifadenin <code>[ae]</code> kısmı. K&ouml;şeli parantezler eşleşmez - yalnızca i&ccedil;lerindeki karakterler.</p>\n\n<p>Karakter sınıfı, hangisine bakılmaksızın, ekteki karakterlerden biriyle eşleşecektir, ancak birden fazla olmayacaktır. Bu nedenle, yukarıdaki normal ifade &quot;Hallo&quot; veya &quot;Hello&quot; iki dizesinden herhangi biriyle eşleşir, ancak başka dizelerle eşleşmez. &quot;H&quot; ve &quot;llo&quot; arasında yalnızca &quot;a&quot; veya &quot;e&quot;ye izin verilir.</p>\n\n<p>Aradaki bir tire ile aralıktaki ilk ve son karakteri belirterek bir karakter aralığını eşleştirilebilir. &Ouml;rneğin, <code>[a-z]</code> karakter sınıfı, hem <code>a</code> hem de <code>z</code> dahil olmak &uuml;zere k&uuml;&ccedil;&uuml;k <code>a</code> ve k&uuml;&ccedil;&uuml;k <code>z</code> arasındaki t&uuml;m karakterlerle eşleşir.</p>\n\n<p>Bir karakter sınıfında birden fazla karakter aralığınız olabilir. &Ouml;rneğin, <code>[a-zA-Z]</code> karakter sınıfı, <code>a</code> ile <code>z</code> arasındaki veya <code>A</code> ile <code>Z</code> arasındaki t&uuml;m harflerle eşleşir.</p>\n\n<p>Rakamlar i&ccedil;in aralıkları da kullanabilirsiniz. &Ouml;rneğin, <code>[0-9]</code> karakter sınıfı, her ikisi de dahil olmak &uuml;zere 0 ile 9 arasındaki karakterlerle eşleşir.</p>\n\n<p>Bir metindeki k&ouml;şeli parantezlerden birini ger&ccedil;ekten eşleştirmek istiyorsanız, onlardan ka&ccedil;manız gerekir.</p>\n\n<pre>\n<code class=\"language-java\">String regex = \"H\\\\[llo\";</code></pre>\n\n<p><code>\\\\[</code>, ka&ccedil;an k&ouml;şeli sol parantezdir. Bu normal ifade, &quot;H[llo&quot; dizesiyle eşleşecektir. Bir karakter sınıfındaki k&ouml;şeli parantezleri eşleştirmek istiyorsanız</p>\n\n<pre>\n<code class=\"language-java\">String regex = \"H[\\\\[\\\\]]llo\";</code></pre>\n\n<p>Karakter sınıfı şu kısımdır: <code>[\\\\[\\\\]]</code>. Karakter sınıfı, ka&ccedil;an iki k&ouml;şeli parantez i&ccedil;erir (<code>\\\\[</code>&nbsp;and&nbsp;<code>\\\\]</code>). Bu normal ifade, &quot;H[llo&quot; ve &quot;H]llo&quot; dizeleriyle eşleşecektir.</p>\n\n<h3><strong>Bir Karakter Aralığını Eşleştirme</strong></h3>\n\n<p>Java normal ifade API&#39;si, eşleşecek bir dizi karakter belirtmeye&nbsp;olanak tanır. Bir karakter aralığı belirtmek, eşleşecek her karakteri a&ccedil;ık&ccedil;a belirtmekten daha kolaydır. &Ouml;rneğin, a&#39;dan z&#39;ye karakterleri şu şekilde eşleştirebiliriz:</p>\n\n<pre>\n<code class=\"language-java\">String regex = \"[a-z]\";</code></pre>\n\n<p>Bu normal ifade, alfabedeki a&#39;dan z&#39;ye herhangi bir tek karakterle eşleşir. Karakter sınıfları b&uuml;y&uuml;k/k&uuml;&ccedil;&uuml;k harfe duyarlıdır. A&#39;dan z&#39;ye t&uuml;m karakterleri b&uuml;y&uuml;k/k&uuml;&ccedil;&uuml;k harf fark etmeksizin eşleştirmek i&ccedil;in hem b&uuml;y&uuml;k hem de k&uuml;&ccedil;&uuml;k harf karakter aralıkları eklemelisiniz.</p>\n\n<pre>\n<code class=\"language-java\">String regex = \"[a-zA-Z]\";</code></pre>\n\n<h3><strong>Rakamları Eşleştirme</strong></h3>\n\n<p>&Ouml;nceden tanımlanmış karakter sınıfına sahip bir sayının rakamlarını <code>\\d</code> koduyla eşleştirebiliriz. Rakam karakter sınıfı, <code>[0-9]</code> karakter sınıfına karşılık gelir.</p>\n\n<p><code>\\</code> karakteri ayrıca Java&#39;da bir ka&ccedil;ış karakteri olduğundan, normal ifadede bir <code>\\d</code> elde etmek i&ccedil;in Java dizesinde iki ters eğik &ccedil;izgiye ihtiyacımız vardır. B&ouml;yle bir d&uuml;zenli ifade dizesi şu şekilde g&ouml;r&uuml;n&uuml;r:</p>\n\n<pre>\n<code class=\"language-java\">String regex = \"Hi\\\\d\";</code></pre>\n\n<p>Bu normal ifade, &quot;Hi&quot; ile başlayan ve ardından bir rakam (<code>0</code> ila <code>9</code>) gelen dizelerle eşleşir. Bu nedenle, &quot;Hi5&quot; dizesiyle eşleşecek, ancak &quot;Hip&quot; dizesiyle eşleşmeyecektir.</p>\n\n<h3><strong>Rakam Olmayanları Eşleştirme</strong></h3>\n\n<p>&Ouml;nceden tanımlanmış karakter sınıfı <code>[\\D]</code> (b&uuml;y&uuml;k harf D) ile yapılabilir. Rakam olmayan karakter sınıfını i&ccedil;eren normal bir ifade:</p>\n\n<pre>\n<code class=\"language-java\">String regex = \"Hi\\\\D\";</code></pre>\n\n<p>Bu normal ifade, &quot;Hi&quot; ile başlayan ve ardından rakam olmayan bir karakter gelen herhangi bir dizeyle eşleşir.</p>\n\n<h3><strong>Karakterleri Eşleştirme</strong></h3>\n\n<p>&Ouml;nceden tanımlanmış karakter sınıfıyla <code>\\w</code> koduyla eşleştirebiliriz. Kelime karakter sınıfı, <code>[a-zA-Z_0-9]</code> karakter sınıfına karşılık gelir.</p>\n\n<pre>\n<code class=\"language-java\">String regex = \"Hi\\\\w\";</code></pre>\n\n<p>Bu normal ifade, &quot;Hi&quot; ile başlayan ve ardından tek bir kelime karakteri gelen herhangi bir dizeyle eşleşir.</p>\n\n<h3><strong>Kelime Olmayan Karakterleri Eşleştirme</strong></h3>\n\n<p>&Ouml;nceden tanımlanmış karakter sınıfı <code>[\\W]</code>(b&uuml;y&uuml;k harf W) ile eşleştirebiliriz. <code>\\</code> karakteri ayrıca Java&#39;da bir ka&ccedil;ış karakteri olduğundan, normal ifadede bir <code>\\w</code> elde etmek i&ccedil;in Java dizesinde iki ters eğik &ccedil;izgiye ihtiyacımız vardır. B&ouml;yle bir d&uuml;zenli ifade dizesi şu şekilde g&ouml;r&uuml;n&uuml;r:</p>\n\n<pre>\n<code class=\"language-java\">String regex = \"Hi\\\\W\";</code></pre>\n\n<h3><strong>Sınırlar</strong></h3>\n\n<p>Bir dizgedeki sınırları(<em>boundaries</em>) da eşleştirebiliriz. Sınır, bir dizenin başı, bir dizenin sonu, bir kelimenin başlangıcı vb. olabilir.</p>\n\n<table style=\"width:736px\">\n	<tbody>\n		<tr>\n			<th style=\"width: 90px;\">Sembol</th>\n			<th style=\"width: 630px;\">A&ccedil;ıklama</th>\n		</tr>\n		<tr>\n			<td style=\"text-align:center; width:90px\">^</td>\n			<td style=\"text-align:center; width:630px\">Satırın başlangıcı</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center; width:90px\">$</td>\n			<td style=\"text-align:center; width:630px\">Satırın sonu</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center; width:90px\">\\b</td>\n			<td style=\"text-align:center; width:630px\">Bir kelime sınırı (bir kelimenin başladığı veya bittiği yer, &ouml;rneğin boşluk, sekme vb.).</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center; width:90px\">\\B</td>\n			<td style=\"text-align:center; width:630px\">S&ouml;zc&uuml;k olmayan bir sınır.</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center; width:90px\">\\A</td>\n			<td style=\"text-align:center; width:630px\">Girişin başlangıcı</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center; width:90px\">\\G</td>\n			<td style=\"text-align:center; width:630px\">&Ouml;nceki eşleşmenin sonu</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center; width:90px\">\\Z</td>\n			<td style=\"text-align:center; width:630px\">Girişin sonu, ancak son sonlandırıcı i&ccedil;in (varsa).</td>\n		</tr>\n		<tr>\n			<td style=\"text-align:center; width:90px\">\\z</td>\n			<td style=\"text-align:center; width:630px\">&nbsp;</td>\n		</tr>\n	</tbody>\n</table>\n\n<h4><strong>Satır Başı (veya Dize)</strong></h4>\n\n<p><code>^</code> sınır eşleştiricisi, Java API belirtimine g&ouml;re bir satırın başlangıcıyla eşleşir. Ancak pratikte yalnızca bir String&#39;in başlangıcıyla eşleşiyor gibi g&ouml;r&uuml;n&uuml;yor. &Ouml;rneğin, aşağıdaki &ouml;rnek 0 dizininde yalnızca tek bir eşleşme alır:</p>\n\n<pre>\n<code class=\"language-java\">String text = \"Line 1\\nLine2\\nLine3\";\n\nPattern pattern = Pattern.compile(\"^\");\nMatcher matcher = pattern.matcher(text);\n\nwhile(matcher.find()){\n    System.out.println(\"Found match at: \"  + matcher.start() + \" to \" + matcher.end());\n}</code></pre>\n\n<p>Giriş dizesi birka&ccedil; satır sonu i&ccedil;erse bile, <code>^</code> karakteri her satırın başlangıcıyla değil, yalnızca giriş dizesinin başlangıcıyla eşleşir. Satır / dize eşleştiricisinin başlangıcı, bir dizenin belirli bir alt dizeyle başlayıp başlamadığını kontrol etmek i&ccedil;in genellikle diğer karakterlerle birlikte kullanılır. &Ouml;rneğin, bu &ouml;rnek, giriş dizesinin <code>http://</code>&nbsp;alt dizesiyle başlayıp başlamadığını kontrol eder:</p>\n\n<pre>\n<code class=\"language-java\">String text = \"http://jenkov.com\";\n\nPattern pattern = Pattern.compile(\"^http://\");\nMatcher matcher = pattern.matcher(text);\n\nwhile(matcher.find()){\n    System.out.println(\"Found match at: \"  + matcher.start() + \" to \" + matcher.end());\n}</code></pre>\n\n<p>Bu &ouml;rnek, giriş akışında dizin 0&#39;dan 7&#39;ye <code>http://</code> alt dizesinin tek bir eşleşmesini bulur. Giriş dizesi <code>http://</code> alt dizesinin daha fazla &ouml;rneğini i&ccedil;erse bile, normal ifade <code>^</code> karakteriyle başladığı i&ccedil;in bu normal ifadeyle eşleşmezdi.</p>\n\n<h4><strong>Satır Sonu(veya Dize)</strong></h4>\n\n<p><code>$</code> sınır eşleştiricisi, Java belirtimine g&ouml;re satırın sonuyla eşleşir. Ancak pratikte, yalnızca giriş dizesinin sonuyla eşleşiyor gibi g&ouml;r&uuml;n&uuml;yor.</p>\n\n<pre>\n<code class=\"language-java\">String text = \"http://jenkov.com\";\n\nPattern pattern = Pattern.compile(\".com$\");\nMatcher matcher = pattern.matcher(text);\n\nwhile(matcher.find()){\n    System.out.println(\"Found match at: \"  + matcher.start() + \" to \" + matcher.end());\n}</code></pre>\n\n<p>Bu &ouml;rnek, giriş dizesinin sonunda tek bir eşleşme bulacaktır.</p>\n\n<h4><strong>Kelime Sınırları</strong></h4>\n\n<p><code>\\b</code>&nbsp;sınır eşleştiricisi, bir s&ouml;zc&uuml;k sınırıyla eşleşir; bu, bir s&ouml;zc&uuml;ğ&uuml;n başladığı veya bittiği bir giriş dizesindeki bir konum anlamına gelir.</p>\n\n<pre>\n<code class=\"language-java\">String text = \"Mary had a little lamb\";\n\nPattern pattern = Pattern.compile(\"\\\\b\");\nMatcher matcher = pattern.matcher(text);\n\nwhile(matcher.find()){\n    System.out.println(\"Found match at: \"  + matcher.start() + \" to \" + matcher.end());\n}</code></pre>\n\n<pre>\n<code class=\"language-bash\">Found match at: 0 to 0\nFound match at: 4 to 4\nFound match at: 5 to 5\nFound match at: 8 to 8\nFound match at: 9 to 9\nFound match at: 10 to 10\nFound match at: 11 to 11\nFound match at: 17 to 17\nFound match at: 18 to 18\nFound match at: 22 to 22</code></pre>\n\n<h4><strong>Kelime Dışı Sınırlar</strong></h4>\n\n<p><code>\\B</code> sınır eşleştiricisi, s&ouml;zc&uuml;k olmayan sınırlarla eşleşir. S&ouml;zc&uuml;k olmayan sınır, her ikisi de aynı s&ouml;zc&uuml;ğ&uuml;n par&ccedil;ası olan iki karakter arasındaki sınırdır. Başka bir deyişle, karakter kombinasyonu, kelimeden kelimeye karakter dizisi değildir.</p>\n\n<pre>\n<code class=\"language-java\">String text = \"Mary had a little lamb\";\n\nPattern pattern = Pattern.compile(\"\\\\B\");\nMatcher matcher = pattern.matcher(text);\n\nwhile(matcher.find()){\n    System.out.println(\"Found match at: \"  + matcher.start() + \" to \" + matcher.end());\n}</code></pre>\n\n<pre>\n<code class=\"language-apache\">Found match at: 1 to 1\nFound match at: 2 to 2\nFound match at: 3 to 3\nFound match at: 6 to 6\nFound match at: 7 to 7\nFound match at: 12 to 12\nFound match at: 13 to 13\nFound match at: 14 to 14\nFound match at: 15 to 15\nFound match at: 16 to 16\nFound match at: 19 to 19\nFound match at: 20 to 20\nFound match at: 21 to 21</code></pre>\n\n<h3><strong>Quantifiers</strong></h3>\n\n<p>Niceleyiciler, karakterleri bir kereden fazla eşleştirmek i&ccedil;in kullanılabilir. Java Regex S&ouml;zdiziminde listelenen &ccedil;eşitli niceleyici t&uuml;rleri vardır.</p>\n\n<p>İlk iki niceleyici <code>*</code> ve <code>+</code> karakterleridir. Bu karakterlerden birini birden &ccedil;ok kez eşleştirmek istediğiniz karakterin arkasına koyarız.</p>\n\n<pre>\n<code class=\"language-java\">String regex = \"Hell*\";</code></pre>\n\n<p>Bu normal ifade, dizeleri &quot;Hell&quot; metniyle ve ardından sıfır veya daha fazla o karakteriyle eşleştirir. B&ouml;ylece, normal ifade &quot;Hell&quot;, &quot;Hello&quot;, &quot;Helloo&quot; vb. ile eşleşecektir.</p>\n\n<p>Nicelik belirteci <code>*</code> karakteri yerine <code>+</code> karakteri olsaydı, dizenin 1 veya daha fazla o karakteriyle bitmesi gerekirdi. İki niceleyici karakterden herhangi birini eşleştirmek istiyorsanız, onlardan ka&ccedil;manız gerekir.</p>\n\n<pre>\n<code class=\"language-java\">String regex = \"Hell\\\\+\";</code></pre>\n\n<p>Bu normal ifade &quot;Hell+&quot; dizesiyle eşleşir; <code>{n}</code> niceleyiciyi kullanarak belirli bir karakterin tam sayısını da eşleştirebilirsiniz; burada n, eşleştirmek istediğiniz karakter sayısıdır.</p>\n\n<pre>\n<code class=\"language-java\">String regex = \"Hello{2}\";</code></pre>\n\n<p>Bu normal ifade, &quot;Helloo&quot; dizesiyle eşleşecektir (sonunda iki o karakterle). Eşleştirmek istediğimiz karakter sayısı i&ccedil;in aşağıdaki gibi bir &uuml;st ve alt sınır belirleyebilirsiniz:</p>\n\n<pre>\n<code class=\"language-java\">String regex = \"Hello{2,4}\";</code></pre>\n\n<p>Bu normal ifade &quot;Helloo&quot;, &quot;Hellooo&quot; ve &quot;Helloooo&quot; dizeleriyle eşleşecektir. Başka bir deyişle, sonunda 2, 3 veya 4 o karakterli &quot;Hell&quot; dizesi.</p>\n\n<h3><strong>Mantıksal Operat&ouml;rler</strong></h3>\n\n<p>Java, birden &ccedil;ok alt modeli tek bir normal ifade i&ccedil;inde birleştirmek i&ccedil;in kullanılabilen bir dizi mantıksal işleci destekler. Java Regex API, iki mantıksal operat&ouml;r&uuml; destekler: <em>and&nbsp;</em>operat&ouml;r&uuml; ve <em>or</em> operat&ouml;r&uuml;.</p>\n\n<p><em>and</em>&nbsp;operat&ouml;r&uuml; implicittir. Normal bir ifadede iki karakter&nbsp;birbirini takip ediyorsa, bu, hem birinci hem de(<em>and</em>) ikinci alt kalıbın hedef dizeyle b&uuml;y&uuml;k &ouml;l&ccedil;&uuml;de eşleştiği anlamına gelir.</p>\n\n<pre>\n<code class=\"language-java\">String text = \"Cindarella and Sleeping Beauty sat in a tree\";\n\nPattern pattern = Pattern.compile(\"[Cc][Ii].*\");\nMatcher matcher = pattern.matcher(text);\n\nSystem.out.println(\"matcher.matches() = \" + matcher.matches());</code></pre>\n\n<p><code>[Cc]</code>,&nbsp;<code>[Ii]</code>&nbsp;ve<code>.*</code> olmak &uuml;zere 3 alt kalıba dikkat edelim. Normal ifadede bu alt kalıplar arasında karakter bulunmadığından, aralarında implict olarak <em>and</em>&nbsp;operat&ouml;r&uuml; vardır. Bu, hedef dizenin bir b&uuml;t&uuml;n olarak normal ifadeyle eşleşmesi i&ccedil;in verilen sırayla 3 alt kalıbın t&uuml;m&uuml; ile eşleşmesi gerektiği anlamına gelir.</p>\n\n<p>Dizeden de g&ouml;rebileceğiniz gibi, ifade dizeyle eşleşir. Dize, b&uuml;y&uuml;k veya k&uuml;&ccedil;&uuml;k harf <code>C</code> ile başlamalı, ardından b&uuml;y&uuml;k harf veya k&uuml;&ccedil;&uuml;k harf <code>I</code> ve ardından sıfır veya daha fazla karakter gelmelidir. Dize bu kriterleri karşılar.</p>\n\n<p><em>or</em>&nbsp;işleci explicttir ve <code>|</code> boru karakteriyle temsil edilir.</p>\n\n<pre>\n<code class=\"language-java\">String text = \"Cindarella and Sleeping Beauty sat in a tree\";\n\nPattern pattern = Pattern.compile(\".*Ariel.*|.*Sleeping Beauty.*\");\nMatcher matcher = pattern.matcher(text);\n\nSystem.out.println(\"matcher.matches() = \" + matcher.matches());</code></pre>\n\n<p>G&ouml;rd&uuml;ğ&uuml;n&uuml;z gibi, model hedef dizide bir yerde ya <code>Ariel</code>&nbsp;alt modeliyle ya da <code>Sleeping Beauty</code> alt modeliyle eşleşecektir. Hedef dize <code>Sleeping Beauty</code> metnini i&ccedil;erdiğinden, normal ifade hedef dizeyle eşleşir.</p>\n\n<h3><strong>Metodlar</strong></h3>\n\n<p>Java String sınıfının da birka&ccedil; normal ifade y&ouml;ntemi vardır.</p>\n\n<p><strong>matches()</strong> Parametre olarak normal bir ifade alır ve normal ifade dizeyle eşleşirse <code>true</code>, değilse <code>false</code>&nbsp;d&ouml;nd&uuml;r&uuml;r.</p>\n\n<pre>\n<code class=\"language-java\">boolean matches = \"one two three two one\".matches(\".*two.*\");</code></pre>\n\n<p><strong>split()</strong> Dizeyi N alt dizeye b&ouml;ler ve bu alt dizelerle bir String dizisi d&ouml;nd&uuml;r&uuml;r. <code>split()</code> y&ouml;ntemi, parametre olarak normal bir ifadeyi alır ve dizeyi, normal ifadenin dizenin bir kısmıyla eşleştiği dizedeki t&uuml;m konumlarda b&ouml;ler. Normal ifade, d&ouml;nd&uuml;r&uuml;len alt dizelerin bir par&ccedil;ası olarak d&ouml;nd&uuml;r&uuml;lmez.</p>\n\n<pre>\n<code class=\"language-java\">String[] twos = \"one two three two one\".split(\"two\");</code></pre>\n\n<p><strong>replaceFirst()</strong> İkinci parametrenin dize değeriyle ilk parametre olarak ge&ccedil;irilen normal ifadenin ilk eşleşmesiyle yeni bir String d&ouml;nd&uuml;r&uuml;r.</p>\n\n<pre>\n<code class=\"language-java\">String s = \"one two three two one\".replaceFirst(\"two\", \"five\");</code></pre>\n\n<p><strong>replaceAll()</strong>&nbsp;İkinci parametrenin dize değeriyle ilk parametre olarak ge&ccedil;irilen normal ifadenin t&uuml;m eşleşmeleriyle yeni bir String d&ouml;nd&uuml;r&uuml;r.</p>\n\n<pre>\n<code class=\"language-java\">String t = \"one two three two one\".replaceAll(\"two\", \"five\");</code></pre>\n\n<p>&nbsp;</p>', 'regex', 'Regex', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Regex'),
('1cb9374e-4e52-4142-a1af-20008ef4a271', '<p>pom.xml</p>\n\n<pre>\n<code class=\"language-apache\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;org.example&lt;/groupId&gt;\n    &lt;artifactId&gt;example&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n\n    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;\n    &lt;/properties&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;\n            &lt;version&gt;4.3.10.Final&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n            &lt;artifactId&gt;hibernate-search-orm&lt;/artifactId&gt;\n            &lt;version&gt;5.3.0.Final&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;version&gt;8.0.13&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.18.20&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;build&gt;\n        &lt;sourceDirectory&gt;src&lt;/sourceDirectory&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.5.1&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;1.8&lt;/source&gt;\n                    &lt;target&gt;1.8&lt;/target&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre>\n\n<p>Kitap Modelimiz;</p>\n\n<pre>\n<code class=\"language-java\">package main.java;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport javax.persistence.*;\nimport java.io.Serializable;\n\n@Entity\n@Table(name=\"Kitap\")\n@Getter\n@Setter\npublic class Kitap implements Serializable {\n	@Id\n 	@GeneratedValue(strategy=GenerationType.IDENTITY)\n	private int id;\n	private String baslik;\n	private String yazar;\n	private double fiyat;\n}\n</code></pre>\n\n<p>Kitap Servis Sınıfımız;</p>\n\n<pre>\n<code class=\"language-java\">package main.java;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.Query;\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\n\nimport java.util.List;\n\npublic class KitapService {\n\n	  public void kaydet(String title,String author,double price){\n        Session session = HibernateUtil.getSession();\n        Transaction transaction = null;\n        try {\n            transaction = session.beginTransaction();\n            Kitap kitap =new Kitap();\n            kitap.setBaslik(title);\n            kitap.setYazar(author);\n            kitap.setFiyat(price);\n            session.save(kitap);\n            transaction.commit();\n            System.out.println(\"Kitap başarıyla eklendi\");\n        } catch (HibernateException e) {\n            transaction.rollback();\n            e.printStackTrace();\n        } finally {\n            session.close();\n        }\n    }\n\n    public List&lt;Kitap&gt; getKitap(){\n        Session session = HibernateUtil.getSession();\n        Query query = session.createQuery(\"from Kitap\");\n        List&lt;Kitap&gt; kitaps =  query.list();\n        session.close();\n        return kitaps;\n    }\n\n    public int guncelle(Kitap b){\n        if(b.getId() &lt;=0)\n              return 0;\n        Session session = HibernateUtil.getSession();\n        Transaction tx = session.beginTransaction();\n        Query query = session.createQuery(\"update Kitap set baslik = :baslik, yazar=:yazar, fiyat=:fiyat where id = :id\");\n        query.setInteger(\"id\",b.getId());\n        query.setString(\"baslik\",b.getBaslik());\n        query.setString(\"yazar\",b.getYazar());\n        query.setDouble(\"fiyat\",b.getFiyat());\n        int rowCount = query.executeUpdate();\n        System.out.println(\"Toplam Satır: \" + rowCount);\n        tx.commit();\n        session.close();\n        return rowCount;\n   }\n\n    public int sil(int id) {\n        Session session = HibernateUtil.getSession();\n        Transaction tx = session.beginTransaction();\n        Query query = session.createQuery(\"delete from Kitap where id = :id\");\n        query.setInteger(\"id\",id);\n        int rowCount = query.executeUpdate();\n        System.out.println(\"Toplam Satır: \" + rowCount);\n        tx.commit();\n        session.close();\n        return rowCount;\n    }\n}\n</code></pre>\n\n<p>Hibernate Config Sınıfımız;</p>\n\n<pre>\n<code class=\"language-java\">package main.java;\n\nimport org.hibernate.Session;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.cfg.Configuration;\n\npublic class HibernateUtil {\n	  private static final HibernateUtil instance = new HibernateUtil();\n    private final SessionFactory sessionFactory;\n\n    private HibernateUtil(){\n        Configuration configuration = new Configuration();\n        configuration.configure(\"hibernate.cfg.xml\");\n        sessionFactory = configuration.buildSessionFactory();\n    }\n\n    public static HibernateUtil getInstance(){\n        return instance;\n    }\n\n    public static Session getSession(){\n        return getInstance().sessionFactory.openSession();\n    }\n}\n</code></pre>\n\n<p>hibernate.cfg.xml</p>\n\n<pre>\n<code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE hibernate-configuration PUBLIC\n		\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n		\"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;\n&lt;hibernate-configuration&gt;\n    &lt;session-factory&gt;\n        &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt;\n        &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql://localhost:3310/hibernate?useSSL=false&lt;/property&gt;\n        &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt;\n        &lt;property name=\"hibernate.connection.password\"&gt;senocak&lt;/property&gt;\n\n        &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;\n        &lt;property name=\"current_session_context_class\"&gt;thread&lt;/property&gt;\n        &lt;property name=\"show_sql\"&gt;true&lt;/property&gt;\n        &lt;property name=\"hbm2ddl.auto\"&gt;update&lt;/property&gt;\n        &lt;mapping class=\"main.java.Kitap\"/&gt;\n    &lt;/session-factory&gt;\n&lt;/hibernate-configuration&gt;\n</code></pre>\n\n<p>Main Sınıfımız;</p>\n\n<pre>\n<code class=\"language-java\">package main.java;\n\nimport java.util.List;\n\npublic class Application {\n\n	public static void main(String[] args) {\n\n		KitapService b=new KitapService();\n		b.kaydet(\"Ferman\", \"Padişah Vahdettin\", 1);\n\n		List&lt;Kitap&gt; bt=b.getKitap();\n		System.out.println(bt.get(0).getYazar());\n\n		Kitap kitap =new Kitap();\n		kitap.setYazar(\"Mustafa Kemal ATATÜRK\");\n		kitap.setBaslik(\"Nutuk\");\n		kitap.setFiyat(100);\n		kitap.setId(1);\n		System.out.println(b.guncelle(kitap));\n\n		System.out.println(b.sil(2));\n	 }\n}\n</code></pre>\n\n<p>&Ccedil;ıktı;</p>\n\n<pre>\n<code class=\"language-apache\">Hibernate: insert into Kitap (baslik, fiyat, yazar) values (?, ?, ?)\nKitap başarıyla eklendi\nHibernate: select kitap0_.id as id1_0_, kitap0_.baslik as baslik2_0_, kitap0_.fiyat as fiyat3_0_, kitap0_.yazar as yazar4_0_ from Kitap kitap0_\nMustafa Kemal ATATÜRK\nHibernate: update Kitap set baslik=?, yazar=?, fiyat=? where id=?\nToplam Satır: 1\n1\nHibernate: delete from Kitap where id=?\nToplam Satır: 1\n1</code></pre>\n\n<p>Zip Hali;</p>\n\n<p><a href=\"/upload/files/hibernate.7z\" target=\"_blank\">hibernate</a></p>', 'hibernate-crud', 'Hibernate Crud', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'hibernate'),
('1cb9374e-4e52-4142-a1af-20009ef4a271', '<p>Her ikisi de kavramsal olarak iki farklı ama&ccedil; i&ccedil;in kullanılan iki farklı şeydir. Verileri depolamak i&ccedil;in <code>collection</code>&#39;lar&nbsp;kullanılır, bu veriler &uuml;zerinde işlemler ger&ccedil;ekleştirmek i&ccedil;in <code>stream</code>&#39;ler kullanılır.</p>\n\n<h2><strong>Kavramsal Fark</strong></h2>\n\n<p>Collection&#39;lar, verileri <em>List</em>,&nbsp;<em>Set</em>&nbsp;veya&nbsp;<em>Map</em> gibi belirli bir veri yapısında depolamak ve gruplamak i&ccedil;in kullanılır. Ancak stream&#39;ler, array, collection&nbsp;veya I/O kaynakları gibi depolanan veriler &uuml;zerinde <em>filtering</em>,&nbsp;<em>matching</em>,&nbsp;<em>mapping</em>&nbsp;vb. gibi karmaşık veri işleme işlemlerini ger&ccedil;ekleştirmek i&ccedil;in kullanılır. Bu, collection&#39;ların esas olarak verilerle, stream&#39;lerin ise esas olarak veriler &uuml;zerindeki işlemlerle ilgili olduğu anlamına gelir.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.ArrayList;\nimport java.util.List;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        //Collection\'lar genel olarak verileri tutmak için kullanılır\n        List&lt;String&gt; names = new ArrayList&lt;&gt;();\n        names.add(\"Ornek\");\n        names.add(\"Collection\");\n        names.add(\"Stream\");\n\n        //Stream\'ler genel olarak veiler üzerinde işlem yapmak için kullanılır\n        names.stream().distinct().forEach(System.out::println);\n    }\n}\n// Ornek Collection Stream</code></pre>\n\n<h2><strong>Veri Değişikliği</strong></h2>\n\n<p>Collection&#39;lara &ouml;ğe ekleyebilir veya kaldırabiliriz, ancak streams&#39;lere &ouml;ğe ekleyemez veya &ccedil;ıkaramayız. Stream bir kaynağı t&uuml;ketir, &uuml;zerinde işlemler ger&ccedil;ekleştirir ve bir sonu&ccedil; d&ouml;nd&uuml;r&uuml;r.</p>\n\n<h2><strong>External Iteration Vs Internal Iteration</strong></h2>\n\n<p>Java 8 Streams&#39;in ana &ouml;zelliği, akışları kullanırken yineleme konusunda endişelenmemize gerek olmamasıdır. Akışlar bizim i&ccedil;in sahne arkasında dahili olarak yineleme ger&ccedil;ekleştirir. Bir kaynak &uuml;zerinde yapılacak işlemlerden bahsetmemiz yeterlidir.&nbsp;&Ouml;te yandan, yinelemeyi d&ouml;ng&uuml;ler kullanarak koleksiyonlar &uuml;zerinde harici olarak yapmamız gerekir.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.ArrayList;\nimport java.util.List;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        List&lt;String&gt; names = new ArrayList&lt;&gt;();\n        names.add(\"Ornek\");\n        names.add(\"Collection\");\n        names.add(\"Stream\");\n        for (String name : names) {\n            System.out.println(name);\n        }\n        System.out.println(\"-------------\");\n        names.stream().map(String::toUpperCase).forEach(System.out::println);\n    }\n}\n/*\nOrnek\nCollection\nStream\n-------------\nORNEK\nCOLLECTION\nSTREAM\n*/</code></pre>\n\n<h2><strong>Ge&ccedil;iş</strong></h2>\n\n<p>Akışlar yalnızca bir kez ge&ccedil;ilebilir. Akışı bir kez ge&ccedil;ilirse, t&uuml;ketildiği&nbsp;s&ouml;ylenilir. Tekrar ge&ccedil;mek i&ccedil;in kaynaktan tekrar yeni akış almak gerekir. Ancak, koleksiyonlar birden &ccedil;ok kez ge&ccedil;ilebilir.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Stream;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        List&lt;Integer&gt; numbers = Arrays.asList(4, 2, 8, 9, 5, 6, 7);\n        Stream&lt;Integer&gt; numbersGreaterThan5 = numbers.stream().filter(i -&gt; i &gt; 5);\n\n        numbersGreaterThan5.forEach(System.out::println);\n\n        //Error : stream has already been operated upon or closed\n        numbersGreaterThan5.forEach(System.out::println);\n    }\n}\n/*\n8\n9\n6\n7\nException in thread \"main\" java.lang.IllegalStateException: stream has already been operated upon or closed\n	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)\n	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)\n	at OrnekSinif.main(scratch.java:18)\n*/</code></pre>\n\n<h2><strong>Eager Construction vs Lazy Construction</strong></h2>\n\n<p>Collections eagerly oluşturulur, yani t&uuml;m &ouml;ğeler başlangı&ccedil;ta hesaplanır. Ancak, stream&#39;ler&nbsp;lazy oluşturulur, yani ara işlemler, intermediate işlemi &ccedil;ağrılana kadar değerlendirilmez.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.Arrays;\nimport java.util.List;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        List&lt;Integer&gt; numbers = Arrays.asList(4, 2, 8, 9, 5, 6, 7);\n        numbers.stream().filter(i -&gt; i &gt;= 5).limit(3).forEach(System.out::println);\n    }\n}\n// 8 9 5</code></pre>\n\n<p>3 adet sayının 5&#39;ten b&uuml;y&uuml;k olma koşulu sağlanana kadar hesaplanır.</p>\n\n<h2><strong>Sonu&ccedil;</strong></h2>\n\n<table border=\"1\">\n	<tbody>\n		<tr>\n			<td style=\"width:459px\"><strong>Collections</strong></td>\n			<td style=\"width:418px\"><strong>Streams</strong></td>\n		</tr>\n		<tr>\n			<td style=\"width:459px\">Verileri depolamak ve gruplamak i&ccedil;in kullanılır.</td>\n			<td style=\"width:418px\">Veriler &uuml;zerinde işlem yapmak i&ccedil;in kullanılır.</td>\n		</tr>\n		<tr>\n			<td style=\"width:459px\">Koleksiyonlardan &ouml;ğeler ekleyebilir veya kaldırabilirsiniz.</td>\n			<td style=\"width:418px\">Akışlardan &ouml;ğe ekleyemez veya kaldıramazsınız.</td>\n		</tr>\n		<tr>\n			<td style=\"width:459px\">Harici olarak yinelenmelidir.</td>\n			<td style=\"width:418px\">Dahili olarak yinelenir.</td>\n		</tr>\n		<tr>\n			<td style=\"width:459px\">Birden &ccedil;ok kez ge&ccedil;ilebilir.</td>\n			<td style=\"width:418px\">Yalnızca bir kez ge&ccedil;ilebilir.</td>\n		</tr>\n		<tr>\n			<td style=\"width:459px\">Eagerly oluşturulur.</td>\n			<td style=\"width:418px\">Lazy oluşturulur.</td>\n		</tr>\n		<tr>\n			<td style=\"width:459px\">&Ouml;rnek: List, Set, Map&hellip;</td>\n			<td style=\"width:418px\">&Ouml;rnek: filtering, mapping, matching&hellip;</td>\n		</tr>\n	</tbody>\n</table>', 'collections-vs-streams', 'Collections vs Streams', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Collections;Streams'),
('1cb9374e-4e52-4142-a1af-20010ef4a271', '<p>Terminal işlemlerinin aşağıdaki iki temel &ouml;zelliğini unutulmamalı,</p>\n\n<ul>\n	<li>İlkel bir değer (boolean, long...), somut bir t&uuml;r veya void d&ouml;nd&uuml;rebilirler.</li>\n	<li>Eagerly y&uuml;r&uuml;t&uuml;l&uuml;rler ve bir terminal işlemi her zaman bir Stream pipeline&#39;ın son işlemdir.&nbsp;</li>\n</ul>\n\n<h2><strong>allMatch()</strong></h2>\n\n<p>Şu soruyu yanıtlar:&nbsp;Akıştaki t&uuml;m &ouml;ğeler sağlanan bir y&uuml;klemle eşleşirse true d&ouml;nd&uuml;r&uuml;r, aksi takdirde false d&ouml;nd&uuml;r&uuml;r.</p>\n\n<p>Bu bir kısa devre terminal işlemidir, &ccedil;&uuml;nk&uuml; eşleşmeyen herhangi bir eleman bulunursa işlem hemen durur (tıpkı AND operat&ouml;r&uuml;n&uuml;n kısa devre davranışı gibi).</p>\n\n<pre>\n<code class=\"language-java\">import java.util.Arrays;\nimport java.util.List;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        List&lt;Integer&gt; list = Arrays.asList(3, 4, 6, 12, 20);\n        boolean cevap = list.stream().allMatch(n-&gt; n % 3 ==0);\n        System.out.println(cevap);\n    }\n}\n// false</code></pre>\n\n<h2><strong>anyMatch()</strong></h2>\n\n<p>Akıştaki herhangi bir &ouml;ğe sağlanan bir değer ile&nbsp;eşleşirse&nbsp;anyMatch()&nbsp;işlemi true değerini d&ouml;nd&uuml;r&uuml;r.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.Arrays;\nimport java.util.List;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        List&lt;Integer&gt; list = Arrays.asList(3, 4, 6, 12, 20);\n        boolean answer = list.stream().anyMatch(n-&gt; n % 3 ==0);\n        System.out.println(answer);\n    }\n}\n// true</code></pre>\n\n<h2><strong>noneMatch()</strong></h2>\n\n<p>Akıştaki hi&ccedil;bir &ouml;ğe sağlanan bir değer ile eşleşmezse true değerini d&ouml;nd&uuml;r&uuml;r.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.Arrays;\nimport java.util.List;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        List&lt;Integer&gt; list = Arrays.asList(3, 4, 6, 12, 20);\n        boolean answer = list.stream().noneMatch(n-&gt; n % 21 ==0);\n        System.out.println(answer);\n    }\n}\n// true</code></pre>\n\n<h2><strong>collect()</strong></h2>\n\n<p>Bir akıştaki &ouml;ğeleri koleksiyon gibi bir kapsayıcıda toplar. İşlenmiş değerin ArrayList gibi değişken bir sonu&ccedil; kapsayıcısı olduğu değişken azaltma işlemini ger&ccedil;ekleştirir. Bu y&ouml;ntem, yararlı azaltma işlemleri sağlayan bir Collector&nbsp;uygulaması alır. <strong>Collectors&nbsp;</strong>sınıfı, JDK&#39;da yaygın bir uygulamadır.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        List&lt;String&gt; lines = Arrays.asList(\"Ornek\", \"stream\", \"collect\", \"java\");\n        List&lt;String&gt; result = lines.stream().filter(line -&gt; !\"java\".equals(line)).collect(Collectors.toList());\n        result.forEach(System.out::println);\n    }\n}\n// Ornek stream collect</code></pre>\n\n<h2><strong>count()</strong></h2>\n\n<p>Akıştaki toplam &ouml;ğe sayısını d&ouml;nd&uuml;r&uuml;r.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.Arrays;\nimport java.util.List;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        List&lt;Integer&gt; list = Arrays.asList(0, 2, 4, 6, 8, 10, 12);\n        System.out.println(list.stream().count());\n    }\n}\n// 7</code></pre>\n\n<h2><strong>forEach()</strong></h2>\n\n<p>Akıştaki her &ouml;ğe i&ccedil;in bir eylem ger&ccedil;ekleştirir.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        List&lt;Integer&gt; list = Arrays.asList(0, 2, 4, 6, 8, 10, 12);\n        list.stream().sorted(Comparator.reverseOrder()).forEach(System.out::println);\n    }\n}\n// 12 10 8 6 4 2 0</code></pre>\n\n<h2><strong>min()</strong></h2>\n\n<p>Sağlanan karşılaştırıcıya g&ouml;re akıştaki minimum &ouml;ğeyi d&ouml;nd&uuml;ren &ouml;zel bir azaltma işlemidir.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.Arrays;\nimport java.util.List;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        List&lt;Integer&gt; list = Arrays.asList(0, 2, 4, 6, 8, 10, 12);\n        System.out.print(list.stream().min(Integer::compare).get());\n    }\n}\n// 0</code></pre>\n\n<h2><strong>max()</strong></h2>\n\n<p>Sağlanan karşılaştırıcıya g&ouml;re akıştaki maxiumum &ouml;ğeyi d&ouml;nd&uuml;ren &ouml;zel bir azaltma işlemidir.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.Arrays;\nimport java.util.List;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        List&lt;Integer&gt; list = Arrays.asList(0, 2, 4, 6, 8, 10, 12);\n        System.out.print(list.stream().max(Integer::compare).get());\n    }\n}\n// 12</code></pre>\n\n<h2><strong>reduce()</strong></h2>\n\n<p>Akıştaki her &ouml;ğeye bir ikili işle&ccedil; uygular; burada işle&ccedil; i&ccedil;in ilk arg&uuml;man &ouml;nceki uygulamanın d&ouml;n&uuml;ş değeridir ve ikinci arg&uuml;man ge&ccedil;erli akış &ouml;ğesidir.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        List&lt;String&gt; words = Arrays.asList(\"Ornek\", \"stream\", \"reduce\", \"java\");\n\n        Optional&lt;String&gt; longestString = words.stream().reduce((word1, word2) -&gt; word1.length() &gt; word2.length() ? word1 : word2);\n\n        longestString.ifPresent(System.out::println);\n    }\n}\n// reduce</code></pre>', 'terminal-operations', 'Terminal Operations', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'allMatch;anyMatch;noneMatch;collect;count;forEach;min;max;reduce'),
('1cb9374e-4e52-4142-a1af-20011ef4a271', '<p>Java 8&#39;de <em>intermediate </em>işlemleri, bir sorgu bi&ccedil;iminde birden &ccedil;ok işlemi &ccedil;ağırmanıza izin veren başka bir <em>Stream</em>&nbsp;d&ouml;nd&uuml;r&uuml;r. Terminal işlemi &ccedil;ağrılana kadar akış intermediate işlemleri y&uuml;r&uuml;tmez.</p>\n\n<p>T&uuml;m intermediate işlemleri tembeldir, bu nedenle ger&ccedil;ekten bir işlemin&nbsp;sonucu gerekli olana kadar y&uuml;r&uuml;t&uuml;lmezler.</p>\n\n<h2><strong>filter()&nbsp;</strong></h2>\n\n<p>Belirli bir Tahminle(<em>Predicate</em>) eşleşen bir akışın &ouml;ğelerini filtrelememize izin veren <em>Stream&nbsp;</em>interface&#39;ini&nbsp;implement etmiş bir&nbsp;intermediate ara işlemidir, verilen input ile&nbsp;<em>eşleşen</em> akışın &ouml;ğelerinden oluşan bir akış d&ouml;nd&uuml;r&uuml;r.</p>\n\n<pre>\n<code class=\"language-java\">Stream intStream = Stream.of(1, 2, 3, 4, 5);\nStream subStream = intStream.filter(value -&gt; value &gt; 3);\nSystem.out.println(subStream.count()); // 2</code></pre>\n\n<p>Bu program Predicate fonksiyonel aray&uuml;z&uuml;n&uuml; lambda olarak alır ve sayının 3&#39;ten b&uuml;y&uuml;k olup olmadığını kontrol eder.</p>\n\n<h2><strong>map()</strong></h2>\n\n<p>Verilen işlevin bu stream &ouml;ğelerine uygulanmasının sonu&ccedil;larından oluşan bir stream d&ouml;nd&uuml;r&uuml;r.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        Stream&lt;?&gt; strStream = Stream.of(\"Ornek\", \"stream\", \"map\", \"java\");\n\n        Stream&lt;?&gt; subStream2 = strStream.map(string -&gt; {\n            if (string == \"java\") return \"Java8\";\n            return string;\n        });\n\n        System.out.println(subStream2.collect(Collectors.toList()));\n    }\n}\n// [Ornek, stream, map, Java8]</code></pre>\n\n<p>Burada map fonksiyonu, Function t&uuml;r&uuml;nden değişken alır. Fonksiyon, functional interface&#39;dir ve bir&nbsp;<code>apply()</code> metoduna sahiptir. Bu y&ouml;ntem bir değer alır ve başka bir değer d&ouml;nd&uuml;r&uuml;r.&nbsp;&nbsp;map() sarmalayıcı t&uuml;rleri de ara intermediate oprerasyon kategorisine girer.</p>\n\n<p><em>mapToDouble(), mapToLong(), mapToInt()</em></p>\n\n<h2><strong>flatMap()</strong></h2>\n\n<p>Bir koleksiyon listesi i&ccedil;in en iyi sonucu verir. &Ouml;rneği iki listeyle ve bunların <em>flatmap()</em> y&ouml;ntemini kullanarak tek bir akışa nasıl d&ouml;n&uuml;şt&uuml;r&uuml;leceğini g&ouml;stereceğiz.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.stream.Stream;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        String[][] array = new String[][] {{\"a\", \"b\"}, {\"c\", \"d\"}, {\"e\", \"f\"}};\n        String[] result = Stream.of(array).flatMap(Stream::of).toArray(String[]::new);\n\n        for (String s : result) {\n            System.out.println(s);\n        }\n    }\n}\n/*\na\nb\nc\nd\ne\nf\n*/</code></pre>\n\n<pre>\n<code class=\"language-java\">import java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        String[][] array = new String[][]{{\"a\", \"b\"}, {\"c\", \"d\"}, {\"e\", \"f\"}};\n        List&lt;String&gt; collect = Stream.of(array).flatMap(Stream::of).filter(x -&gt; !\"a\".equals(x)).collect(Collectors.toList());\n        collect.forEach(System.out::println);\n    }\n}\n/*\nb\nc\nd\ne\nf\n*/</code></pre>\n\n<p><em>flatMapToInt(), flatMapToLong(), flatMapToDouble()</em> gibi t&uuml;rleri de implement edilmiştir.</p>\n\n<h2><strong>distinct()</strong></h2>\n\n<p>Bu akışın <em>farklı </em>&ouml;ğelerinden&nbsp;(Object.equals(Object)&#39;e g&ouml;re) oluşan bir akış d&ouml;nd&uuml;r&uuml;r.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        Collection&lt;String&gt; list = Arrays.asList(\"A\", \"B\", \"C\", \"D\", \"A\", \"B\", \"C\");\n        List&lt;String&gt; distinctElements = list.stream().distinct().collect(Collectors.toList());\n        System.out.println(distinctElements);\n    }\n}\n// [A, B, C, D]</code></pre>\n\n<h2><strong>sorted()</strong></h2>\n\n<p>Doğal sıraya g&ouml;re sıralanmış bu akışın &ouml;ğelerinden oluşan bir akış d&ouml;nd&uuml;r&uuml;r. Bu akışın &ouml;ğeleri Comparable değilse, terminal işlemi y&uuml;r&uuml;t&uuml;ld&uuml;ğ&uuml;nde bir <code>java.lang.ClassCastException</code> oluşturulabilir.</p>\n\n<p><strong>Not</strong>: Sıralı akışlar i&ccedil;in sıralama sabittir. Sırasız akışlar i&ccedil;in kararlılık garantisi verilmez.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.stream.Stream;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        Stream&lt;?&gt; vegStream = Stream.of(\"Ornek\", \"stream\", \"sort\");\n        Stream&lt;?&gt; sortedStream = vegStream.sorted();\n        sortedStream.forEach(System.out::println);\n    }\n}\n// Ornek sort stream</code></pre>\n\n<h2><strong>peek()</strong></h2>\n\n<p>Bu akışın &ouml;ğelerinden oluşan bir akış d&ouml;nd&uuml;r&uuml;r, ayrıca elde edilen akıştan &ouml;ğeler t&uuml;ketilirken her &ouml;ğe &uuml;zerinde sağlanan eylemi ger&ccedil;ekleştirir. peek() y&ouml;ntemi, Java 8&#39;deki akışlarda hata ayıklamanın en iyi yoludur.</p>\n\n<p><strong>Not</strong>: stream pipeline&nbsp;i&ccedil;in peek() &ccedil;ağırma sırasını tahmin edemeyiz.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        Stream.of(\"bir\", \"iki\", \"üç\", \"dört\")\n            .filter(e -&gt; e.length() &gt; 2)\n            .peek(e -&gt; System.out.println(\"Filtrelenen değer: \" + e))\n            .map(String::toUpperCase)\n            .collect(Collectors.toList());\n    }\n}\n/*\nFiltrelenen değer: bir\nFiltrelenen değer: iki\nFiltrelenen değer: dört\n*/</code></pre>\n\n<h2><strong>limit()</strong></h2>\n\n<p>Verilen sınırlı boyutta bir akış d&ouml;nd&uuml;r&uuml;r. Akıştan kalan &ouml;ğeleri kesecektir.</p>\n\n<p><strong>Not</strong>: <em>limit()</em>&nbsp;sıralı akışlar i&ccedil;in uygundur ve paralel akışlar i&ccedil;in iyi performans sonu&ccedil;ları veremez.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.stream.Stream;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        Stream.of(\"bir\", \"iki\", \"üç\", \"dört\").limit(2).forEach(System.out::println);\n    }\n}\n// bir iki</code></pre>\n\n<h2><strong>skip()</strong></h2>\n\n<p>Verilen n &ouml;ğesini atlar ve bir <strong>Stream</strong> d&ouml;nd&uuml;r&uuml;r. Bu, bir Liste&#39;de veya Akıştaki son n kayıt&#39;ta&nbsp;veya satır &uuml;zerinde herhangi bir işlem yapmak istediğinizde en kullanışlı olanıdır.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.stream.Stream;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        Stream.of(\"bir\", \"iki\", \"üç\", \"dört\").skip(2).forEach(System.out::println);\n    }\n}\n// üç dört</code></pre>', 'intermediate-operations', 'Intermediate Operations', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'filter;map;flatMap;distinct;sorted;peek;limit;skip'),
('1cb9374e-4e52-4142-a1af-20012ef4a271', '<p>Y&uuml;r&uuml;t&uuml;len bir Java programının kendisini incelemesine&nbsp;ve programın dahili &ouml;zelliklerini değiştirmesine izin verir. &Ouml;rneğin, bir Java sınıfının t&uuml;m &uuml;yelerinin adlarını alması ve bunları g&ouml;r&uuml;nt&uuml;lemesi m&uuml;mk&uuml;nd&uuml;r.</p>\n\n<p>Bir Java sınıfını kendi i&ccedil;inden inceleme ve değiştirme yeteneği kulağa pek hoş gelmeyebilir, ancak diğer programlama dillerinde bu &ouml;zellik yoktur. &Ouml;rneğin, bir Pascal, C veya C++ dillerinde, o program i&ccedil;inde tanımlanan işlevler hakkında bilgi edinmenin bir yolu yoktur.</p>\n\n<p>Reflection&#39;ın&nbsp;somut bir kullanımı, yazılım bileşenlerinin bir builder aracılığıyla g&ouml;rsel olarak değiştirilebildiği JavaBeans&#39;tedir. Bu tool, dinamik olarak y&uuml;klenirken Java bileşenlerinin(sınıflarının) &ouml;zelliklerini elde etmek i&ccedil;in yansıma kullanır.</p>\n\n<pre>\n<code class=\"language-java\">import java.lang.reflect.*;\n\nclass OrnekSinif {\n    private int ornekMetod(\n        Object p, int x) throws NullPointerException {\n        if (p == null) throw new NullPointerException();\n        return x;\n    }\n    public static void main(String[] args){\n        try {\n            Class&lt;?&gt; c = Class.forName(\"OrnekSinif\");\n            Method[] m = c.getDeclaredMethods();\n            for (Method method : m)\n                System.out.println(method.toString());\n        }catch (Throwable e) {\n            System.err.println(e);\n        }\n    }\n}\n</code></pre>\n\n<pre>\n<code class=\"language-apache\">public static void OrnekSinif.main(java.lang.String[])\nprivate int OrnekSinif.ornekMetod(java.lang.Object,int) throws java.lang.NullPointerException</code></pre>\n\n<p>Bu program, <code>class.forName</code> kullanarak belirtilen sınıfı y&uuml;kler ve ardından sınıfta tanımlanan y&ouml;ntemlerin listesini almak i&ccedil;in <code>getDeclaredMethods</code>&#39;u &ccedil;ağırır. <code>java.lang.reflect.Method</code>, tek bir sınıf y&ouml;ntemini temsil eden bir sınıftır.</p>\n\n<h4><strong>Reflection Kullanmak i&ccedil;in Ayarlamalar</strong></h4>\n\n<p>Reflection sınıfları <code>Method</code>&#39;lar gibi <code>java.lang.reflect</code> i&ccedil;inde bulunur. Bu sınıfları kullanmak i&ccedil;in izlenmesi gereken &uuml;&ccedil; adım vardır.</p>\n\n<p>İlk adım, işlemek istediğiniz sınıf i&ccedil;in bir <code>java.lang.Class</code> nesnesi elde etmektir. <code>java.lang.Class</code>, &ccedil;alışan bir Java programında sınıfları ve interface&#39;leri temsil etmek i&ccedil;in kullanılır.</p>\n\n<p>Bir Class nesnesi elde etmenin bir yolu şunu s&ouml;ylemektir:</p>\n\n<pre>\n<code class=\"language-java\">Class c = Class.forName(\"java.lang.String\");</code></pre>\n\n<p>İkinci adım, sınıf tarafından bildirilen t&uuml;m y&ouml;ntemlerin bir listesini almak i&ccedil;in <code>getDeclaredMethods</code>&nbsp;gibi bir y&ouml;ntemi &ccedil;ağırmaktır.</p>\n\n<pre>\n<code class=\"language-java\">Method[] m = c.getDeclaredMethods();</code></pre>\n\n<p>Bu bilgi elde edildikten sonra &uuml;&ccedil;&uuml;nc&uuml; adım, bilgiyi işlemek i&ccedil;in yansıma API&#39;sini kullanmaktır.</p>\n\n<pre>\n<code class=\"language-java\">System.out.println(m[0].toString());</code></pre>\n\n<h4><strong><code>instanceof&nbsp;</code>operat&ouml;r &ouml;rneğini sim&uuml;le etme</strong></h4>\n\n<p>Class bilgisi elde edildikten sonra, genellikle bir sonraki adım Class nesnesi hakkında temel sorular sormaktır. &Ouml;rneğin, <code>Class.isInstance</code> y&ouml;ntemi, <code>instanceof</code>&nbsp;operat&ouml;r&uuml;n&uuml; sim&uuml;le etmek i&ccedil;in kullanılabilir:</p>\n\n<pre>\n<code class=\"language-java\">import java.lang.reflect.*;\n\nclass OrnekSinif {\n    public static void main(String[] args){\n\n        try {\n            Class&lt;?&gt; cls = Class.forName(\"OrnekSinif\");\n            boolean b1 = cls.isInstance(new Integer(37));\n            System.out.println(b1);\n            boolean b2 = cls.isInstance(new OrnekSinif2());\n            System.out.println(b2);\n            boolean b3 = cls.isInstance(new OrnekSinif());\n            System.out.println(b3);\n        } catch (Throwable e) {\n            System.err.println(e);\n        }\n    }\n}\n\nclass OrnekSinif2 {}</code></pre>\n\n<pre>\n<code class=\"language-bash\">false\nfalse\ntrue</code></pre>\n\n<p>Bu &ouml;rnekte, <code>OrnekSinif2&nbsp;</code>i&ccedil;in bir Class nesnesi oluşturulur ve ardından sınıf &ouml;rneği nesnelerinin, <code>OrnekSinif2&nbsp;</code>.<code>Integer(37)</code>, yeni <code>OrnekSinif2</code>()&nbsp;olup olmadığı kontrol edilir.</p>\n\n<h4><strong>Bir Sınıfın Metodlarını Bulma</strong></h4>\n\n<p>Reflection&#39;ın en değerli ve temel kullanımlarından biri, bir sınıf i&ccedil;inde hangi y&ouml;ntemlerin tanımlandığını bulmaktır. Bunu yapmak i&ccedil;in aşağıdaki kod kullanılabilir:</p>\n\n<pre>\n<code class=\"language-java\">import java.lang.reflect.*;\n\nclass OrnekSinif {\n    private int ornekMetod(\n        Object p, int x) throws NullPointerException {\n        if (p == null) throw new NullPointerException();\n        return x;\n    }\n\n    public static void main(String[] args) {\n\n        try {\n            Class&lt;?&gt; cls = Class.forName(\"OrnekSinif\");\n\n            Method[] methlist = cls.getDeclaredMethods();\n            for (Method m : methlist) {\n                System.out.println(\"name = \" + m.getName());\n                System.out.println(\"decl class = \" + m.getDeclaringClass());\n\n                Class&lt;?&gt;[] pvec = m.getParameterTypes();\n                for (int j = 0; j &lt; pvec.length; j++)\n                System.out.println(\"param #\" + j + \" \" + pvec[j]);\n\n                Class&lt;?&gt;[] evec = m.getExceptionTypes();\n                for (int j = 0; j &lt; evec.length; j++)\n                System.out.println(\"exc #\" + j + \" \" + evec[j]);\n                System.out.println(\"return type = \" + m.getReturnType());\n\n                System.out.println(\"-----\");\n            }\n        } catch (Throwable e) {\n            System.err.println(e);\n        }\n    }\n}</code></pre>\n\n<p>Program &ouml;nce <code>OrnekSinif</code> i&ccedil;in sınıf a&ccedil;ıklamasını alır ve ardından sınıfta tanımlanan her y&ouml;ntem i&ccedil;in bir <code>Method</code>&nbsp;nesnesi listesi almak &uuml;zere <code>getDeclaredMethods</code>&#39;u &ccedil;ağırır. Bunlar public, protected, package ve private metodları i&ccedil;erir.</p>\n\n<p><code>Method</code>&nbsp;nesnelerinin bir listesi elde edildikten sonra, sadece parametre t&uuml;rleri, exception t&uuml;rleri ve her bir metod i&ccedil;in d&ouml;n&uuml;ş t&uuml;r&uuml; hakkındaki bilgilerin g&ouml;r&uuml;nt&uuml;lenmesi işlemidir. Bu t&uuml;rlerin her biri, ister temel ister sınıf t&uuml;rleri olsun, sırayla bir Sınıf tanımlayıcısı ile temsil edilir. Programın &ccedil;ıktısı ş&ouml;yle:</p>\n\n<pre>\n<code class=\"language-bash\">name = main\ndecl class = class OrnekSinif\nparam #0 class [Ljava.lang.String;\nreturn type = void\n-----\nname = ornekMetod\ndecl class = class OrnekSinif\nparam #0 class java.lang.Object\nparam #1 int\nexc #0 class java.lang.NullPointerException\nreturn type = int\n-----</code></pre>\n\n<h4><strong>Yapıcılar Hakkında Bilgi Edinme</strong></h4>\n\n<p>Bir sınıfın kurucuları hakkında bilgi edinmek i&ccedil;in benzer bir yaklaşım kullanılır. &Ouml;rneğin:</p>\n\n<pre>\n<code class=\"language-java\">import java.lang.reflect.*;\n\nclass OrnekSinif {\n    public OrnekSinif() {}\n    protected OrnekSinif(int i, double d) {}\n\n    public static void main(String[] args) {\n        try {\n            Class&lt;?&gt; cls = Class.forName(\"OrnekSinif\");\n\n            Constructor&lt;?&gt;[] ctorlist = cls.getDeclaredConstructors();\n            for (Constructor&lt;?&gt; ct : ctorlist) {\n                System.out.println(\"name = \" + ct.getName());\n                System.out.println(\"decl class = \" + ct.getDeclaringClass());\n                Class&lt;?&gt;[] pvec = ct.getParameterTypes();\n                for (int j = 0; j &lt; pvec.length; j++)\n                    System.out.println(\"param #\" + j + \" \" + pvec[j]);\n                Class&lt;?&gt;[] evec = ct.getExceptionTypes();\n                for (int j = 0; j &lt; evec.length; j++)\n                    System.out.println(\"exc #\" + j + \" \" + evec[j]);\n                System.out.println(\"-----\");\n            }\n        }catch (Throwable e) {\n            System.err.println(e);\n        }\n    }\n}\n</code></pre>\n\n<p>Bu &ouml;rnekte geri d&ouml;n&uuml;ş t&uuml;r&uuml; bilgisi alınmamıştır, &ccedil;&uuml;nk&uuml; yapıcılar ger&ccedil;ekten ger&ccedil;ek bir d&ouml;n&uuml;ş t&uuml;r&uuml;ne sahip değildir.</p>\n\n<pre>\n<code class=\"language-bash\">name = OrnekSinif\ndecl class = class OrnekSinif\n-----\nname = OrnekSinif\ndecl class = class OrnekSinif\nparam #0 int\nparam #1 double\n-----</code></pre>\n\n<h4><strong>Sınıf Alanlarını &Ouml;ğrenmek</strong></h4>\n\n<p>Bir sınıfta hangi veri alanlarının tanımlandığını bulmak da m&uuml;mk&uuml;nd&uuml;r. Bunu yapmak i&ccedil;in aşağıdaki kod kullanılabilir:</p>\n\n<pre>\n<code class=\"language-java\">import java.lang.reflect.*;\n\nclass OrnekSinif {\n    private double d;\n    public static final int i = 37;\n    String s = \"testing\";\n\n    public static void main(String[] args) {\n        try {\n            Class&lt;?&gt; cls = Class.forName(\"OrnekSinif\");\n\n            Field[] fieldlist = cls.getDeclaredFields();\n            for (Field fld : fieldlist) {\n                System.out.println(\"name = \" + fld.getName());\n                System.out.println(\"decl class = \" + fld.getDeclaringClass());\n                System.out.println(\"type = \" + fld.getType()); int mod = fld.getModifiers();\n                System.out.println(\"modifiers = \" + Modifier.toString(mod));\n                System.out.println(\"-----\");\n            }\n        } catch (Throwable e) {\n            System.err.println(e);\n        }\n    }\n}\n</code></pre>\n\n<p>Bu &ouml;rnek &ouml;ncekilere benzer. Yeni bir &ouml;zellik, <code>Modifier&nbsp;</code>kullanılmasıdır. Bu, bir alan &uuml;yesinde bulunan değiştiricileri temsil eden bir reflection sınıfıdır, &ouml;rneğin&quot;<code>private int</code>&quot;. Değiştiricilerin kendileri bir tamsayı ile temsil edilir ve <code>Modifier.toString</code>, &quot;official&quot; bildirim sırasında bir dize temsili d&ouml;nd&uuml;rmek i&ccedil;in kullanılır (&quot;<code>final</code>&quot;den &ouml;nce &quot;<code>static</code>&quot; gibi). Programın &ccedil;ıktısı ş&ouml;yle:</p>\n\n<pre>\n<code class=\"language-bash\">name = d\ndecl class = class OrnekSinif\ntype = double\nmodifiers = private\n-----\nname = i\ndecl class = class OrnekSinif\ntype = int\nmodifiers = public static final\n-----\nname = s\ndecl class = class OrnekSinif\ntype = class java.lang.String\nmodifiers =\n-----</code></pre>\n\n<p>Y&ouml;ntemlerde olduğu gibi, yalnızca bir sınıfta bildirilen alanlar (<code>getDeclaredFields</code>) hakkında bilgi edinmek veya &uuml;st sınıflarda tanımlanan alanlar (<code>getFields</code>) hakkında bilgi almak m&uuml;mk&uuml;nd&uuml;r.</p>\n\n<p>As with methods, it&#39;s possible to obtain information about just the fields declared in a class (<code>getDeclaredFields</code>), or to also get information about fields defined in superclasses (<code>getFields</code>).</p>\n\n<h4><strong>Ada G&ouml;re Y&ouml;ntemleri &Ccedil;ağırma</strong></h4>\n\n<p>Şimdiye kadar sunulan &ouml;rneklerin t&uuml;m&uuml;, sınıf bilgilerinin elde edilmesiyle ilgilidir. Ancak reflection&#39;ı başka şekillerde kullanmak da m&uuml;mk&uuml;nd&uuml;r, &ouml;rneğin belirli bir isimde bir y&ouml;ntemi &ccedil;ağırmak i&ccedil;in.</p>\n\n<pre>\n<code class=\"language-java\">import java.lang.reflect.*;\n\nclass OrnekSinif {\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    public static void main(String[] args) {\n        try {\n            Class&lt;?&gt; cls = Class.forName(\"OrnekSinif\");\n            Class&lt;?&gt;[] partypes = new Class[2];\n            partypes[0] = Integer.TYPE;\n            partypes[1] = Integer.TYPE;\n            Method meth = cls.getMethod(\"add\", partypes);\n            OrnekSinif ornekSinif = new OrnekSinif();\n            Object[] arglist = new Object[2];\n            arglist[0] = 11;\n            arglist[1] = 22;\n            Object retobj = meth.invoke(ornekSinif, arglist);\n            Integer retval = (Integer)retobj;\n            System.out.println(retval.intValue());\n        } catch (Throwable e) {\n            System.err.println(e);\n        }\n    }\n}\n</code></pre>\n\n<p>Bir programın <code>add</code>&nbsp;y&ouml;ntemini &ccedil;ağırmak istediğini, ancak runtime&#39;a kadar bunu bilmediğini varsayalım. Yani, y&ouml;ntemin adı y&uuml;r&uuml;tme sırasında belirtilir (bu, &ouml;rneğin bir JavaBeans geliştirme ortamı tarafından yapılabilir). Yukarıdaki program bunu yapmanın bir yolunu g&ouml;stermektedir.</p>\n\n<p><code>getMethod</code>, sınıfta iki tamsayı parametre t&uuml;r&uuml;ne sahip ve uygun ada sahip bir y&ouml;ntem bulmak i&ccedil;in kullanılır. Bu y&ouml;ntem bir kez bulunup bir <code>Method</code>&nbsp;nesnesi i&ccedil;inde yakalandıktan sonra, uygun t&uuml;rde bir nesne &ouml;rneğine &ccedil;ağrılır. Bir y&ouml;ntemi &ccedil;ağırmak i&ccedil;in, <code>Integer</code>&nbsp;nesnelerine sarılmış 11 ve 22 temel tamsayı değerleriyle bir parametre listesi oluşturulmalıdır. D&ouml;n&uuml;ş değeri (<strong><code>33</code></strong>) ayrıca bir <code>Integer</code>&nbsp;nesnesine sarılır.</p>\n\n<h4><strong>Yeni Nesneler Oluşturma</strong></h4>\n\n<p>Yapıcılar i&ccedil;in y&ouml;ntem &ccedil;ağırmanın eşdeğeri yoktur, &ccedil;&uuml;nk&uuml; bir yapıcıyı &ccedil;ağırmak yeni bir nesne oluşturmaya eşdeğerdir (en kesin olmak gerekirse, yeni bir nesne oluşturmak hem bellek ayırmayı hem de nesne oluşturmayı i&ccedil;erir). Bu nedenle, &ouml;nceki &ouml;rneğe en yakın eşdeğer şunu s&ouml;ylemektir:</p>\n\n<pre>\n<code class=\"language-java\">import java.lang.reflect.*;\n\nclass OrnekSinif {\n    public OrnekSinif() { }\n\n    public OrnekSinif(int a, int b) {\n        System.out.println(\"a = \" + a + \" b = \" + b);\n    }\n\n    public static void main(String[] args) {\n        try {\n            Class&lt;?&gt; cls = Class.forName(\"OrnekSinif\");\n            Class&lt;?&gt;[] partypes = new Class[2];\n            partypes[0] = Integer.TYPE;\n            partypes[1] = Integer.TYPE;\n            Constructor&lt;?&gt; ct = cls.getConstructor(partypes);\n            Object[] arglist = new Object[2];\n            arglist[0] = 11;\n            arglist[1] = 22;\n            Object retobj = ct.newInstance(arglist);\n        }catch (Throwable e) {\n            System.err.println(e);\n        }\n    }\n}\n</code></pre>\n\n<pre>\n<code class=\"language-bash\">a = 11 b = 22</code></pre>\n\n<p>Bu, belirtilen parametre t&uuml;rlerini işleyen ve nesnenin yeni bir &ouml;rneğini oluşturmak i&ccedil;in onu &ccedil;ağıran bir constructor bulur. Bu yaklaşımın değeri, derleme zamanından ziyade y&uuml;r&uuml;tme zamanında(runtime) constructor arama ve &ccedil;ağırma ile tamamen dinamik olmasıdır.</p>\n\n<h4><strong>Alanların Değerlerini Değiştirme</strong></h4>\n\n<p>Reflection&#39;ın&nbsp;başka bir kullanımı, nesnelerdeki veri alanlarının değerlerini değiştirmektir. Bunun değeri yine yansımanın dinamik doğasından t&uuml;retilir; burada bir alan, y&uuml;r&uuml;t&uuml;lmekte olan bir programda adıyla aranabilir ve ardından değeri değiştirilir. Bu, aşağıdaki &ouml;rnekle g&ouml;sterilmiştir:</p>\n\n<pre>\n<code class=\"language-java\">import java.lang.reflect.*;\n\nclass OrnekSinif {\n    public double d;\n\n    public static void main(String[] args) {\n        try {\n            Class&lt;?&gt; cls = Class.forName(\"OrnekSinif\");\n            Field fld = cls.getField(\"d\");\n            OrnekSinif ornekSinif = new OrnekSinif();\n            System.out.println(\"d = \" + ornekSinif.d);\n            fld.setDouble(ornekSinif, 12.34);\n            System.out.println(\"d = \" + ornekSinif.d);\n        } catch (Throwable e) {\n            System.err.println(e);\n        }\n    }\n}\n</code></pre>\n\n<p>Bu &ouml;rnekte, d alanının değeri 12.34 olarak ayarlanmıştır.</p>\n\n<pre>\n<code class=\"language-apache\">d = 0.0\nd = 12.34</code></pre>\n\n<h4><strong>Dizileri Kullanma</strong></h4>\n\n<p>Reflection&#39;ın&nbsp; son bir kullanımı, dizileri oluşturmak ve manip&uuml;le etmektir. Java dilindeki diziler, &ouml;zel bir sınıf t&uuml;r&uuml;d&uuml;r ve bir <code>Object</code>&nbsp;referansına bir dizi referansı atanabilir.</p>\n\n<pre>\n<code class=\"language-java\">import java.lang.reflect.*;\n\nclass OrnekSinif {\n    public static void main(String[] args) {\n        try {\n            Class&lt;?&gt; cls = Class.forName(\"java.lang.String\");\n            Object arr = Array.newInstance(cls, 10);\n            Array.set(arr, 5, \"this is a test\");\n            String s = (String)Array.get(arr, 5);\n            System.out.println(s);\n        }catch (Throwable e) {\n            System.err.println(e);\n        }\n    }\n}\n</code></pre>\n\n<p>Bu &ouml;rnek, 10 uzunluğunda bir array&nbsp;oluşturur ve ardından dizideki 5. konumu bir dize değerine ayarlar. Değer alınır ve g&ouml;r&uuml;nt&uuml;lenir.</p>\n\n<pre>\n<code class=\"language-bash\">this is a test</code></pre>', 'reflection', 'Reflection', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Reflection'),
('1cb9374e-4e52-4142-a1af-20013ef4a271', '<h3><strong>Process Nedir?</strong></h3>\n\n<p>Process, bir programda belirtilen eylemleri ger&ccedil;ekleştirmenize izin veren bir programın y&uuml;r&uuml;t&uuml;lmesidir. Bir programın &ccedil;alıştığı y&uuml;r&uuml;tme birimi olarak tanımlanabilir. İşletim sistemi, CPU tarafından kullanılan s&uuml;re&ccedil;leri oluşturmanıza, planlamanıza ve sonlandırmanıza yardımcı olur. Ana process tarafından oluşturulan diğer s&uuml;re&ccedil;lere alt process denir.</p>\n\n<h3><strong>Process &Ouml;zellikleri;</strong></h3>\n\n<ul>\n	<li>Her işlemin oluşturulması, her process i&ccedil;in ayrı sistem &ccedil;ağrıları gerektirir.</li>\n	<li>İzole edilmiş bir y&uuml;r&uuml;tme varlığıdır ve veri ve bilgileri paylaşmaz.</li>\n	<li>Process&#39;ler, sistem &ccedil;ağrılarının sayısını &ouml;nemli &ouml;l&ccedil;&uuml;de artıran iletişim i&ccedil;in IPC(Inter-Process Communication / S&uuml;re&ccedil;ler Arası İletişim) mekanizmasını kullanır.</li>\n	<li>Process y&ouml;netimi daha fazla sistem &ccedil;ağrısı alır.</li>\n	<li>Bir process&#39;in yığın belleği ve veri haritası olan stack&#39;ı vardır.</li>\n</ul>\n\n<h3><strong>Thread Nedir?</strong></h3>\n\n<p>Thread, bir s&uuml;recin par&ccedil;ası olan bir y&uuml;r&uuml;tme birimidir. Bir işlem, t&uuml;m&uuml; aynı anda y&uuml;r&uuml;t&uuml;len birden &ccedil;ok iş par&ccedil;acığına sahip olabilir. Bir iş par&ccedil;acığı hafiftir ve bir scheduler tarafından bağımsız olarak y&ouml;netilebilir. Paralelliği kullanarak uygulama performansını artırmanıza yardımcı olur. Birden &ccedil;ok iş par&ccedil;acığı, veri, kod, dosyalar vb. gibi bilgileri paylaşır.</p>\n\n<ul>\n	<li>&Ccedil;ekirdek(Kernel) d&uuml;zeyinde thread</li>\n	<li>Kullanıcı(User) d&uuml;zeyinde thread</li>\n	<li>Hibrit thread</li>\n</ul>\n\n<h3><strong>Thread &Ouml;zellikleri;</strong></h3>\n\n<ul>\n	<li>Tek sistem &ccedil;ağrısı birden fazla thread&nbsp;oluşturabilir</li>\n	<li>Thread&#39;ler veri ve bilgi paylaşır.</li>\n	<li>Thread&#39;ler instruction, global ve heap b&ouml;lgelerini paylaşır. Ancak kendisinin register ve stack&#39;leri vardır.</li>\n	<li>Thread management consumes very few, or no system calls because of communication between threads that can be achieved using shared memory.</li>\n	<li>Thread y&ouml;netimi, paylaşılan bellek kullanılarak elde edilebilen iş par&ccedil;acıkları arasındaki iletişim nedeniyle &ccedil;ok az sistem &ccedil;ağrısı t&uuml;ketir veya hi&ccedil; sistem &ccedil;ağrısı kullanmaz.</li>\n</ul>\n\n<h3><strong>Single Thread&nbsp;Nedir?</strong></h3>\n\n<p>Single thread, temel olarak hafif ve en k&uuml;&ccedil;&uuml;k işleme birimidir. Java, bir &quot;<code>Thread Class</code>&quot; kullanarak thread&#39;leri y&ouml;netir.</p>\n\n<p><strong>user </strong>ve&nbsp;<strong>daemon </strong>olan 2 adet thread vardır.(daemon, uygulamayı temizlemek istediğimizde kullanılır ve arka planda &ccedil;alışır).</p>\n\n<p>Bir uygulama ilk başladığında, user thread oluşturulur.</p>\n\n<pre>\n<code class=\"language-java\">public class Demo{\n	public static void main(String[] args) {\n		System.out.println(\"Single Thread\");\n	}\n}</code></pre>\n\n<h3><strong>Multithreading&nbsp;Nedir?</strong></h3>\n\n<ul>\n</ul>\n\n<p>Multithreading, bir işletim sistemi i&ccedil;inde birden &ccedil;ok y&uuml;r&uuml;tme iş par&ccedil;acığını ifade eder. Basit bir ifadeyle, aynı işlemin iki veya daha fazla iş par&ccedil;acığı aynı anda y&uuml;r&uuml;t&uuml;l&uuml;yor.</p>\n\n<p><strong>Avantajları:</strong></p>\n\n<ul>\n	<li>Thread&#39;ler bağımsız olduğundan, kullanıcılar engellenemez ve zaman zaman birden fazla işlem ger&ccedil;ekleştirebiliriz</li>\n	<li>Thread&#39;ler bağımsız olduğundan, bir iş par&ccedil;acığı bir exception&nbsp;ile karşılaşırsa diğer iş par&ccedil;acıkları etkilenmez.</li>\n</ul>\n\n<h3><strong>Thread Synchronization</strong></h3>\n\n<p>Multithreading işleminde, programların asenkron davranışı vardır. Bir thread veri yazıyorsa ve aynı anda veri okuyan başka bir thread varsa,&nbsp;uygulamada tutarsızlık yaratabilir. İki veya daha fazla iş par&ccedil;acığı tarafından paylaşılan kaynaklara erişim ihtiyacı olduğunda, senkronizasyon yaklaşımı kullanılır.</p>\n\n<p>Java, senkronize davranışı uygulamak i&ccedil;in senkronize y&ouml;ntemler sağlamıştır. Bu yaklaşımda, iş par&ccedil;acığı senkronize bloğun i&ccedil;ine ulaştığında, aynı nesne &uuml;zerinde başka hi&ccedil;bir iş par&ccedil;acığı bu y&ouml;ntemi &ccedil;ağıramaz. T&uuml;m iş par&ccedil;acıkları, bu iş par&ccedil;acığı senkronize bloğu bitirip bundan &ccedil;ıkana kadar beklemek zorundadır.</p>\n\n<p>Bu şekilde, senkronizasyon &ccedil;ok iş par&ccedil;acıklı bir uygulamada yardımcı olur. Bir iş par&ccedil;acığı, diğer iş par&ccedil;acığının y&uuml;r&uuml;t&uuml;lmesini bitirene kadar beklemek zorundadır, ancak diğer iş par&ccedil;acıklarının y&uuml;r&uuml;t&uuml;lmesine izin verilir.</p>\n\n<pre>\n<code class=\"language-java\">Synchronized(object){\n	//Senkronize edilecek ifade bloğu\n}</code></pre>\n\n<pre>\n<code class=\"language-java\">public class Demo implements Runnable{\n	public static void main(String[] args) {\n		Thread thread1 = new Thread(\"Anil1\");\n		Thread thread2 = new Thread(\"Anil2\");\n		thread1.start();\n		thread2.start();\n		System.out.println(\"Thread isimleri:\");\n		System.out.println(thread1.getName());\n		System.out.println(thread2.getName());\n	}\n	@Override\n	public void run() {}\n}</code></pre>\n\n<h3><strong>Ana Farklar</strong></h3>\n\n<ul>\n	<li>Process, bir programın y&uuml;r&uuml;t&uuml;lmekte olduğu anlamına gelirken, thread bir process&#39;in bir b&ouml;l&uuml;m&uuml; anlamına gelir.</li>\n	<li>Process&#39;ler hafif değildir, oysa Thread&#39;ler hafiftir.</li>\n	<li>Process&#39;in sonlandırılması daha fazla zaman alır ve Thread&#39;lerin sonlandırılması daha az zaman alır.</li>\n	<li>Process oluşturma i&ccedil;in daha fazla zaman alırken, Thread oluşturma i&ccedil;in daha az zaman alır.</li>\n	<li>Process, context switching i&ccedil;in daha fazla zaman alırken, Threads&#39;ler daha az zaman alır.</li>\n	<li>Process &ccedil;oğunlukla yalıtılmıştır, oysa Thread&#39;ler belleği paylaşır.</li>\n	<li>Process verileri paylaşmaz ve Thread&#39;ler verileri birbirleriyle paylaşır.</li>\n</ul>', 'process-vs-thread', 'Process vs Thread', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Process;Thread;Multithreading'),
('1cb9374e-4e52-4142-a1af-20014ef4a271', '<p>Java 1.5&#39;ten &ouml;nce, Koleksiyonlar API&#39;si yalnızca ham t&uuml;rleri destekliyordu - bir koleksiyon oluştururken t&uuml;r bağımsız değişkenlerinin parametreleştirilmesinin bir yolu yoktu:</p>\n\n<pre>\n<code class=\"language-java\">List cars = new ArrayList();\ncars.add(new Object());\ncars.add(\"car\");\ncars.add(new Integer(1));</code></pre>\n\n<p>Bu, herhangi bir t&uuml;r&uuml;n eklenmesine izin verir ve &ccedil;alışma zamanında olası <em><strong>runtime exceptionlara</strong></em> yol a&ccedil;ar.</p>\n\n<h3><strong>Generics</strong></h3>\n\n<p>Java 1.5&#39;te, Nesneleri bildirirken ve oluştururken Koleksiyonlar API&#39;sindekiler de dahil olmak &uuml;zere sınıflar i&ccedil;in t&uuml;r bağımsız değişkenlerini parametreleştirmemize izin veren <code>Generics</code> tanıtıldı:</p>\n\n<pre>\n<code class=\"language-java\">List&lt;String&gt; cars = new ArrayList&lt;String&gt;();</code></pre>\n\n<p>Bu noktada, nesne &uuml;retilirken bir şekilde okunamayan parametreleştirilmiş t&uuml;r&uuml; belirtmemiz gerekir:</p>\n\n<pre>\n<code class=\"language-java\">Map&lt;String, List&lt;Map&lt;String, Map&lt;String, Integer&gt;&gt;&gt;&gt; cars = new HashMap&lt;String, List&lt;Map&lt;String, Map&lt;String, Integer&gt;&gt;&gt;&gt;();</code></pre>\n\n<p>Bu yaklaşımın nedeni, geriye d&ouml;n&uuml;k uyumluluk adına ham t&uuml;rlerin h&acirc;l&acirc; mevcut olmasıdır, bu nedenle derleyicinin bu ham t&uuml;rler ile generic&#39;ler arasında ayrım yapması gerekir:</p>\n\n<pre>\n<code class=\"language-java\">List&lt;String&gt; generics = new ArrayList&lt;String&gt;();\nList&lt;String&gt; raws = new ArrayList();</code></pre>\n\n<p>Derleyici hala nesne &uuml;retilirken ham t&uuml;rleri kullanmamıza izin verse de, bize bir uyarı mesajı g&ouml;nderecektir:</p>\n\n<pre>\n<code class=\"language-bash\">ArrayList is a raw type. References to generic type ArrayList&lt;E&gt; should be parameterized</code></pre>\n\n<h3><strong>Diamond Operator</strong></h3>\n\n<p>Java 1.7&#39;de tanıtılan diamond operat&ouml;r&uuml;, t&uuml;r &ccedil;ıkarımı ekler ve <strong>generic&nbsp;</strong>kullanırken atamalardaki ayrıntı d&uuml;zeyini azaltır:</p>\n\n<pre>\n<code class=\"language-java\">List&lt;String&gt; cars = new ArrayList&lt;&gt;();</code></pre>\n\n<p>Java 1.7 derleyicisinin t&uuml;r &ccedil;ıkarımı &ouml;zelliği, &ccedil;ağrıyla eşleşen en uygun oluşturucu bildirimini belirler.</p>\n\n<p>Tasit&nbsp;ve Motor&#39;ler ile&nbsp;&ccedil;alışmak i&ccedil;in aşağıdaki interface ve sınıf hiyerarşisini g&ouml;z &ouml;n&uuml;nde bulundurun:</p>\n\n<pre>\n<code class=\"language-java\">public interface Motor { }\npublic class Dizel implements Motor { }\npublic interface Tasit&lt;T extends Motor&gt; { }\npublic class Araba&lt;T extends Motor&gt; implements Tasit&lt;T&gt; { }</code></pre>\n\n<p>Diamond operat&ouml;r&uuml;n&uuml; kullanarak yeni bir <em>Araba&nbsp;</em>&ouml;rneği oluşturalım:</p>\n\n<pre>\n<code class=\"language-java\">Araba&lt;Dizel&gt; araba = new Araba&lt;&gt;();</code></pre>\n\n<p>Dahili olarak, derleyici Dizel&#39;in&nbsp;Motor aray&uuml;z&uuml;n&uuml;&nbsp;uyguladığını bilir ve ardından, t&uuml;r&uuml; &ccedil;ıkararak uygun bir kurucu belirleyebilir.</p>\n\n<h3><strong>Sonu&ccedil;</strong></h3>\n\n<p>Basit&ccedil;e s&ouml;ylemek gerekirse, diamond operat&ouml;r&uuml; derleyiciye t&uuml;r &ccedil;ıkarımı &ouml;zelliğini ekler ve generic&#39;ler ile tanıtılan atamalardaki ayrıntı d&uuml;zeyini azaltır.</p>', 'diamond-operator', 'Diamond Operator', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Diamond;Generics'),
('1cb9374e-4e52-4142-a1af-20015ef4a271', '<p>Genel olarak, <code>static</code>, &quot;<code>t&uuml;r&uuml;n bir &ouml;rneği yerine t&uuml;r&uuml;n kendisiyle ilişkili</code>&quot; anlamına gelir.&nbsp;</p>\n\n<p>Bu, t&uuml;r&uuml;n bir &ouml;rneğini oluşturmadan statik bir değişkene sahip olabileceğimiz anlamına gelir ve değişkene erişen herhangi bir kod, tam olarak aynı verilere erişir. &Ouml;rnek:</p>\n\n<pre>\n<code class=\"language-java\">Test x = new Test();\nTest y = new Test();\nx.sinifDegiskeni = 10;\ny.sinifDegiskeni = 20;\nSystem.out.println(x.sinifDegiskeni);\n</code></pre>\n\n<p>Konsola 10 yazar:&nbsp;<code>y.sinifDegiskeni</code>&nbsp;ve&nbsp;<code>x.sinifDegiskeni</code>&nbsp;ayrıdır, &ccedil;&uuml;nk&uuml;&nbsp;x&nbsp;ve&nbsp;y&nbsp;farklı nesneleri&nbsp;referans eder. Statik &uuml;yelere referanslar aracılığıyla başvurabilirsiniz, ancak bunu yapmak k&ouml;t&uuml; bir fikirdir. Yapsaydık:</p>\n\n<pre>\n<code class=\"language-java\">Test x = new Test();\nTest y = new Test();\nx.statikDegisken = 10;\ny.statikDegisken = 20;\nSystem.out.println(x.statikDegisken);\n</code></pre>\n\n<p>o zaman&nbsp;20 yazar. Her instance i&ccedil;in sabit olan sadece bir&nbsp;değişken vardır. Bunu şu şekilde yazmak daha net olurdu:</p>\n\n<pre>\n<code class=\"language-java\">Test x = new Test();\nTest y = new Test();\nTest.statikDegisken = 10;\nTest.statikDegisken = 20;\nSystem.out.println(Test.statikDegisken);\n</code></pre>\n\n<p>Bu, davranışı &ccedil;ok daha belirgin hale getirir. Modern IDE&#39;ler genellikle ikinci &ouml;rneğin &uuml;&ccedil;&uuml;nc&uuml;ye d&ouml;n&uuml;şt&uuml;r&uuml;lmesini &ouml;nerir.</p>\n\n<p>Değeri aşağıdaki gibi tanımlanan bir satır i&ccedil;i bildirime sahip olmak i&ccedil;in hi&ccedil;bir neden yoktur, &ccedil;&uuml;nk&uuml; her &ouml;rneğin kendi NUMARASI&nbsp;olacaktır, ancak her zaman aynı değere sahip olacaktır (değişmezdir ve bir değişmez değerle başlatılır). Bu, t&uuml;m &ouml;rnekler i&ccedil;in yalnızca bir <code>final static</code> değişkene sahip olmakla aynıdır.</p>\n\n<pre>\n<code class=\"language-java\">private final int NUMBER = 10;\n</code></pre>\n\n<p>Bu nedenle değişemiyorsa, her &ouml;rnekte bir instance olmasının bir anlamı yoktur. Ancak, bunun gibi bir constructor&#39;da&nbsp;setlenirse daha&nbsp;anlamlıdır:</p>\n\n<pre>\n<code class=\"language-java\">// Tanımlandığında setlenmek zorunda değiliz\nprivate final int cevap;\n\npublic Bilgi(int cvp) {\n   // Yapıcı metod ile değer atanabilir ancak daha sonra değiştirilemez.\n   cevap = cvp;\n}</code></pre>\n\n<p>Şimdi, <code>Bilgi</code>&nbsp;class&#39;ının&nbsp;her &ouml;rneği i&ccedil;in farklı ancak değişmez bir sayı değerine sahip olabiliriz.</p>\n\n<p>Java 5&#39;te <code>enum</code>&#39;lar mevcut olana kadar, <code>static final</code>, sabitleri tanımlamanın&nbsp;genel yoluydu.</p>\n\n<pre>\n<code class=\"language-java\">public class Bilgi {\n    private static final Integer CEVAP = 42;\n\n    public String soruSor(String soru) {\n        return \"Sorulan soru:\" + soru + \", cevap: \" + CEVAP;\n    }\n}</code></pre>\n\n<p>Şimdi cevabı test ama&ccedil;lı değiştirmek istiyoruz:</p>\n\n<pre>\n<code class=\"language-java\">public class BilgiTest {\n    @Test\n    public void testSoruSor() throws Exception {\n        Bilgi bilgi = new Bilgi();\n\n        String cevap = bilgi.soruSor(\"örnek soru?\");\n        assertThat(cevap, is(\"Sorulan soru:örnek soru?, cevap: 42\"));\n\n        setFinalStaticField(Bilgi.class, \"CEVAP\", 41);\n\n        cevap = knowledge.askQuestion(\"örnek soru?\");\n        assertThat(cevap, is(\"Sorulan soru:örnek soru?, cevap: 41\"));\n    }\n\n    private static void setFinalStaticField(Class&lt;?&gt; clazz, String fieldName, Object value)\n            throws ReflectiveOperationException {\n\n        Field field = clazz.getDeclaredField(fieldName);\n        field.setAccessible(true);\n\n        Field modifiers = Field.class.getDeclaredField(\"modifiers\");\n        modifiers.setAccessible(true);\n        modifiers.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);\n\n        field.set(null, value);\n    }\n}</code></pre>\n\n<p>Alanı erişilebilir hale getirip <code>final</code> kaldırarak bunu m&uuml;mk&uuml;n kılıyoruz. Daha sonra alanı reflection kullanılarak editlenebilir.</p>\n\n<h3><strong>static initialization block</strong></h3>\n\n<pre>\n<code class=\"language-java\">{\n    // Bişeyler bişeyler...\n}</code></pre>\n\n<p>Sınıfın bir &ouml;rneği her oluşturulduğunda &ccedil;ağrılır. <em>static block</em>, sınıfın kendisi başlatıldığında, bu t&uuml;rden ka&ccedil; tane nesne oluşturursanız oluşturun, yalnızca bir kez &ccedil;ağrılır.</p>\n\n<pre>\n<code class=\"language-java\">public class Test {\n\n    static{\n        System.out.println(\"Static\");\n    }\n\n    {\n        System.out.println(\"static olmayan block\");\n    }\n\n    public static void main(String[] args) {\n        Test t = new Test();\n        Test t2 = new Test();\n    }\n}</code></pre>\n\n<pre>\n<code class=\"language-bash\">Static\nstatic olmayan block\nstatic olmayan block</code></pre>\n\n<p>&nbsp;</p>', 'private-static-final-alanlar-nasil-degistirilir', 'private static final alanlar nasıl değiştirilir', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'private;static;final'),
('1cb9374e-4e52-4142-a1af-20016ef4a271', '<p>Runnuable ve Callable bir g&ouml;revi farklı bir Thread ile &ccedil;alıştırmak i&ccedil;in kullanılan iki interface&#39;dir.</p>\n\n<p>Callable interface, Runnable interface&#39;den daha yenidir ve&nbsp;Generics, Enum, Static imports ve variable argument method&nbsp;gibi diğer &ouml;nemli değişikliklerle birlikte Java 5&#39;e gelmiştir.&nbsp;Runnable, Java 1 ile gelmiştir.</p>\n\n<p>Hem Callable hem de Runnable interface&#39;ler, herhangi bir iş par&ccedil;acığı tarafından y&uuml;r&uuml;t&uuml;lebilecek bir g&ouml;revi temsil etmek &uuml;zere tasarlanmış olsa da, aralarında bazı &ouml;nemli farklar vardır. Callable ve Runnable interface&#39;ler arasındaki en b&uuml;y&uuml;k fark,</p>\n\n<ul>\n	<li>Runnable&#39;ın <code>run()</code> y&ouml;ntemi geri bir sonu&ccedil; d&ouml;nd&uuml;rmezken, Callable&#39;nın <code>call()</code> y&ouml;ntemi sonu&ccedil; d&ouml;nd&uuml;r&uuml;r. Ek olarak <code>call()</code> y&ouml;ntemi Exception oluşturarak işlemden &ccedil;ıkabilir. Runnable&#39;nın <code>run()</code> y&ouml;ntemi exception fırlatamaz.</li>\n</ul>\n\n<p>Callable, g&ouml;rev kuyruğuna koymak i&ccedil;in <code>submit()</code> y&ouml;ntemini kullanır, ancak Runnable, g&ouml;rev kuyruğuna koymak i&ccedil;in <code>execute()</code> y&ouml;ntemini kullanır.</p>\n\n<p>Callable ve Runnable arabirimler arasındaki bir diğer &ouml;nemli fark, checked exception&#39;ları&nbsp;atma yeteneğidir. Callable interface,&nbsp;checked exception fırlatabilir &ccedil;&uuml;nk&uuml; <code>call()</code> metodu&nbsp;exception fırlatır.</p>\n\n<pre>\n<code class=\"language-java\">public interface Runnable {\n    public abstract void run();\n}\n\npublic class WorkRunnable implements Runnable{\n	@Override\n	public void run() {\n		try {\n			System.out.println(\"Task started\");\n\n			Thread.sleep(1000);\n\n			String name = Thread.currentThread().getName();\n			String state = Thread.currentThread().getState().toString();\n			System.out.println(\"Thread \"+name+\" with state \"+state);\n\n		} catch (InterruptedException e) {\n			e.printStackTrace();\n		}\n	}\n}</code></pre>\n\n<p>Yukarıdaki kod olduk&ccedil;a basittir. Bu runnable sınıf, konsola <code>Task started</code> yazdıracaktır. Sonra bir saniye bekler ve son olarak, g&ouml;revi y&uuml;r&uuml;ten iş par&ccedil;acığının adını yazdıracaktır.</p>\n\n<pre>\n<code class=\"language-java\">public interface Callable&lt;V&gt; {\n    V call() throws Exception;\n}\n\npublic class WorkCallable implements Callable&lt;String&gt;{\n	@Override\n	public String call() throws Exception{\n		try {\n			System.out.println(\"Task started\");\n\n			Thread.sleep(1000);\n\n			String name = Thread.currentThread().getName();\n			String state = Thread.currentThread().getState().toString();\n			System.out.println(\"Thread \"+name+\" with state \"+state);\n\n		} catch (InterruptedException e) {\n			e.printStackTrace();\n		}\n		return \"Task done\";\n	}\n}</code></pre>\n\n<p>Yukarıdaki kod temelde &ouml;nceki &ouml;rnekle aynı şeyi yapıyor: <code>Task started</code>&nbsp;yazıyor, 1 saniye bekliyor ve son olarak thread adı yazdırılıyor.</p>\n\n<p>Ancak bir&nbsp;farklılık vardır, sınıfı uyguladığınızda, geri d&ouml;nen değişkenin t&uuml;r&uuml;n&uuml; belirtmeniz gerekir. Bu &ouml;rnekte <code>Callable</code> bir string d&ouml;nd&uuml;recektir, ancak tanımladığınız bir sınıf dahil olmak &uuml;zere istediğiniz herhangi bir t&uuml;r&uuml; d&ouml;nd&uuml;rebilir.</p>', 'runnable-vs-callable', 'Runnable vs Callable', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Runnable;Callable'),
('1cb9374e-4e52-4142-a1af-20017ef4a271', '<p>Lambda Expressions Java 8&#39;de eklendi ve kısace &quot;<em>parametreleri alan ve bir değer d&ouml;nd&uuml;ren kısa bir kod bloğudur</em>&quot;. Lambda Expressions&nbsp;metodlara benzer, ancak bir isime ihtiya&ccedil; duymazlar ve doğrudan bir metodun g&ouml;vdesinde uygulanabilirler.</p>\n\n<p>En basit olarak&nbsp;tek bir parametre ve bir ifade i&ccedil;erir:</p>\n\n<blockquote>\n<pre>\n<code><em>parameter</em> -&gt; <em>expression</em></code></pre>\n</blockquote>\n\n<p>Birden fazla parametre kullanmak i&ccedil;in bunları parantez i&ccedil;ine alın:</p>\n\n<blockquote>\n<pre>\n<code><em>(parameter1, parameter2)</em> -&gt; <em>expression</em></code></pre>\n</blockquote>\n\n<p>Expressions sınırlıdır. Derhal bir değer d&ouml;nd&uuml;rmeleri gerekir ve <em>if</em> veya <em>for</em> gibi değişkenler, atamalar veya ifadeler i&ccedil;eremezler. Daha karmaşık işlemler yapmak i&ccedil;in k&uuml;me parantezleri ile bir kod bloğu kullanılabilir. Lambda ifadesinin bir değer d&ouml;nd&uuml;rmesi gerekiyorsa kod bloğunun bir <code>return</code> ifadesi olmalıdır.</p>\n\n<blockquote>\n<pre>\n<code><em>(parameter1, parameter2)</em> -&gt; { <em>code block</em> }</code></pre>\n</blockquote>\n\n<p>Lambda expressions genellikle bir fonksiyona parametre olarak iletilir:&nbsp; Listedeki her &ouml;ğeyi yazdırmak i&ccedil;in <code>ArrayList</code>&#39;in&nbsp;<code>forEach()</code>&nbsp;y&ouml;nteminde bir lambda ifadesi kullanalım:</p>\n\n<pre>\n<code class=\"language-java\">import java.util.ArrayList;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList&lt;Integer&gt; numara = new ArrayList&lt;Integer&gt;();\n    numara.add(5);\n    numara.add(9);\n    numara.add(8);\n    numara.add(1);\n    numara.forEach( (n) -&gt; { System.out.println(n); } );\n  }\n}</code></pre>\n\n<p>Değişkenin t&uuml;r&uuml; yalnızca bir y&ouml;ntemi olan bir interface ise, Lambda expression&#39;lar değişkenlerde saklanabilir. O metodla aynı sayıda parametreye ve aynı d&ouml;n&uuml;ş t&uuml;r&uuml;ne sahip olmalıdır. Java&#39;da, listeler tarafından kullanılan <code>Consumer</code> interface (<code>java.util</code> paketinde bulunur) gibi bu t&uuml;r interfacelerin&nbsp;&ccedil;oğu yerleşik olarak bulunur.</p>\n\n<p>Bir değişkende lambda ifadesini depolamak i&ccedil;in Java&#39;nın <code>Consumer</code> interface&#39;ini kullanın:</p>\n\n<pre>\n<code class=\"language-java\">import java.util.ArrayList;\nimport java.util.function.Consumer;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList&lt;Integer&gt; numara = new ArrayList&lt;Integer&gt;();\n    numara.add(5);\n    numara.add(9);\n    numara.add(8);\n    numara.add(1);\n    Consumer&lt;Integer&gt; method = (n) -&gt; { System.out.println(n); };\n    numara.forEach( method );\n  }\n}</code></pre>\n\n<p>Bir y&ouml;ntemde lambda expression kullanmak i&ccedil;in, metodun t&uuml;r&uuml; olarak single-method inteface&#39;ine&nbsp;sahip bir parametreye sahip olması gerekir. Interface&#39;in metodunu &ccedil;ağırmak lambda expression &ccedil;alıştırır. Parametre olarak lambda expression alan bir y&ouml;ntem oluşturalım:</p>\n\n<pre>\n<code class=\"language-java\">interface OrnekInterface {\n  String yaz(String str);\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    OrnekInterface metod1 = (s) -&gt; s + \"!\";\n    OrnekInterface metod2 = (s) -&gt; s + \"?\";\n    ekranaYaz(\"Merhaba\", metod1);\n    ekranaYaz(\"Merhaba\", metod2);\n  }\n  public static void ekranaYaz(String str, OrnekInterface format) {\n    String sonuc = format.yaz(str);\n    System.out.println(sonuc);\n  }\n}</code></pre>\n\n<p>&Ccedil;ıktı;</p>\n\n<pre>\n<code class=\"language-apache\">Merhaba!\nMerhaba?</code></pre>', 'lambda-expressions', 'Lambda Expressions', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Lambda'),
('1cb9374e-4e52-4142-a1af-20018ef4a271', '<p>Java 8 ile birlikte hayatımıza giren en &ouml;nemli &ouml;zelliklerden biri olan&nbsp;<strong>Optional</strong>&nbsp;sınıfında&nbsp;null referanslar yerine isteğe bağlı değerleri g&ouml;stermek i&ccedil;in iyi bir &ccedil;&ouml;z&uuml;m sunmaktadır.</p>\n\n<p>Optional sınıfı&nbsp;<code><strong>java.util</strong></code>&nbsp;paketine aittir.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.Optional;\n</code></pre>\n\n<p>Şimdi basit&ccedil;e bir optional nesnesi nasıl oluşturulur ona bakalım.</p>\n\n<pre>\n<code class=\"language-java\">Optional empty = Optional.empty();\n</code></pre>\n\n<p>Yukarıda g&ouml;rd&uuml;ğ&uuml;n&uuml;z &uuml;zere basit&ccedil;e Optional sınıfının&nbsp;<code>empty()</code>&nbsp;metodunu kullanarak boş bir Optional nesnesi oluşturuldu. Bir Optional nesnesi &uuml;zerinde herhangi bir değer olup, olmadığını şu şekilde &ouml;ğreniyoruz.</p>\n\n<pre>\n<code class=\"language-java\">empty.isPresent()\n</code></pre>\n\n<p>Yukarıdaki blokta olduğu gibi <code>isPresent()</code> metodunu kullanarak herhangi bir Optional nesnesi &uuml;zerinde bir değer olup, olmadığını kontrol edebiliriz. Sonu&ccedil; olarak &uuml;zerinde hen&uuml;z herhangi bir değer olmadığı i&ccedil;in bize false d&ouml;necektir. Ayrıca Optional tipinde olmayan bir nesneyi Optional tipine &ccedil;evirebilmemiz m&uuml;mk&uuml;n.</p>\n\n<pre>\n<code class=\"language-java\">Optional&lt;String&gt; var = Optional.of(\"anil\");\n</code></pre>\n\n<p>Fakat bazı durumlarda <code>null</code> olan nesnelere de bu işlemi uygulayabilmemiz gerekiyor. Bunun i&ccedil;in&nbsp;<code>Optional.ofNullable()</code>&nbsp;metodunu kullanabiliriz. Aksi halde&nbsp;<code>NullPointerException</code>&nbsp;hatasıyla karşılaşabiliriz.</p>\n\n<pre>\n<code class=\"language-java\">Optional&lt;String&gt; var = Optional.ofNullable(null);\n</code></pre>\n\n<p>Optional sınıfının en &ouml;nemli &ouml;zelliklerinden biri de&nbsp;<code>ifPresent</code>&nbsp;metodudur. Bu metod; Optional nesnesinin &uuml;zerinde herhangi bir değer tutulduğu zaman istenilen işlemlerin yapılmasına olanak sağlar.</p>\n\n<pre>\n<code class=\"language-java\">Optional&lt;String&gt; var = Optional.ofNullable(\"anil\");\nvar.ifPresent(v -&gt; System.out::println);\n</code></pre>\n\n<p>Bazen Optional nesnesi &uuml;zerinde herhangi bir değerin tutulup, tutulmadığının kontrol&uuml; yapılırken tutulmadığı durumdaki senaryoları tasarlayabilmemiz gerekiyor. Bunun i&ccedil;in Optional sınıfının bize sunduğu &ccedil;&ouml;z&uuml;mlere bakalım. Bunlar;&nbsp;<code>orElse()</code>,&nbsp;<code>orElseGet()</code>,&nbsp;<code>orElseThrow()</code></p>\n\n<h3><strong>orElse()</strong></h3>\n\n<p>Eğer Optional nesnesi &uuml;zerinde herhangi bir değer tanımlı değilse bu durumda istediğimiz değeri d&ouml;nebiliriz.</p>\n\n<pre>\n<code class=\"language-java\">Optional&lt;String&gt; optionalName = Optional.ofNullable(null);\nString result = optionalName.orElse(\"The Coders\");\n</code></pre>\n\n<h3><strong>orElseGet()</strong></h3>\n\n<p><strong>orElse()</strong> metoduna benzerdir. Eğer Optional nesnesi &uuml;zerinde herhangi bir değer tanımlı değilse bu durumda istediğimiz değeri <strong>orElse()</strong> deki gibi direk d&ouml;nmek yerine functional interface kullanabiliriz.</p>\n\n<pre>\n<code class=\"language-java\">Optional&lt;String&gt; optionalName = Optional.ofNullable(null);\nString result = optionalName.orElseGet(() -&gt; \"The Coders\");\n</code></pre>\n\n<h3><strong>orElseThrow()</strong></h3>\n\n<p>Eğer Optional nesnesi &uuml;zerinde herhangi bir değer tanımlı değilse bu durumda hata fırlatabiliriz.</p>\n\n<pre>\n<code class=\"language-java\">Optional&lt;String&gt; optionalName = Optional.ofNullable(null);\nString result = optionalName.orElseThrow(IllegalArgumentException::new);\n</code></pre>\n\n<p>Optional nesnesi i&ccedil;indeki değeri almak i&ccedil;in kullanılan diğer bir y&ouml;ntem ise&nbsp;<code>get()</code>&nbsp;metodudur.</p>\n\n<pre>\n<code class=\"language-java\">Optional&lt;String&gt; optionalName = Optional.ofNullable(\"The Coders\");\nString name = optionalName.get();\n</code></pre>\n\n<p>Fakat bu y&ouml;ntemin bir dezavantajı vardır. Eğer Optional nesnesi &uuml;zerinde herhangi bir değer yoksa ve direkt olarak <code>get()</code> metodunu kullanırsak&nbsp;<code>NoSuchElementException()</code>&nbsp;hatasını alırız.</p>', 'optional-sinifi', 'Optional Sınıfı', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Optional;Java8'),
('1cb9374e-4e52-4142-a1af-20019ef4a271', '<p>Hem throw hem de throws, bir metodtan veya herhangi bir kod bloğundan a&ccedil;ık&ccedil;a bir exception atmak i&ccedil;in kullanılan exception işleme kavramlarıdır ve y&ouml;ntemin imzasında bu y&ouml;ntemin listelenen t&uuml;r istisnalarından birini atabileceğini belirtmek i&ccedil;in throws kullanılır.&nbsp;&nbsp; Aşağıdakiler, throw ve throws arasındaki &ouml;nemli farklardır.</p>\n\n<table border=\"1\">\n	<thead>\n		<tr>\n			<th style=\"width:104px\">&nbsp;</th>\n			<th style=\"width:376px\">throw</th>\n			<th style=\"width:412px\">throws</th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td style=\"width:104px\">Tanım</td>\n			<td style=\"width:376px\">\n			<p>Programda bir işlev veya bir kod bloğu i&ccedil;inde a&ccedil;ık&ccedil;a bir istisna atmak i&ccedil;in kullanılan bir anahtar s&ouml;zc&uuml;kt&uuml;r.</p>\n			</td>\n			<td style=\"width:412px\">\n			<p>Kod y&uuml;r&uuml;t&uuml;l&uuml;rken işlev tarafından atılabilecek bir istisna bildirmek i&ccedil;in kullanılan y&ouml;ntem imzasında kullanılan bir anahtar s&ouml;zc&uuml;kt&uuml;r.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"width:104px\">Dahili uygulama</td>\n			<td style=\"width:376px\">\n			<p>Dahili throw, bir seferde yalnızca tek bir istisna atılmasına izin verildiği i&ccedil;in uygulanır; yani, <code>throw</code> anahtar kelimesi ile birden fazla istisna atamayız.</p>\n			</td>\n			<td style=\"width:412px\">\n			<p>Throws anahtar kelimesinin kullanıldığı fonksiyon tarafından atılabilecek olan throws anahtar kelimesi ile birden fazla istisna bildirebiliriz.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"width:104px\">İstisna t&uuml;r&uuml;</td>\n			<td style=\"width:376px\">\n			<p>Throw anahtar s&ouml;zc&uuml;ğ&uuml; ile yalnızca kontrol edilmemiş istisnayı yayabiliriz, yani kontrol edilen istisna, throw kullanılarak yayılamaz.</p>\n			</td>\n			<td style=\"width:412px\">\n			<p>Throws anahtar kelimesi ile hem kontrol edilen hem de kontrol edilmeyen istisnalar bildirilebilir ve yayılma kontroll&uuml; istisnalar i&ccedil;in throws anahtar kelimesini ve ardından &ouml;zel istisna sınıfı adını kullanmalıdır.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"width:104px\">Tanımlama</td>\n			<td style=\"width:376px\">Throw anahtar s&ouml;zc&uuml;ğ&uuml;n&uuml; kullanmak i&ccedil;in, y&ouml;ntem i&ccedil;inde throw anahtar s&ouml;zc&uuml;ğ&uuml;n&uuml;n kullanıldığını bilmeliyiz.</td>\n			<td style=\"width:412px\">\n			<p>Metod imzası ile birlikte throws anahtar s&ouml;zc&uuml;ğ&uuml; kullanılır.</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<pre>\n<code class=\"language-java\">public class OrnekSinif{\n   public void yasCek(int age){\n      if(age&lt;18)\n         throw new ArithmeticException(\"exception oldu\");\n      else\n         System.out.println(\"18den büyük\");\n   }\n   public static void main(String args[]){\n      OrnekSinif obj = new OrnekSinif();\n      obj.yasCek(13);\n   }\n}</code></pre>\n\n<h3><strong>&Ccedil;ıktı</strong></h3>\n\n<pre>\n<code class=\"language-http\">Exception in thread \"main\" java.lang.ArithmeticException:\nexception oldu\nat OrnekSinif.checkAge(OrnekSinif.java:4)\nat OrnekSinif.main(OrnekSinif.java:10)</code></pre>\n\n<pre>\n<code class=\"language-java\">public class OrnekSinif{\n   public int bolme(int a, int b) throws ArithmeticException{\n      int t = a/b;\n      return t;\n   }\n   public static void main(String args[]){\n      OrnekSinif obj = new OrnekSinif();\n      try{\n         System.out.println(obj.bolme(15,0));\n      }catch(ArithmeticException e){\n         System.out.println(\"0\'a bölemezsiniz\");\n      }\n   }\n}</code></pre>\n\n<h3><strong>&Ccedil;ıktı</strong></h3>\n\n<pre>\n<code class=\"language-bash\">0\'a bölemezsiniz</code></pre>', 'throw-vs-throws', 'Throw vs Throws', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Throw;Throws'),
('1cb9374e-4e52-4142-a1af-20020ef4a271', '<h3><strong>Interface Nedir?</strong></h3>\n\n<p>Interface, bir sınıf&nbsp;implement etmek i&ccedil;in&nbsp;kullanılabilecek bir blueprinttir. Herhangi bir somut olarak kodu olan metod i&ccedil;ermez. Interface&#39;in t&uuml;m metodları abstract metodlardır.</p>\n\n<p>Bir interface somutlaştırılamaz(instance&#39;ı oluşturulamaz). Ancak, onu implement eden&nbsp;sınıflar somutlaştırılabilir. Hi&ccedil;bir zaman &ouml;rnek değişkenler i&ccedil;ermezler, ancak <code>public static final</code> değişkenler (yani sabit sınıf değişkenleri) i&ccedil;erebilirler.</p>\n\n<pre>\n<code class=\"language-java\">public interface A{}\npublic class B implements A{}\n\npublic static void main(String[] args){\n    A test = new B();\n    //A test = new A(); // compile olmaz\n}</code></pre>\n\n<p>&quot;<code>implements</code>&quot; kelimesi kullanmadan interface&#39;i kullanmak i&ccedil;in anonymous class olarak yazmak gerek;</p>\n\n<pre>\n<code class=\"language-java\">interface A{\n    public void read();\n}\n\nclass Ornek{\n    new A() {\n        public void read() {\n            System.out.println(\"interface implemented with anonymously\");\n        }\n    };\n}</code></pre>\n\n<p><strong>Interface&#39;leri&nbsp;Kullanmanın &Ouml;nemli Nedenleri</strong></p>\n\n<ul>\n	<li>Interfaceler&nbsp;soyutlama elde etmek i&ccedil;in kullanılır.</li>\n	<li>&Ccedil;alışma zamanında(runtime) dinamik metod &ouml;zelliğini desteklemek i&ccedil;in tasarlanmıştır.</li>\n	<li>Gevşek bağlantı(loose coupling) elde etmenize yardımcı olur.</li>\n	<li>Bir y&ouml;ntemin tanımını kalıtım hiyerarşisinden ayırmanıza izin verir.</li>\n</ul>\n\n<h3><strong>Abstract Class Nedir?</strong></h3>\n\n<p>Tanımlanmasında <code>abstract</code> anahtar s&ouml;zc&uuml;ğ&uuml;ne sahip bir sınıfa abstract/soyut sınıf denir. Abstract sınıfların en az bir soyut metodu(yani g&ouml;vdesi olmayan metodlar) olmalıdır. Birden fazla somut y&ouml;nteme sahip olabilir. Abstract sınıflar, somut sınıflar i&ccedil;in planlar oluşturmanıza olanak tanır. Ancak miras alan sınıf, soyut y&ouml;ntemi uygulamalıdır. Soyut sınıflar somutlaştırılamaz(instance&#39;ı oluşturulamaz). Genel tanım ise; kodu, birbiriyle yakından ilişkili birka&ccedil; sınıf arasında paylaşmak istememizdir.</p>\n\n<ul>\n</ul>\n\n<p><strong>Abstract Class&#39;lari&nbsp;Kullanmanın &Ouml;nemli Nedenleri</strong></p>\n\n<ul>\n	<li>Soyut sınıflar, alt sınıflar i&ccedil;in varsayılan fonksiyonları sunar.</li>\n	<li>Gelecekteki belirli sınıflar i&ccedil;in bir şablon sağlar.</li>\n	<li>Alt sınıfları i&ccedil;in ortak bir interface tanımlamanıza yardımcı olur.</li>\n	<li>Abstract class, kodun yeniden kullanılabilirliğine izin verir.</li>\n</ul>\n\n<h3><strong>Interface vs Abstract Class</strong></h3>\n\n<p>Abstract bir sınıf, alt sınıfların uygulayabileceği veya ge&ccedil;ersiz kılabileceği işlevsellikleri yapmamıza izin verirken, bir interface&nbsp;yalnızca işlevselliği belirtmenize izin verir, ancak uygulamanıza izin vermez. Bir sınıf yalnızca bir soyut sınıfı genişletebilirken, bir sınıf birden &ccedil;ok arabirim uygulayabilir.</p>\n\n<table border=\"1\" style=\"width:100%\">\n	<thead>\n		<tr>\n			<th style=\"width:194px\"><strong>Parametre</strong></th>\n			<th style=\"width:569px\"><strong>Interface</strong></th>\n			<th style=\"width:478px\"><strong>Abstract class</strong></th>\n		</tr>\n	</thead>\n	<tbody>\n		<tr>\n			<td style=\"width:194px\">Hız</td>\n			<td style=\"width:569px\">Yavaş</td>\n			<td style=\"width:478px\">Hızlı</td>\n		</tr>\n		<tr>\n			<td style=\"width:194px\">&Ccedil;oklu kalıtım</td>\n			<td style=\"width:569px\">Birden fazla sınıf&#39;ın implement etmesine izin verir</td>\n			<td style=\"width:478px\">Yalnızca bir adet</td>\n		</tr>\n		<tr>\n			<td style=\"width:194px\">Yapı</td>\n			<td style=\"width:569px\">Abstract methodlar</td>\n			<td style=\"width:478px\">Abstract &amp; somut methodlar</td>\n		</tr>\n		<tr>\n			<td style=\"width:194px\">Ne zaman kullanılmalı</td>\n			<td style=\"width:569px\">Gelecekteki geliştirmeler i&ccedil;in</td>\n			<td style=\"width:478px\">Bağımsızlıktan ka&ccedil;ınmak i&ccedil;in</td>\n		</tr>\n		<tr>\n			<td style=\"width:194px\">Varsayılan Uygulama</td>\n			<td style=\"width:569px\">\n			<p>Yeni şeyler eklemek, t&uuml;m implement edenleri&nbsp;bulmak ve yeni tanımlanmış şeyleri uygulamak zor</p>\n			</td>\n			<td style=\"width:478px\">\n			<p>Varsayılan implementasyonu kullanabiliriz</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"width:194px\">Erişim Değiştiricileri</td>\n			<td style=\"width:569px\">\n			<p>Erişim değiştiricileri yoktur. Tanımlanan her şeyin public</p>\n			</td>\n			<td style=\"width:478px\">\n			<p>Abstract Class&#39;ın&nbsp;bir erişim değiştiricisi olabilir</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"width:194px\">Veri alanları</td>\n			<td style=\"width:569px\">Veri alanları i&ccedil;eremez</td>\n			<td style=\"width:478px\">İ&ccedil;erebilir</td>\n		</tr>\n		<tr>\n			<td style=\"width:194px\">Kalıtım</td>\n			<td style=\"width:569px\">\n			<p>Birden &ccedil;ok interface&#39;i miras alabilir&nbsp;ancak bir sınıfı devralamaz.</p>\n			</td>\n			<td style=\"width:478px\">\n			<p>Bir sınıfı ve birden &ccedil;ok interface&#39;i devralabilir</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"width:194px\">Constructor&nbsp;/ Destructors</td>\n			<td style=\"width:569px\">Constructors / Destructors tanımlanamaz.</td>\n			<td style=\"width:478px\">Tanımlanabilir</td>\n		</tr>\n		<tr>\n			<td style=\"width:194px\">Limit</td>\n			<td style=\"width:569px\">\n			<p>Herhangi bir sayıda interface&#39;i&nbsp;extend edebilir.</p>\n			</td>\n			<td style=\"width:478px\">\n			<p>Bir sınıfı(abstract olabilir) extend edebilir.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"width:194px\">Abstract kelimesi</td>\n			<td style=\"width:569px\">\n			<p>Bir metodu&nbsp;abstract olarak bildirmek isteğe bağlıdır.</p>\n			</td>\n			<td style=\"width:478px\">\n			<p>Abstract anahtar kelimesi zorunludur.</p>\n			</td>\n		</tr>\n		<tr>\n			<td style=\"width:194px\">Sınıf tipi</td>\n			<td style=\"width:569px\">\n			<p>Yalnızca public abstract metodlar&nbsp;olabilir.</p>\n			</td>\n			<td style=\"width:478px\">\n			<p>Protected veya public abstract metodlar&nbsp;olabilir.</p>\n			</td>\n		</tr>\n	</tbody>\n</table>\n\n<pre>\n<code class=\"language-java\">interface Arac {\n    // tanımlama\n    void vites(int yeniDeger);\n    void hizlan(int artis);\n    void fren(int azalis);\n}\nclass Araba implements Arac {\n    int hiz = 0;\n    int vites = 1;\n    // implementasyon\n    @Override\n    public void vites(int yeniDeger) {\n        vites = yeniDeger;\n    }\n    @Override\n    public void hizlan(int artis) {\n        hiz = hiz + artis;\n    }\n    @Override\n    public void fren(int azalis) {\n        hiz = hiz - azalis;\n    }\n    void printStates() {\n        System.out.println(\"Hız:\" + hiz + \" vites:\" + vites);\n    }\n}\nclass Scratch {\n    public static void main(String[] args) {\n        Araba araba = new Araba();\n        araba.printStates();\n    }\n}</code></pre>\n\n<pre>\n<code class=\"language-java\">abstract class Arac {\n    public abstract int vites();\n    public int kapiSayısı() {\n        return 4;\n    }\n}\nclass Porsche extends Arac {\n    public int vites() {\n        return 5;\n    }\n    public int kapiSayısı() {\n        return 2;\n    }\n}\nclass Sahin extends Arac {\n    public int vites() {\n        return 5;\n    }\n}\n\nclass Scratch {\n    public static void main(String[] args) {\n        Porsche porsche = new Porsche();\n        System.out.println(porsche.kapiSayısı());\n        System.out.println(porsche.vites());\n        System.out.println(\"--------\");\n        Sahin sahin = new Sahin();\n        System.out.println(sahin.kapiSayısı());\n        System.out.println(sahin.vites());\n    }\n}</code></pre>\n\n<p>&nbsp;</p>', 'interface-vs-abstract-class', 'Interface vs Abstract Class', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Interface;Abstract Class'),
('1cb9374e-4e52-4142-a1af-20021ef4a271', '<p>Java&#39;da primitive tipler (int, char, boolean&hellip;) hari&ccedil; herşey nesne ve bu nesneleri s&uuml;rekli&nbsp;kullanırız. Ancak nesneleri bazen JVM dışında kullanmak gerekebiliyor. Fakat dışarıda kullandığımız bir nesnemizi tekrar i&ccedil;eride kullanmak istediğimizde nesne i&ccedil;inde kullanılan değerlerin hangi tipte olduğunu &ouml;ğrenemiyoruz.</p>\n\n<p>Herhangi bir sınıftan bir nesne &uuml;retip, bunu bir dosyaya yazdırıp onu tekrar dosyadan okuduğumuzda değerlerin tip bilgisini bilememe problemimiz var. İşte tam bu durumda&nbsp;<code><strong>Java Serialization API</strong></code>&nbsp;yardımımıza koşuyor.</p>\n\n<p>Araba bilgilerini tutan sing&nbsp;<code>Araba</code>&nbsp;diye bir sınıfımız olsun ve bu bilgileri bir dosyaya kaydedip, tekrar okuma işlemi yapalım.</p>\n\n<p>Serileştirme işlemi i&ccedil;in&nbsp;<code><strong>Serializable</strong></code>&nbsp;aray&uuml;z&uuml;n&uuml; implement etmek gerekiyor.</p>\n\n<pre>\n<code class=\"language-java\">import java.io.Serializable;\n\nclass Araba implements Serializable {\n    private String marka;\n    private String model;\n\n    Araba(final String marka, final String model) {\n        this.marka = marka;\n        this.model = model;\n    }\n\n    public String getMarka() {return marka;}\n    public void setMarka(final String marka) {this.marka = marka;}\n    public String getModel() {return model;}\n    public void setModel(final String model) {this.model = model;}\n}</code></pre>\n\n<p>Şimdi bu nesneye bir dosyaya yazdıralım,</p>\n\n<pre>\n<code class=\"language-java\">import java.io.FileOutputStream;\nimport java.io.ObjectOutputStream;\n\npublic class Main {\n    public static void main(final String[] args) {\n        try{\n            final Araba araba = new Araba(\"Seat\", \"Leon\");\n            final FileOutputStream file = new FileOutputStream(\"araba.txt\");\n            final ObjectOutputStream write = new ObjectOutputStream(file);\n            write.writeObject(araba);\n            write.close();\n        }catch(final Exception e){\n            System.out.println(e.getMessage());\n        }\n    }\n}</code></pre>\n\n<p>Nesnemizi dosyaya yazdığımız zaman dosyamızın &ccedil;ıktısı şu şekilde.</p>\n\n<pre>\n<code class=\"language-markdown\">¨ÌsrCarÇ«5xÕçLbrandtLjava/lang/String;Lmodelq~xptSeattLeon\n</code></pre>\n\n<p>Şimdi gelin bu nesneyi dosyadan tekrar okuyalım.</p>\n\n<pre>\n<code class=\"language-java\">import java.io.*;\n\npublic class Main {\n    public static void main(final String[] args) {\n        try {\n            final FileInputStream file = new FileInputStream(\"araba.txt\");\n            final ObjectInputStream read = new ObjectInputStream(file);\n            final Araba araba = (Araba) read.readObject();\n            System.out.println(araba.toString());\n            read.close();\n        }catch (final Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}</code></pre>\n\n<p>&Ccedil;ıktımız :</p>\n\n<pre>\n<code class=\"language-markdown\">Marka : Seat Model : Leon\n</code></pre>\n\n<p>G&ouml;r&uuml;ld&uuml;ğ&uuml; gibi dosyaya yazdırdığımız nesneyi tekrar okuyup, başarılı bir şekilde konsolumuza yazdırabildik.</p>', 'serialization', 'Serialization', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'serialization'),
('1cb9374e-4e52-4142-a1af-20022ef4a271', '<p><span style=\"font-size:16px\"><code>Timer</code> sınıfı; bir kod bloğunun ne zaman veya ne sıklıkta &ccedil;alışacağını belirlemek i&ccedil;in kullanılır. Timer sınıfını kullanabilmek i&ccedil;in aşağıdaki paketi import etmemiz gerekir.</span></p>\n\n<ul>\n	<li><span style=\"font-size:16px\"><code>java.util.Timer</code>:&nbsp;Timer sınıfından bir nesneyi aşağıdaki yapılandırıcılar ile yaratabiliriz.</span></li>\n	<li><span style=\"font-size:16px\"><code>Timer()</code>:<strong>&nbsp;</strong>Timer nesnesi yaratır.</span></li>\n	<li><span style=\"font-size:16px\"><code>Timer(String name)</code>:<strong>&nbsp;</strong>Timer nesnesini bizim belirleyeceğimiz &ouml;zel bir adıyla yaratır.</span></li>\n</ul>\n\n<p><span style=\"font-size:16px\">Timer sınıfından yaratılmış bir nesne aşağıdaki metodlar ile kullanılabilir.</span></p>\n\n<ul>\n	<li><span style=\"font-size:16px\"><code>void cancel()</code>:<strong>&nbsp;</strong>Timer&rsquo;ı sona erdirir.</span></li>\n	<li><span style=\"font-size:16px\"><code>int purge()</code>:<strong>&nbsp;</strong>Sona erdirilen t&uuml;m g&ouml;revleri ilgili timer nesnesinin g&ouml;rev kuyruğundan kaldırır.</span></li>\n	<li><span style=\"font-size:16px\"><code>void schedule(TimerTask task, Date time)</code>:<strong>&nbsp;</strong>Belirtilen g&ouml;revin hangi zamanda &ccedil;alışacağını belirler.</span></li>\n	<li><span style=\"font-size:16px\"><code>void schedule(TimerTask task, Date firstTime, long period)</code>:<strong>&nbsp;</strong>Belirtilen g&ouml;revi hangi zamanda başlatacağını ve ne sıklıkla &ccedil;alışacağını belirler.</span></li>\n	<li><span style=\"font-size:16px\"><code>void schedule(TimerTask task, long delay)</code>:<strong>&nbsp;</strong>Belirtilen g&ouml;revi ne kadarlık bir gecikmeyle başlayacağını zamanlar.</span></li>\n	<li><span style=\"font-size:16px\"><code>void schedule(TimerTask task, long delay, long period)</code>:<strong>&nbsp;</strong>Belirtilen g&ouml;revi ne kadarlık bir gecikmeyle başlayacağını ve ne sıklıkla &ccedil;alışacağını belirler.</span></li>\n	<li><span style=\"font-size:16px\"><code>void scheduleAtFixedRate(TimerTask task, Date firstTime, long period)</code>:<strong>&nbsp;</strong>Belirtilen g&ouml;revi hangi zamanda başlatacağını ve hangi sabit oranlı periyodlar ile &ccedil;alışacağını belirler.</span></li>\n	<li><span style=\"font-size:16px\"><code>void scheduleAtFixedRate(TimerTask task, long delay, long period)</code>:<strong>&nbsp;</strong>Belirtilen g&ouml;revi ne kadarlık bir gecikme ile başlayacağını ve hangi sabit oranlı periyodlar ile &ccedil;alışacağını zamanlar.</span></li>\n</ul>\n\n<p><span style=\"font-size:16px\">&Ouml;rnek olarak 5 den geriye sayan bir program yapalım. 0 olduğunda da tekrar başa d&ouml;ns&uuml;n.</span></p>\n\n<pre>\n<code class=\"language-java\">import java.util.Timer;\nimport java.util.TimerTask;\n\npublic class HelloWorld{\n	public static void main(String []args){\n		Timer timer = new Timer();\n		TimerTask task = new TimerTask() {\n			int seconds = 5;\n\n			@Override\n			public void run() {\n				System.out.println(\"Kalan Zaman:\" + seconds--);\n				if (seconds &lt; 0) {\n					seconds = 5;\n				}\n			}\n		};\n		timer.schedule(task, 0, 1000);\n	}\n}</code></pre>\n\n<pre>\n<code class=\"language-html\">Kalan Zaman:5\nKalan Zaman:4\nKalan Zaman:3\nKalan Zaman:2\nKalan Zaman:1\nKalan Zaman:0\nKalan Zaman:5\nKalan Zaman:4\nKalan Zaman:3\nKalan Zaman:2</code></pre>', 'timer-sinifi', 'Timer Sınıfı', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'timer'),
('1cb9374e-4e52-4142-a1af-20023ef4a271', '<h3><strong>JDK Nedir?</strong></h3>\n\n<p>JDK(Java Development Kit), applet&#39;ler ve Java uygulamaları yapmak i&ccedil;in kullanılan bir yazılım geliştirme ortamıdır.&nbsp;Java programlarını yazmak i&ccedil;in gerekli ara&ccedil;ları ve bunları y&uuml;r&uuml;tmek i&ccedil;in JRE&#39;yi i&ccedil;erir.</p>\n\n<p>JDK&#39;nın &ouml;nemli &ouml;zellikleri şunlardır:</p>\n\n<ul>\n	<li>Tek bir catch bloğunda birden fazla uzantıyı işlemenizi sağlar.</li>\n	<li>JDK, JRE&#39;nin sahip olduğu t&uuml;m &ouml;zellikleri i&ccedil;erir.</li>\n	<li>Derleyici, hata ayıklayıcı vb. geliştirme ara&ccedil;larını i&ccedil;erir.</li>\n	<li>JDK, Java kaynak kodunu geliştirmek ve y&uuml;r&uuml;tmek i&ccedil;in ortamı sağlar.</li>\n	<li>Windows, Unix ve Mac işletim sistemlerine kurulabilir.</li>\n	<li>Diamond operat&ouml;r&uuml;, kesin olanı yazmak yerine genel bir t&uuml;r arabirimi belirtmek i&ccedil;in kullanılabilir.</li>\n</ul>\n\n<h4><strong>JDK&#39;nın &ouml;nemli bileşenleri şunlardır;</strong></h4>\n\n<p><img alt=\"\" dir=\"ltr\" src=\"/upload/files/jdk.png\" style=\"float:left; height:303px; margin-left:33px; margin-right:33px; width:350px\" /></p>\n\n<ul>\n	<li><strong>JDK ve JRE</strong>: JDK, programcıların JVM ve sınıf kitaplıklarını i&ccedil;eren JRE tarafından &ccedil;alıştırılabilen temel Java programları oluşturmasına olanak tanır.</li>\n	<li><strong>Class Libraries:&nbsp;</strong>Java programının &ccedil;alışma zamanında &ccedil;ağırabileceği dinamik olarak y&uuml;klenebilir kitaplıklar grubudur.</li>\n	<li><strong>Compilers:</strong>&nbsp;Geliştiricilerin metin dosyasını kabul eden ve Java sınıflarına derleyen bir Java programıdır. Java bayt kodunu i&ccedil;eren derleyici tarafından verilen yaygın &ccedil;ıktı bi&ccedil;imidir. Java&#39;da birincil derleyici Javac&#39;tır.</li>\n	<li><strong>Debuggers:&nbsp;</strong>Geliştiricilerin Java programlarını test etmelerini ve hatalarını ayıklamalarını sağlayan bir Java programıdır.</li>\n	<li><strong>JavaDoc:&nbsp;</strong>JavaDoc, Sun Microsystems tarafından Java i&ccedil;in hazırlanmış belgelerdir. JavaDoc, kaynak programdan HTML dosyasında API belgeleri oluşturarak kullanılabilir</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<h3><strong>JRE Nedir?</strong></h3>\n\n<p>JRE(Java Runtime Environment), diğer yazılımları &ccedil;alıştırmak i&ccedil;in tasarlanmış bir yazılımın par&ccedil;asıdır. K&uuml;t&uuml;phaneleri, y&uuml;kleyici sınıfları&nbsp;ve JVM&#39;i i&ccedil;erir. Basit bir ifadeyle, Java programını &ccedil;alıştırmak istiyorsanız JRE&#39;ye ihtiyacımız var. Yazılımcı değilseniz, Java programlarını &ccedil;alıştırmak i&ccedil;in JDK&#39;yı y&uuml;klemeniz gerekmez, yalnızca JRE&#39;yi y&uuml;klemeniz gerekir. Math, swingetc, util, lang, awt ve runtime k&uuml;t&uuml;phaneleri gibi &ouml;nemli paket sınıflarını i&ccedil;erir. Bununla birlikte, t&uuml;m JDK s&uuml;r&uuml;mleri Java Runtime Environment ile birlikte gelir, bu nedenle JRE&#39;yi PC&#39;nize ayrıca indirip y&uuml;klemeniz gerekmez. JRE&#39;nin tam bi&ccedil;imi Java Runtime Environment&#39;dır.</p>\n\n<p>JRE&#39;nin &ouml;nemli &ouml;zellikleri şunlardır:</p>\n\n<ul>\n	<li>Java Runtime Environment, JVM&#39;nin fiilen &ccedil;alıştığı bir dizi ara&ccedil;tan oluşur.</li>\n	<li>JRE, Java Web Start ve Java Plug-in dahil olmak &uuml;zere dağıtım teknolojisini i&ccedil;erir.</li>\n	<li>Geliştiriciler kaynak kodunu JRE&#39;de kolayca &ccedil;alıştırabilir, ancak Java programını yazamaz ve derleyemez.</li>\n	<li>Java Database Connectivity(JDBC), Remote Method Invocation(RMI), Java Naming ve Directory Interface (JNDI) ve daha fazlası gibi entegrasyon k&uuml;t&uuml;phanelerini i&ccedil;erir.</li>\n	<li>JRE, JVM ve Java HotSpot sanal makine istemcisine sahiptir.</li>\n</ul>\n\n<h3><strong>JRE&#39;nin &ouml;nemli bileşenleri şunlardır;</strong></h3>\n\n<p><img alt=\"\" src=\"/upload/files/jre.png\" style=\"float:left; height:298px; margin-left:33px; margin-right:33px; width:150px\" /></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<ul>\n	<li><strong>Class loaders:&nbsp;</strong>Sınıf y&uuml;kleyici, bir Java programını &ccedil;alıştırmak i&ccedil;in gerekli olan &ccedil;eşitli sınıfları y&uuml;kler. JVM, bootstrap class loader, extensions class loader VE system class loader adı verilen &uuml;&ccedil; sınıf y&uuml;kleyici kullanır.</li>\n	<li><strong>Byte code verifier:</strong>&nbsp;Bayt kodu doğrulayıcı, kodun yorumlayıcıyı rahatsız etmemesi i&ccedil;in bayt kodunu doğrular.</li>\n	<li><strong>Interpreter:&nbsp;</strong>Sınıflar y&uuml;klendikten ve kod doğrulandıktan sonra yorumlayıcı kodu satır satır okur.</li>\n	<li><strong>Run-time:&nbsp;</strong>&Ccedil;alışma zamanı, belirli bir programın &ccedil;alıştığı s&uuml;reyi tanımlamak i&ccedil;in esas olarak programlamada kullanılan bir sistemdir.</li>\n	<li><strong>Hardware:&nbsp;</strong>Java kodu&nbsp;derlendiğinde, belirli bir donanım platformunda &ccedil;alışır.</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<h3><strong>JVM Nedir?</strong></h3>\n\n<p>JVM(Java Virtual Machine), Java Kodunu veya uygulamalarını &ccedil;alıştırmak i&ccedil;in bir &ccedil;alışma zamanı ortamı sağlayan platform bağımsız bir motordur. Java bayt kodunu makine diline d&ouml;n&uuml;şt&uuml;r&uuml;r. JVM, Java Run Environment&#39;ın (JRE) bir par&ccedil;asıdır. Ayrı olarak indirilemez ve kurulamaz. JVM&#39;yi kurmak i&ccedil;in JRE&#39;yi kurmanız gerekir.</p>\n\n<p>JVM, Java kaynak kodunu d&uuml;ş&uuml;k seviyeli makine diline d&ouml;n&uuml;şt&uuml;ren JIT(Just-in-Time) derleyicisi ile birlikte gelir. Bu nedenle, normal bir uygulama olarak daha hızlı &ccedil;alışır. Diğer bir&ccedil;ok programlama dilinde, derleyici belirli bir sistem i&ccedil;in makine kodu &uuml;retir. Ancak Java derleyicisi, JVM olarak adlandırılan bir sanal makine i&ccedil;in kod &uuml;retir.</p>\n\n<h4><strong>JVM &#39;in &ouml;nemli bileşenleri şunlardır;</strong></h4>\n\n<p><img alt=\"\" src=\"/upload/files/jvm.png\" style=\"float:left; height:290px; margin-left:11px; margin-right:11px; width:444px\" /></p>\n\n<ul>\n	<li><strong>Class Loader</strong>: Sınıf dosyalarını y&uuml;klemek i&ccedil;in kullanılan bir alt sistemdir. &Uuml;&ccedil; ana işlevi yerine getirir; Loading, Linking ve Initialization</li>\n	<li><strong>Method Area</strong>: Meta veriler gibi sınıfın yapısını, Java y&ouml;ntemlerinin kodunu ve sabit &ccedil;alışma zamanı havuzunu depolar.</li>\n	<li><strong>Heap</strong>: T&uuml;m Nesneler, diziler ve &ouml;rnek değişkenler bir yığında saklanır. Bu bellek birden &ccedil;ok iş par&ccedil;acığı arasında paylaşılr.</li>\n	<li><strong>JVM language Stacks</strong>: Yerel değişkenleri ve kısmi sonu&ccedil;larını depolar. Her iş par&ccedil;acığının, iş par&ccedil;acığı oluşturulurken eşzamanlı olarak oluşturulan kendi JVM dil yığını vardır. Y&ouml;ntem &ccedil;ağrıldığında yeni bir frame oluşturulur ve y&ouml;ntem &ccedil;ağırma işlemi tamamlandığında kaldırılır.</li>\n	<li><strong>PC Registers</strong>:Halihazırda y&uuml;r&uuml;t&uuml;lmekte olan Java sanal makine talimatının adresini saklar. Java&#39;da her iş par&ccedil;acığının ayrı bir PC kaydı vardır.</li>\n	<li><strong>Native Method Stacks</strong>: Yerel kitaplığa bağlı olarak yerel kodun talimatını tutar. Yerel yığınlara bellek ayırır veya herhangi bir yığın t&uuml;r&uuml;n&uuml; kullanır.</li>\n	<li><strong>Execution Engine</strong>: Yazılım, donanım veya komple sistemleri test etmek i&ccedil;in kullanılan bir yazılım t&uuml;r&uuml;d&uuml;r. Test edilen &uuml;r&uuml;n hakkında hi&ccedil;bir zaman bilgi taşımaz.</li>\n	<li><strong>Native Method interface</strong>: Bir programlama &ccedil;er&ccedil;evesidir. Bir JVM&#39;de &ccedil;alışan Java kodunun k&uuml;t&uuml;phaneler ve yerel uygulamalar tarafından &ccedil;ağrılmasına izin verir.</li>\n	<li><strong>Native Method Libraries</strong>: Y&uuml;r&uuml;tme Motoru tarafından ihtiya&ccedil; duyulan Native Kitaplıkların (C, C++) bir koleksiyonudur.</li>\n</ul>\n\n<h4><strong>Başlıca Farklar</strong></h4>\n\n<ul>\n	<li>JDK bir yazılım geliştirme kiti iken JRE, Java programının &ccedil;alışmasına izin veren bir yazılım paketi, JVM ise bayt kodunu &ccedil;alıştıran&nbsp;i&ccedil;in bir ortamdır.</li>\n	<li>JDK ve JRE de platforma bağlıdır, ancak JVM platformdan bağımsızdır.</li>\n	<li>JDK, geliştirme, hata ayıklama vb. ara&ccedil;lar i&ccedil;erir. JRE, sınıf kitaplıkları ve diğer destekleyici dosyaları i&ccedil;erirken, yazılım geliştirme ara&ccedil;ları JVM&#39;ye dahil değildir.</li>\n	<li>JDK, y&uuml;kleyiciyle birlikte gelir, RE yalnızca kaynak kodunu y&uuml;r&uuml;tmek i&ccedil;in ortamı i&ccedil;erirken, JVM hem JDK hem de JRE yazılımında paketlenmiştir.</li>\n</ul>', 'jdk-vs-jre-vs-jvm', 'JDK vs JRE vs JVM', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'JDK;JRE;JVM'),
('1cb9374e-4e52-4142-a1af-20024ef4a271', '<p>Joshua Bloch&#39;un Effective Java yazısında diyorki;</p>\n\n<blockquote>\n<p>Equals() &ouml;ğesini override eden her sınıfta hashCode() &ouml;ğesini override etmelisiniz. Bunu yapmamak, sınıfınızın HashMap, HashSet ve Hashtable dahil olmak &uuml;zere t&uuml;m karma tabanlı koleksiyonlarla birlikte d&uuml;zg&uuml;n &ccedil;alışmasını engelleyen Object.hashCode() i&ccedil;in genel s&ouml;zleşmenin ihlaliyle sonu&ccedil;lanacaktır.</p>\n</blockquote>\n\n<p>HashCode()&#39;u override etmeden sadece equals()&#39;ı override edersek ve bir Map kullanmaya &ccedil;alışırsak ne olacağına dair bir &ouml;rnekle anlamaya &ccedil;alışalım.</p>\n\n<p>Diyelim ki aşağıdaki gibi bir sınıfımız var ve importantField değerleri eşitse Bilgi sınıfın iki nesnesinin eşit olduğunu varsayalım.</p>\n\n<pre>\n<code class=\"language-java\">class Bilgi{\n    private final String soru;\n    private final String cevap;\n\n    // Getter, Setter ve Yapıcı metodlar olduğunu varsayalım\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj)\n            return true;\n\n        if (obj == null)\n            return false;\n\n        if (getClass() != obj.getClass())\n            return false;\n\n        final Bilgi bilgi = (Bilgi) obj;\n        if (soru == null) {\n            if (bilgi.soru != null)\n                return false;\n        } else if (!soru.equals(bilgi.soru))\n            return false;\n\n        return true;\n    }\n    /*\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((soru == null) ? 0 : soru.hashCode());\n        return result;\n    }\n    */\n}</code></pre>\n\n<p>Şimdi bir sınıf oluşturalım, <code>Bilgi</code>&nbsp;nesnesini bir <code>HashSet</code>&#39;e ekleyip ve bu nesnenin mevcut olup olmadığını test edelim.</p>\n\n<pre>\n<code class=\"language-java\">class BilgiTest {\n    public static void main(String[] args) {\n        Bilgi bir = new Bilgi(\"soru1\",\"cevap1\");\n        Bilgi iki = new Bilgi(\"soru1\",\"cevap2\");\n\n        HashSet&lt;Bilgi&gt; sorular = new HashSet&lt;&gt;();\n        sorular.add(bir);\n        System.out.println(sorular.contains(iki));\n        System.out.println(\"bir.hashCode(): \" + bir.hashCode() + \"  iki.hashCode():\" + iki.hashCode());\n    }\n}</code></pre>\n\n<p>Bu şekilde &ccedil;ıktımız;</p>\n\n<pre>\n<code class=\"language-html\">false\nbir.hashCode():654845766  iki.hashCode():1712536284</code></pre>\n\n<p>Eğer hashcode()&#39;u override edersek ise;</p>\n\n<pre>\n<code class=\"language-html\">true\nbir.hashCode():109624977  iki.hashCode():109624977</code></pre>\n\n<p>&Ccedil;ıktılarınız alırız.</p>\n\n<p><code>SONU&Ccedil;</code>: Şimdi, iki nesne eşit olarak kabul edersek, <em>hashcode</em>&#39;larının da eşit olması gerektiğini anladık? Aksi takdirde, Object sınıfındaki varsayılan <em>hashcode</em>&nbsp;y&ouml;ntemi neredeyse her nesne i&ccedil;in benzersiz bir sayı d&ouml;nderdiğinden, <code>equals()</code> metodu override edilse bile, nesneyi asla bulamayız. Hash kodları eşit değilse, nesnelerin ne kadar eşit olduğunun bir &ouml;nemi yoktur. Yani bir kez daha: İki nesne eşitse, hashcode&#39;ları da eşit olmalıdır.</p>', 'overriding-equals-ve-hashcode', 'Overriding equals() ve hashcode()', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'equals;hashcode'),
('1cb9374e-4e52-4142-a1af-20025ef4a271', '<p>Java exception&#39;ları 2 kategoriye ayrılır: checked ve unchecked exceptionlar.</p>\n\n<h3>Checked Exceptions</h3>\n\n<p>Genel olarak, kontrol edilen exceptionlar, programın kontrol&uuml; dışındaki hataları temsil eder. &Ouml;rneğin, girdi dosyası yoksa FileInputStream yapıcısı <em>FileNotFoundException</em>&#39;ı atar. Java, checked exceptionları derleme zamanında kontrol eder. Bu nedenle, checked exceptionları bildirmek i&ccedil;in <code>throws</code> anahtar s&ouml;zc&uuml;ğ&uuml;n&uuml; kullanmalıyız:</p>\n\n<pre>\n<code class=\"language-java\">import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\n\nclass Test {\n    public static void main(String args[]) throws FileNotFoundException {\n        File file = new File(\"not_existing_file.txt\");\n        FileInputStream stream1 = new FileInputStream(file);\n    }\n}</code></pre>\n\n<p>Java&#39;da bazı checked exceptionlar:&nbsp;<em>IOException</em>,&nbsp;<em>SQLException</em>&nbsp;ve&nbsp;<em>ParseException</em>.</p>\n\n<p>Exception sınıfı, checked exception&#39;ların &uuml;st sınıfıdır, bu nedenle Exception&#39;yı genişleterek &ouml;zel bir checked exception oluşturabiliriz:</p>\n\n<pre>\n<code class=\"language-java\">public class IncorrectFileNameException extends Exception {\n    public IncorrectFileNameException(String errorMessage) {\n        super(errorMessage);\n    }\n}</code></pre>\n\n<h3>Unchecked Exceptions</h3>\n\n<p>Bir program denetlenmeyen exception atarsa, program mantığının i&ccedil;indeki bazı hataları yansıtır. &Ouml;rneğin, bir sayıyı 0&#39;a b&ouml;lersek, Java <em>ArithmeticException</em>&#39;ı verir:</p>\n\n<pre>\n<code class=\"language-java\">class Test {\n    public static void main(String args[]) {\n        int numerator = 1;\n        int denominator = 0;\n        int result = numerator / denominator;\n        System.out.println(\"result = \" + result);\n    }\n}\n// Exception in thread \"main\" java.lang.ArithmeticException: / by zero at Test.main(test.java:5)</code></pre>\n\n<h4>Java, unchecked exceptionları &ccedil;alışma zamanında fırlatır.</h4>\n\n<p>&nbsp;</p>', 'checked-ve-unchecked-exceptionlar', 'Checked ve Unchecked Exceptionlar', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'checked;unchecked'),
('1cb9374e-4e52-4142-a1af-20026ef4a271', '<p>Java&#39;da Collection, tek bir birim halinde bir araya getirilmiş birden &ccedil;ok nesne grubudur. <em>Java Collections</em>&nbsp;API&#39;si, Java geliştiricilerine nesne koleksiyonlarıyla &ccedil;alışmayı kolaylaştıran bir dizi sınıf ve arabirim sağlar; list, map, stack vb. Java, kendi koleksiyon sınıflarımızı yazmak yerine, bu kullanıma hazır koleksiyon sınıflarını sağlar.</p>\n\n<p>Temel interface&#39;ler;</p>\n\n<ul>\n	<li><code>Java Collection</code>\n\n	<ul>\n		<li>List, Set, Stack, Queue ve Deque gibi genel bir koleksiyonda m&uuml;mk&uuml;n olan işlemleri temsil eder. &Ouml;rneğin, &ouml;ğelere dizinlerine g&ouml;re erişme y&ouml;ntemleri, sıralama gibi generic metodlar&nbsp;Collection interface&#39;inde mevcuttur.</li>\n	</ul>\n	</li>\n	<li><code>Java List</code>\n	<ul>\n		<li>Sıralı bir koleksiyonu&nbsp;temsil eder. Sıralı demek, &ouml;ğelere listede bulundukları sırayla erişebiliriz. Aynı eleman listede olabilir.</li>\n	</ul>\n	</li>\n	<li><code>Java Set</code>\n	<ul>\n		<li>Sırasız bir koleksiyonu&nbsp;temsil eder. Listeden farklı olarak, bir Set&#39;in &ouml;ğelerine herhangi bir garantili sırada erişmenize izin vermez. &Ouml;ğeleri doğal sıralarına g&ouml;re sıralayan Set&#39;in&nbsp;metodları vardır, ancak Set interface&#39;in kendisi b&ouml;yle bir garanti sağlamaz. Listede sadece uniqe elemanlar olabilir. TreeSet sıralı izin veriyor.</li>\n	</ul>\n	</li>\n	<li><code>Java SortedSet</code>\n	<ul>\n		<li>Sıralı bir koleksiyonu&nbsp;temsil eder. B&ouml;ylece, SortedSet&#39;teki &ouml;ğeler sıralı d&uuml;zende yinelenebilir.</li>\n	</ul>\n	</li>\n	<li><code>Java navigableSet</code>\n	<ul>\n		<li>SortedSet interface&#39;in bir uzantısıdır ve NavigableSet&#39;teki &ouml;ğelerin her seferinde gezinmesi i&ccedil;in ek metodlar i&ccedil;erir.</li>\n	</ul>\n	</li>\n	<li><code>Java Map</code>\n	<ul>\n		<li>Nesneleri key-value şeklinde temsil eder. Hem key hem de value nesnelerdir. Bir Map&#39;e bir key-value eklersek&nbsp;ve daha sonra değeri key aracılığıyla alabiliriz, değeri daha sonra Map&#39;den yeniden okumak i&ccedil;in yalnızca anahtara ihtiyacınız olduğu anlamına gelir.</li>\n	</ul>\n	</li>\n	<li><code>Java SortedMap</code>\n	<ul>\n		<li>Map&#39;teki keylerin sıralandığı bir Map&#39;i&nbsp;temsil eden Map uzantısıdır. B&ouml;ylece, SortedMap&#39;te saklanan keyler, normal bir Map&#39;te tekrarlanan t&uuml;rden rastgele bir d&uuml;zen yerine, sıralı d&uuml;zende alabiliriz&nbsp;</li>\n	</ul>\n	</li>\n	<li><code>Java NavigableMap</code>\n	<ul>\n		<li>SortedMap&#39;in bir uzantısıdır ve NavigableMap&#39;te key-value nesneleri arasında kolay gezinme i&ccedil;in ek metodlar i&ccedil;erir.</li>\n	</ul>\n	</li>\n	<li><code>Java Stack</code>\n	<ul>\n		<li>Nesnelerin stack&#39;in en &uuml;st&uuml;ne itilebildiği ve daha sonra stack&#39;in tepesinden yeniden &ccedil;ıkarılabildiği klasik bir yığın veri yapısını temsil eder(LIFO - Last In First Out / First In Last Out).</li>\n	</ul>\n	</li>\n	<li><code>Java Queue</code>\n	<ul>\n		<li>Nesnelerin kuyruğun bir sonuna eklendiği ve kuyruğun başından nesnenin &ccedil;ıkarıldığı veri yapısını temsil eder(FIFO - First In First Out / Last In Last Out). Stack&#39;in tam tersi.</li>\n	</ul>\n	</li>\n	<li><code>Java Deque</code>\n	<ul>\n		<li>&Ccedil;ift u&ccedil;lu bir kuyruğu temsil eder; bu, kuyruğun her iki ucuna &ouml;ğeler ekleyip kaldırabileceğimiz bir veri yapısı anlamına gelir. Buna &ccedil;ift u&ccedil;lu stack da diyebilirdik&nbsp;</li>\n	</ul>\n	</li>\n	<li><code>Java Iterator</code>\n	<ul>\n		<li>Bir t&uuml;r Java koleksiyonunu yineleme yeteneğine sahip bir bileşeni temsil eder. &Ouml;rneğin, bir List&nbsp;veya Stack.</li>\n	</ul>\n	</li>\n	<li><code>Java Iterable</code>\n	<ul>\n		<li>Sorumluluk a&ccedil;ısından Iterator interface&#39;ine &ccedil;ok benzer. Java&#39;daki for-each d&ouml;ng&uuml;s&uuml; kullanılarak yinelenmesine izin verir. Java Yinelenebilir arabirimi aslında Java Koleksiyon API&#39;sinin bir par&ccedil;ası değildir, ancak Java Koleksiyon API&#39;si ile &ccedil;ok sık kullanılır.</li>\n	</ul>\n	</li>\n</ul>\n\n<p>Sınıflar;</p>\n\n<ul>\n	<li>\n	<p>Java Properties</p>\n\n	<ul>\n		<li>\n		<p>Java Map interface&#39;ine benzer&nbsp;&ouml;zel bir key/value olarak nesneleri tutar, ancak &ouml;zellikle key ve value &ccedil;iftinin string değer olmasını hedefleyen ve &ouml;zellik dosyalarından &ouml;zellikleri y&uuml;kleyip depolayabilmeyi ama&ccedil;lar.</p>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<h3>Giriş</h3>\n\n<p>Interface&#39;lerin iki grubu vardır: <code>Collection</code>&nbsp;ve <code>Map</code>.</p>\n\n<p><img alt=\"Collection-Framework-Hierarchy\" src=\"https://media.geeksforgeeks.org/wp-content/cdn-uploads/20200811210521/Collection-Framework-1.png\" style=\"height:250px; width:524px\" /><img alt=\"Collection-Framework-Map-Part\" src=\"https://media.geeksforgeeks.org/wp-content/cdn-uploads/20200811210611/Collection-Framework-2.png\" style=\"height:250px; width:546px\" /></p>\n\n<h2>Iterator</h2>\n\n<p>T&uuml;m hiyerarşide&nbsp;en &uuml;sttedir; bu, her collection sınıf ve arabirimin onu uyguladığı anlamına gelir. Birincil işlevi, kullanıcının t&uuml;m koleksiyon sınıfı nesneleri arasında basit veri &ouml;ğeleri dizileriymiş gibi ge&ccedil;iş yapmasına izin vermektir.(Veriye erişmek)&nbsp;</p>\n\n<p>Java&#39;daki en eski mekanizmalardan biridir (en eski olmasa da - Enumeration, Yineleyiciden &ouml;nce).</p>\n\n<p>Sadece Collection&#39;lar i&ccedil;in kullanabiliriz, Array&#39;lerde kullanamayız.</p>\n\n<blockquote>\n<p>Iterable: An iterator over a collection. Iterator takes the place of Enumeration in the Java Collections Framework.&nbsp;</p>\n\n<p>Enumeration:&nbsp;An object that implements the Enumeration interface generates a series of elements, one at a time. Successive calls to the nextElement method return successive elements of the series.</p>\n</blockquote>\n\n<pre>\n<code class=\"language-java\">import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nclass Test {\n    public static void main(String args[]) {\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(\"one\");\n        list.add(\"two\");\n        list.add(\"three\");\n\n        Iterator&lt;String&gt; iterator = list.iterator();\n\n        while(iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n    }\n}</code></pre>\n\n<p><code>Iterable</code>&nbsp;interface 3 metodu olmakla beraber sadece 1 tanesini implement etmeliyiz. Diğer ikisi default implementasyonlardır.</p>\n\n<pre>\n<code class=\"language-java\">public interface Iterable&lt;T&gt; {\n  Iterator&lt;T&gt;    iterator();\n  Spliterator&lt;T&gt; spliterator();\n  void           forEach(Consumer&lt;? super T&gt; action);\n}</code></pre>\n\n<table>\n	<tbody>\n		<tr>\n			<th>Method</th>\n			<th>Tanım</th>\n		</tr>\n		<tr>\n			<td>hasNext()</td>\n			<td>Iterator&#39;da&nbsp;daha fazla &ouml;ğe varsa <code>true</code>, yoksa <code>false</code>&nbsp;d&ouml;nd&uuml;r&uuml;r.</td>\n		</tr>\n		<tr>\n			<td>next()</td>\n			<td>Iterator&#39;daki bir sonraki elemanı verir</td>\n		</tr>\n		<tr>\n			<td>remove()</td>\n			<td>next() metodundan gelen en son &ouml;ğeyi Koleksiyondan kaldırır.</td>\n		</tr>\n		<tr>\n			<td style=\"vertical-align:top\">forEachRemaining()</td>\n			<td>Iterator&#39;da&nbsp;kalan t&uuml;m &ouml;ğeler iterate eder ve kalan her &ouml;ğeyi lambda ifadesine parametre olarak ileten bir Java Lambda İfadesi &ccedil;ağırır.</td>\n		</tr>\n	</tbody>\n</table>\n\n<h4>Iteration Sırası</h4>\n\n<p>Nesnelerin işlenme sırası, Interator&#39;ı sağlayan nesneye bağlıdır. &Ouml;rneğin, bir Listeden elde edilen bir iterator, &ouml;ğelerin <code>List</code>&#39;e eklendiği sırayla yinelenir. <code>Set</code>&#39;den elde edilen ise, Set&#39;deki &ouml;ğelerin yinelenme sıraası hakkında herhangi bir garanti vermez.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\n\nclass Test {\n    public static void main(String args[]) {\n        Set&lt;String&gt; set = new HashSet();\n        set.add(\"90\");\n        set.add(\"34\");\n        set.add(\"12\");\n        set.add(\"78\");\n        set.add(\"56\");\n\n        Iterator&lt;String&gt; iterator = set.iterator();\n\n        while(iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n    }\n}\n/*\n34\n12\n78\n56\n90\n*/</code></pre>\n\n<h4>Iteration Sırasında Değişiklik</h4>\n\n<p>Bazı koleksiyonlar, bir Iterator aracılığıyla yinelerken koleksiyonu değiştirmemize izin vermez. Bu durumda, Iterator next() y&ouml;ntemini bir sonraki &ccedil;ağırışımızda bir <code>ConcurrentModificationException</code>&nbsp;alırız. Set hata vermez.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nclass Test {\n    public static void main(String args[]) {\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n        list.add(\"one\");\n        list.add(\"two\");\n        list.add(\"three\");\n        list.add(\"four\");\n\n        Iterator&lt;String&gt; iterator = list.iterator();\n        // list.add(\"five\");\n        // list.remove(0);\n        while(iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n    }\n}</code></pre>\n\n<blockquote>\n<h4>Soru: ListIterator&#39;da neden <em>add</em>()&nbsp;metodu var, ancak Iterator&#39;da yok?</h4>\n\n<h4>ListIterator, bir Koleksiyonun her iki y&ouml;n&uuml;nde de iterate eder. &Ouml;nceki ve sonraki &ouml;ğeler i&ccedil;in iki pointer tutar.</h4>\n\n<h4>ListIterator&#39;da, next() metodu tarafından d&ouml;nd&uuml;r&uuml;len &ouml;ğeden hemen &ouml;nce listeye bir &ouml;ğe eklemek i&ccedil;in <em>add</em>() y&ouml;ntemini kullanabiliriz. Bu nedenle next() metoduna yapılan sonraki istek etkilenmeyecektir ve previous() metoduna yapılan istek, yeni eklenen &ouml;ğeyi d&ouml;nd&uuml;r&uuml;r.</h4>\n\n<h4>Iterator&#39;da sadece bir y&ouml;nde hareket edebiliriz. Yani orada add() y&ouml;nteminin bir amacı yoktur.</h4>\n</blockquote>\n\n<h4>Yineleme Sırasında &Ouml;ğeleri Kaldırmak</h4>\n\n<p>Iterator, next() tarafından d&ouml;nd&uuml;r&uuml;len &ouml;ğeyi koleksiyondan kaldırmamıza izin veren bir remove() metoduna sahiptir. Remove() &ouml;ğesinin &ccedil;ağrılması <code>ConcurrentModificationException</code>&nbsp;&ouml;ğesinin atılmasına neden olmaz.</p>\n\n<h4>forEachRemaining()</h4>\n\n<p>Iterator&#39;da kalan t&uuml;m &ouml;ğeleri dahili olarak yineler&nbsp;ve her &ouml;ğe i&ccedil;in forEachRemaining() &ouml;ğesine parametre olarak ge&ccedil;irilen bir Java Lambda İfadesi &ccedil;ağırır.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.ArrayList;\nimport java.util.List;\n\nclass Test {\n    public static void main(String args[]) {\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(\"123\");\n        list.add(\"456\");\n\n        list.iterator().forEachRemaining(System.out::println);\n    }\n}\n/*\n123\n456\n*/</code></pre>\n\n<h4>ListIterator</h4>\n\n<p>Iterator interface&#39;ini extend eder. &Ccedil;ift y&ouml;nl&uuml; bir iterator temsil eden Java ListIterator interface&#39;i&nbsp;- yani &ouml;ğelerde hem ileri hem de geri gezinebileceğiniz bir iterator.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\n\nclass Test {\n    public static void main(String args[]) {\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(\"one\");\n        list.add(\"two\");\n        list.add(\"three\");\n        list.add(\"four\");\n\n        Iterator&lt;String&gt; iterator = list.iterator();\n        // list.add(\"five\");\n        // list.remove(0);\n        while(iterator.hasNext()) {\n            System.out.println(iterator.next());\n            //iterator.remove();\n        }\n        System.out.println(list);\n        System.out.println(\"-----------------\");\n        ListIterator&lt;String&gt; listIterator = list.listIterator();\n        listIterator.add(\"five\"); // listenin en başına ekliyor\n        while(listIterator.hasNext()){\n            String s = listIterator.next();\n            System.out.println(\"next: \" + s + \" hashcode: \" + s.hashCode());\n        }\n        System.out.println(\"-----------------\");\n        while(listIterator.hasPrevious()){\n            String s = listIterator.previous();\n            System.out.println(\"previous: \" + s + \" hashcode: \" + s.hashCode());\n        }\n        System.out.println(list);\n    }\n}\n/*\none\ntwo\nthree\nfour\n[one, two, three, four]\nnext: one\nnext: two\nnext: three\nnext: four\nprevious: four\nprevious: three\nprevious: two\nprevious: one\nprevious: five\n[five, one, two, three, four]\n\nProcess finished with exit code 0\n\n*/</code></pre>\n\n<h4>Custom Implementation</h4>\n\n<p>&Ouml;zel yapılmış bir koleksiyonumuz olduğunu d&uuml;ş&uuml;nelim, bunun &ouml;ğelerini yineleyebilen bir Iterator oluşturmak i&ccedil;in Java Iterator interface&#39;ini kendimiz uygulayabiliriz.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nclass Test {\n    public static void main(String args[]) {\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n\n        list.add(\"one\");\n        list.add(\"two\");\n        list.add(\"three\");\n\n        ListIterator&lt;String&gt; iterator = new ListIterator&lt;&gt;(list);\n        while(iterator.hasNext()) {\n            System.out.println( iterator.next() );\n        }\n\n    }\n}\n\nclass ListIterator&lt;T&gt; implements Iterator&lt;T&gt; {\n    private final List&lt;T&gt; source;\n    private int index = 0;\n\n    public ListIterator(List&lt;T&gt; source){\n        this.source = source;\n    }\n\n    @Override\n    public boolean hasNext() {\n        boolean hasNext = this.index &lt; this.source.size();\n        System.out.println(\"hasNext: \" + hasNext + \" index: \" + this.index + \" size: \" + this.source.size());\n        return hasNext;\n    }\n\n    @Override\n    public T next() {\n        return this.source.get(this.index++);\n    }\n}\n/*\nhasNext: true index: 0 size: 3\none\nhasNext: true index: 1 size: 3\ntwo\nhasNext: true index: 2 size: 3\nthree\nhasNext: false index: 3 size: 3\n*/</code></pre>\n\n<h2>Iterable</h2>\n\n<p>Yinelenebilir(<em>iterable</em>) olan bir nesnelerin koleksiyonunu temsil eder. Bu, <code>Iterable</code>&nbsp;interface&#39;ini uygulayan bir sınıfın &ouml;ğelerini yineleyebileceği anlamına gelir.</p>\n\n<p><code>Iterator:</code></p>\n\n<p>Yukarıda işledik</p>\n\n<p><code>for()</code>:</p>\n\n<p><code>forEach()</code>:</p>\n\n<pre>\n<code class=\"language-java\">import java.util.ArrayList;\nimport java.util.List;\n\nclass Test {\n    public static void main(String args[]) {\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(\"one\");\n        list.add(\"two\");\n\n        // list.forEach(System.out::println);\n\n        for(String element : list)\n            System.out.println(element);\n    }\n}\n\n/*\none\ntwo\n*/</code></pre>\n\n<h4>Tanımlanması</h4>\n\n<pre>\n<code class=\"language-java\">// Implementing this interface allows an object to be the target of the \"for-each loop\" statement. @since 1.5\npublic interface Iterable&lt;T&gt; {\n    // Returns an iterator over elements of type {@code T}.\n    Iterator&lt;T&gt; iterator();\n\n    // Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception. @since 1.8\n    Spliterator&lt;T&gt; spliterator();\n\n    // Creates a {@link Spliterator} over the elements described by this Iterable @since 1.8\n    void forEach(Consumer&lt;? super T&gt; action);\n}</code></pre>\n\n<p><code>Iterable</code> interface&#39;i, Java Koleksiyonları API&#39;sinin k&ouml;k arabirimlerinden biridir. Bu nedenle, Java&#39;da Java Iterable interface&#39;ini implement eden birka&ccedil; sınıf vardır. Bu sınıflar b&ouml;ylece kendi i&ccedil; &ouml;ğelerini yineleyebilir. Ayrıca bu interface&#39;i extend eden birka&ccedil; interface de vardır.</p>\n\n<p>Collection interface&#39;i, Iterable&#39;i extend eder, b&ouml;ylece Collection&#39;ın t&uuml;m alt t&uuml;rleri, Iterable interface&#39;ini de uygular. &Ouml;rneğin, hem List&nbsp;hem de Set interface&#39;leri, Collection interface&#39;ini extend ettiği i&ccedil;in dolayısıyla Iterable interface&#39;ini de extend eder.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nclass Test {\n    public static void main(String args[]) {\n        Persons list = new Persons();\n\n        Iterator&lt;Person&gt; it = list.iterator();\n        while (it.hasNext()) {\n            Person p = it.next();\n            System.out.println(p.name + \" \" + p.age);\n        }\n    }\n}\nclass Persons implements Iterable&lt;Person&gt; {\n    private final List&lt;Person&gt; persons = new ArrayList&lt;&gt;();\n\n    public Persons() {\n        persons.add(new Person(\"John\", 30));\n        persons.add(new Person(\"Jane\", 25));\n        persons.add(new Person(\"Jack\", 20));\n    }\n\n    public Iterator&lt;Person&gt; iterator() {\n        System.out.println(\"returned iterator\");\n        return this.persons.iterator();\n    }\n}\nclass Person {\n    public final String name;\n    public final int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n/*\nreturned iterator\nJohn 30\nJane 25\nJack 20\n*/</code></pre>\n\n<h3>Iterator vs Iterable Performans</h3>\n\n<pre>\n<code class=\"language-java\">import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nclass Test {\n    public static void main(String args[]) {\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 50_000_000; i++) {\n            list.add(i + \"\");\n        }\n        iteratorTest(list);\n        forEachTest(list);\n        forTest(list);\n        whileTest(list);\n        doWhileTest(list);\n        streamTest(list);\n        streamParallelTest(list);\n    }\n\n    private static void iteratorTest(List&lt;String&gt; list) {\n        long started = System.nanoTime();\n        Iterator&lt;String&gt; iterator = list.iterator();\n        while (iterator.hasNext()) {\n            Object obj = iterator.next();\n        }\n        System.out.println(\"Time taken iterator: \" + (System.nanoTime() - started) / 1_000_000);\n    }\n\n    private static void forEachTest(List&lt;String&gt; list) {\n        long started = System.nanoTime();\n        for (String element : list){\n            Object obj = element;\n        }\n        System.out.println(\"Time taken foreach: \" + (System.nanoTime() - started) / 1_000_000);\n    }\n\n    private static void forTest(List&lt;String&gt; list) {\n        long started = System.nanoTime();\n        for (int i = 0; i &lt; list.size(); i++) {\n            Object obj = list.get(i);\n        }\n        System.out.println(\"Time taken for loop: \" + (System.nanoTime() - started) / 1_000_000);\n    }\n\n    private static void whileTest(List&lt;String&gt; list) {\n        long started = System.nanoTime();\n        int i = 0;\n        while (i &lt; list.size()) {\n            Object obj = list.get(i);\n            i++;\n        }\n        System.out.println(\"Time taken while: \" + (System.nanoTime() - started) / 1_000_000);\n    }\n\n    private static void doWhileTest(List&lt;String&gt; list) {\n        int i = 0;\n        long started = System.nanoTime();\n        do {\n            Object obj = list.get(i);\n            i++;\n        } while (i &lt; list.size());\n        System.out.println(\"Time taken do while: \" + (System.nanoTime() - started) / 1_000_000);\n    }\n\n    private static void streamTest(List&lt;String&gt; list) {\n        long started = System.nanoTime();\n        list.forEach(element -&gt; {\n            Object obj = element;\n        });\n        System.out.println(\"Time taken stream: \" + (System.nanoTime() - started)   / 1_000_000);\n    }\n\n    private static void streamParallelTest(List&lt;String&gt; list) {\n        long started = System.nanoTime();\n        list.stream().parallel().forEach(element -&gt; {\n            Object obj = element;\n        });\n        System.out.println(\"Time taken stream parallel: \" + (System.nanoTime() - started)   / 1_000_000);\n    }\n\n    private static void recursive(List&lt;String&gt; list, int start) {\n        // StackOverflowError\n        if (start &lt; list.size()) {\n            Object obj = list.get(start);\n            recursive(list, start + 1);\n        }\n    }\n\n    // nanoTime(), hassas bir zamanlayıcıdır. currentTimeMillis(), zamanlayıcı yerine bir saattir.\n    // https://jaxenter.com/java-performance-tutorial-how-fast-are-the-java-8-streams-118830.html\n}\n/*\nTime taken iterator: 13\nTime taken foreach: 456\nTime taken for loop: 7\nTime taken while: 10\nTime taken do while: 6\nTime taken stream: 612\nTime taken stream parallel: 380\n*/</code></pre>\n\n<p>for-each d&ouml;ng&uuml;s&uuml;n&uuml;n daha yavaş olmasının nedeni, her yinelemenin yeni bir iterator nesnesi oluşturacak olan <code>List</code>&nbsp;<code>iterator()</code> y&ouml;ntemini &ccedil;ağırmasıdır.</p>\n\n<h2>Collection</h2>\n\n<pre>\n<code class=\"language-java\">Collection collection = new ArrayList();</code></pre>\n\n<ul>\n	<li>List</li>\n	<li>Set</li>\n	<li>SortedSet</li>\n	<li>NavigableSet</li>\n	<li>Queue</li>\n	<li>Deque</li>\n</ul>\n\n<p>Java&#39;da&nbsp;Collection interface&#39;inin&nbsp;kullanılabilir implementation&#39;ı yoktur, bu nedenle listelenen alt t&uuml;rlerden birini kullanmanız gerekecektir. Collection interface&#39;i,&nbsp;Collection&nbsp;alt t&uuml;rlerinin her birinin paylaştığı bir dizi y&ouml;ntemi (davranış) tanımlar. Bu, kullandığımız belirli Collection t&uuml;r&uuml;n&uuml; g&ouml;rmezden gelmemizi ve yalnızca Collection olarak ele almamızı sağlar. Bu standart bir kalıtımdır, yani sihirli bir yanı yoktur, ancak yine de zaman zaman g&uuml;zel bir &ouml;zellik olabilir.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\n\nclass Test {\n    public static void main(String args[]) {\n        Set set  = new HashSet();\n        List list = new ArrayList();\n\n        Test.doSomething(set);\n        Test.doSomething(list);\n\n        Test.add(set, \"foo\");\n        Test.add(list, \"bar\");\n        Test.remove(set, \"foo\");\n\n        System.out.println(\"Size of set: \" + set.size());\n        System.out.println(\"Size of list: \" + list.size());\n    }\n\n    private static void doSomething(Collection collection) {\n        Iterator iterator = collection.iterator();\n        while(iterator.hasNext()){\n            Object object = iterator.next();\n        }\n    }\n\n    private static void add(Collection collection, String element) {\n        collection.add(element);\n    }\n\n    private static void remove(Collection collection, String element) {\n        collection.remove(element);\n    }\n}\n/*\nSize of set: 0\nSize of list: 1\n*/</code></pre>\n\n<h2>Generic Collections</h2>\n\n<p>Java Collections API&#39;sindeki bileşenler&nbsp;i&ccedil;in generic oluşturmak m&uuml;mk&uuml;nd&uuml;r.</p>\n\n<pre>\n<code class=\"language-java\">Collection&lt;String&gt; stringCollection = new HashSet&lt;String&gt;(); // Generic Collection\nIterator&lt;String&gt; iterator = stringCollection.iterator(); // Generic Iterator</code></pre>\n\n<h2>Collections</h2>\n\n<p><em>Java</em>&nbsp;<code>Collections</code> sınıfı, <code>java.util.Collections</code>, Java&#39;da koleksiyonlarla &ccedil;alışmak i&ccedil;in uzun bir yardımcı program y&ouml;ntemleri listesi i&ccedil;erir.</p>\n\n<h3>binarySearch()</h3>\n\n<pre>\n<code class=\"language-java\">import java.util.*;\n\nclass Test {\n    public static void main(String args[]) {\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(\"one\");\n        list.add(\"two\");\n        list.add(\"three\");\n        Collections.sort(list);\n\n        int index = Collections.binarySearch(list, \"two\");\n\n        System.out.println(index);\n    }\n}\n// 2\n</code></pre>\n\n<p><code>addAll()</code>:&nbsp;<code>Collection&#39;a birden fazla eleman ekler.</code></p>\n\n<p><code>copy():</code>&nbsp;bir Listenin t&uuml;m &ouml;ğelerini başka bir Listeye kopyalar.</p>\n\n<p><code>reverse()</code>:&nbsp;bir Java Listesindeki &ouml;ğeleri tersine &ccedil;evirebilir.</p>\n\n<p><code>shuffle()</code>:&nbsp;bir Listenin &ouml;ğelerini karıştırabilir.</p>\n\n<p><code>sort()</code>:&nbsp;bir Java Listesini sıralayabilir.</p>\n\n<p><code>min()</code>:&nbsp;&ouml;ğelerin doğal sırasına g&ouml;re bir Listedeki minimum &ouml;ğeyi bulabilir.</p>\n\n<p><code>max()</code>:&nbsp;&ouml;ğelerin doğal sırasına g&ouml;re bir Listedeki maximun &ouml;ğeyi bulabilir.</p>\n\n<p><code>replaceAll()</code>:&nbsp;bir &ouml;ğenin t&uuml;m oluşumlarını başka bir &ouml;ğeyle değiştirebilir.</p>\n\n<p><code>unmodifiableSet()</code>:&nbsp;normal bir Java Setinden değişmez (unmodifiable) bir Set oluşturabilir.</p>\n\n<h2>List</h2>\n\n<p>Java List interface&#39;i, <code>java.util.List</code>, sıralı bir nesne dizisini temsil eder. Java Listesinde bulunan &ouml;ğeler, Java Listesinde dahili olarak g&ouml;r&uuml;nd&uuml;kleri sıraya g&ouml;re eklenebilir, erişilebilir, yinelenebilir ve kaldırılabilir. &Ouml;ğelerin sıralanması, bu veri yapısının <em>List</em> olarak adlandırılmasının nedenidir.</p>\n\n<p>Her &ouml;ğenin bir indeksi vardır. Listedeki ilk elemanın indeksi 0, ikinci elemanın indeksi 1 vb. İndeks, &quot;listenin başlangıcından ka&ccedil; eleman uzakta&quot; anlamına gelir. B&ouml;ylece ilk eleman, listenin başlangıcından 0 eleman uzaktadır - &ccedil;&uuml;nk&uuml; listenin başındadır.</p>\n\n<p>Herhangi bir Java nesnesini bir Listeye ekleyebiliriz. Liste, Generics kullanılarak yazılmamışsa, aynı Listede farklı t&uuml;rlerdeki (sınıflardaki) nesneleri bile karıştırabiliriz. Bununla birlikte, aynı Listede farklı t&uuml;rdeki nesneleri karıştırmak pratikte genellikle yapılmaz. Java List arabirimi standart bir arabirimdir ve Java Koleksiyonu arabiriminin bir alt t&uuml;r&uuml;d&uuml;r, yani <code>List</code>&#39;in <code>Collection&#39;</code>dan devraldığı anlamına gelir.</p>\n\n<ul>\n	<li>java.util.ArrayList (En &ccedil;ok kullanılan)</li>\n	<li>java.util.LinkedList</li>\n	<li>java.util.Vector</li>\n	<li>java.util.Stack</li>\n</ul>\n\n<p><code>java.util.concurrent</code> paketinde de concurrent <code>List</code> uygulamaları vardır.</p>\n\n<ul>\n	<li>\n	<pre>\n<code>CopyOnWriteArrayList: </code>A thread-safe variant of java.util.ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.</pre>\n	</li>\n	<li><code>CopyOnWriteArraySet: </code>A Set that uses an internal CopyOnWriteArrayList for all of its operations</li>\n	<li>\n	<pre>\n<code>ConcurrentHashMap</code>: A class is thread-safe if it behaves correctly when accessed from multiple thread</pre>\n	</li>\n</ul>\n\n<p>Listeye <code>null</code> değer ekleyebiliriz.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.*;\n\nclass Test {\n    public static void main(String args[]) {\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(null);\n        System.out.println(\"Size of source: \" + list.size());\n    }\n}\n// Size of source: 1</code></pre>\n\n<p>Eğer aynı index&#39;e birden fazla eleman eklersek, sıralamada var olan eleman aşağı itilecektir yani 0 dizinine eklenmeden &ouml;nce 0 dizinine sahip eleman 1 dizinine iletilecektir.</p>\n\n<pre>\n<code class=\"language-java\">import java.util.*;\n\nclass Test {\n    public static void main(String args[]) {\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        list.add(0, \"1\");\n        list.add(0, \"2\");\n        System.out.println(\"List: \" + list);\n    }\n}\n// List: [2, 1]</code></pre>\n\n<h2>Set</h2>\n\n<p><em>Java</em>&nbsp;<em>Set</em>&nbsp;interface, <code>java.util.Set</code>, Java Set i&ccedil;indeki her nesnenin benzersiz olduğu bir nesneler koleksiyonunu temsil eder. Başka bir deyişle, aynı nesne bir Java Setinde birden fazla olamaz. Standart bir Java interface&#39;idir ve Java Koleksiyonu arabiriminin bir alt t&uuml;r&uuml;d&uuml;r; bu, Set&#39;in Koleksiyondan devraldığı anlamına gelir. Herhangi bir Java nesnesini bir Java Set&#39;ine ekleyebilirsiniz. Set, Java Generics kullanılarak yazılmamışsa, aynı Set i&ccedil;inde farklı t&uuml;rlerdeki (sınıflardaki) nesneleri bile karıştırabilirsiniz. Bununla birlikte, aynı K&uuml;mede farklı t&uuml;rdeki nesneleri karıştırmak &ccedil;oğu zaman yapılmaz.</p>\n\n<ul>\n	<li><code>java.util.EnumSet</code>:&nbsp;enum sınıflarıyla &ccedil;alışmak i&ccedil;in &ouml;zel bir Set koleksiyonudur.</li>\n	<li><code>java.util.HashSet</code>:&nbsp;HashMap tarafından desteklenir. &Ouml;ğeleri yinelediğinizde, &ouml;ğelerin sırası hakkında hi&ccedil;bir garanti vermez.</li>\n	<li><code>java.util.LinkedHashSet</code>:&nbsp;HashSet&#39;ten farklı olarak,&nbsp;yineleme sırasında &ouml;ğelerin sırasının Set&#39;e eklendikleri sıra ile aynı olmasını garanti eder. Halihazırda LinkedHashSet&#39;te bulunan bir &ouml;ğenin yeniden eklenmesi bu sırayı değiştirmez.</li>\n	<li><code>java.util.TreeSet</code>:&nbsp;iterate edildiğinde &ouml;ğelerin sırasını da garanti eder, ancak sıra, &ouml;ğelerin sıralama d&uuml;zenidir.</li>\n</ul>\n\n<h3>Set vs. List</h3>\n\n<ul>\n	<li>Aynı &ouml;ğenin Set&#39;te birden fazla bulunamamasıdır. Bu, her &ouml;ğenin birden &ccedil;ok kez meydana gelebileceği Java Listesinden farklıdır.</li>\n	<li>Set&#39;teki &ouml;ğelerin garantili bir i&ccedil; sıraya sahip olmamasıdır. List&#39;teki &ouml;ğelerin bir i&ccedil; sırası vardır ve &ouml;ğeler bu sırayla yinelenebilir.</li>\n</ul>\n\n<h3>Set.of()</h3>\n\n<p>Java 9&#39;dan beri Set interface&#39;i, immutable&nbsp;Set &ouml;rnekleri oluşturabilen bir dizi statik metodlar i&ccedil;erir.</p>\n\n<pre>\n<code class=\"language-java\">Set set = Set.of();\nSet&lt;String&gt; set3 = Set.&lt;String&gt;of();\nSet&lt;String&gt; set3 = Set.&lt;String&gt;of(\"val1\", \"val2\", \"val3\");</code></pre>\n\n<h2>ArrayList</h2>\n\n<blockquote>\n<p><strong>ArrayList uses an Array of Object to store the data internally.</strong></p>\n\n<p>When you initialize an ArrayList, an array of size&nbsp;<strong>10</strong>&nbsp;(<strong>default capacity</strong>) is created and an element added to the ArrayList is actually added to this array. 10 is the default size and it can be passed as a parameter while initializing the ArrayList.</p>\n</blockquote>\n\n<p><code>ArrayList</code>, <code>java.util</code> paketinde bulunabilen, yeniden boyutlandırılabilir bir dizidir. Java&#39;da yerleşik bir dizi ile ArrayList arasındaki fark, bir dizinin boyutunun değiştirilememesidir (bir diziye eleman eklemek veya diziden &ouml;ğe &ccedil;ıkarmak istiyorsanız, yeni bir tane oluşturmanız gerekir). ArrayList&#39;e istediğiniz zaman &ouml;ğeler eklenebilir ve kaldırılabilir.</p>\n\n<h2>LinkedList</h2>\n\n<p><code>LinkedList</code>&nbsp;hemen hemen&nbsp;&nbsp;<code>ArrayList</code> ile aynıdır. &Ouml;ğelerin bitişik konumlarda depolanmadığı ve her &ouml;ğenin veri b&ouml;l&uuml;m&uuml; ve adres b&ouml;l&uuml;m&uuml; olan ayrı bir nesne olduğu doğrusal bir veri yapısıdır. &Ouml;ğeler, işaret&ccedil;iler ve adresler kullanılarak bağlanır. Her eleman bir d&uuml;ğ&uuml;m olarak bilinir. Ekleme ve silme işlemlerinin dinamikliği ve kolaylığı nedeniyle dizilere g&ouml;re tercih edilirler.</p>\n\n<p><img alt=\"types_of_linked_list-singly-linked-list-img1\" src=\"https://www.simplilearn.com/ice9/free_resources_article_thumb/LinkedListInJava_1.png\" style=\"height:100px; width:268px\" />&nbsp;Tek y&ouml;nl&uuml; bir bağlı&nbsp;listedir. Yalnızca bir y&ouml;nde, yani baş d&uuml;ğ&uuml;mden kuyruk d&uuml;ğ&uuml;m&uuml;ne ge&ccedil;ebilirsiniz.&nbsp;Listedeki son d&uuml;ğ&uuml;m kuyruktur ve NULL&#39;a işaret eder.</p>\n\n<p><img alt=\"types_of_linked_list-doubly-linked-list-img1.\" src=\"https://www.simplilearn.com/ice9/free_resources_article_thumb/LinkedListInJava_3.png\" style=\"height:100px; width:303px\" />&nbsp;&Ccedil;ift y&ouml;nl&uuml; bağlı bir listedir. B&ouml;ylece her iki y&ouml;nde de hareket edebiliriz. Tek y&ouml;nl&uuml; bağlı&nbsp;listelerin aksine, d&uuml;ğ&uuml;mleri &quot;previous&quot;&nbsp;pointer olarak adlandırılan fazladan bir işaret&ccedil;i i&ccedil;erir.</p>\n\n<p><img alt=\"types_of_linked_list-circular-linked-list-img1.\" src=\"https://www.simplilearn.com/ice9/free_resources_article_thumb/LinkedListInJava_5.png\" style=\"height:100px; width:195px\" />&nbsp;Dairesel Bağlı liste, tek y&ouml;nl&uuml; bağlı bir listedir. B&ouml;ylece, onu sadece bir y&ouml;nde hareket ettirebiliriz. Ancak bu t&uuml;r bağlantılı listelerin son d&uuml;ğ&uuml;m&uuml; baş d&uuml;ğ&uuml;m&uuml; g&ouml;sterir. Bu y&uuml;zden ge&ccedil;iş yaparken dikkatli olmanız ve baş d&uuml;ğ&uuml;m&uuml; tekrar ziyaret ettiğinizde ge&ccedil;işi durdurmanız gerekir.</p>\n\n<p><img alt=\"types_of_linked_list-circular-doubly-linked-list-img1\" src=\"https://media.geeksforgeeks.org/wp-content/uploads/Circular-doubly-linked-list.png\" style=\"height:100px; width:425px\" />&nbsp;Dairesel &ccedil;ift bağlı liste, &ccedil;ift bağlı liste ile dairesel bağlı listenin bir karışımıdır. &Ccedil;ift bağlı liste gibi, &ouml;nceki işaret&ccedil;i olarak adlandırılan fazladan bir işaret&ccedil;iye sahiptir ve dairesel bağlı listeye benzer şekilde, son d&uuml;ğ&uuml;m&uuml; baş d&uuml;ğ&uuml;mdedir. Bu t&uuml;r bağlı liste, &ccedil;ift y&ouml;nl&uuml; listedir. B&ouml;ylece her iki y&ouml;nde de hareket edebilirsiniz.</p>\n\n<h3>Vector</h3>\n\n<p>Vekt&ouml;r, boyutunu b&uuml;y&uuml;tebilen veya k&uuml;&ccedil;&uuml;ltebilen <em>dynamic </em><em>array</em>&nbsp;gibidir. Diziden farklı olarak, boyut sınırı olmadığı i&ccedil;in i&ccedil;inde n sayıda &ouml;ğe saklayabiliriz.</p>\n\n<p>Vector sınıfını&nbsp;thread-safe uygulamalarda kullanılması &ouml;nerilir. İş par&ccedil;acığı g&uuml;venli uygulamayı kullanmanız gerekmiyorsa, ArrayList&#39;i kullanmalısınız, bu durumda ArrayList daha iyi performans g&ouml;sterecektir.</p>\n\n<p>Vector sınıfı tarafından d&ouml;nd&uuml;r&uuml;len Iterator&#39;lar, <em>fail-fast&#39;</em>tır. Concurrent modification durumunda, başarısız olur ve ConcurrentModificationException&#39;ı atar.</p>\n\n<ul>\n	<li>Vector synchroniztır.</li>\n	<li>Vector, collections framework&#39;&uuml;n&nbsp;par&ccedil;ası olmayan bir&ccedil;ok legacy metod&nbsp;i&ccedil;erir.</li>\n</ul>\n\n<p><strong>Synchronization</strong></p>\n\n<p>Birden fazla thread aynı anda bir ArrayList&#39;e erişiyorsa, listeyi yapısal olarak(listeden eleman(lar)ın eklenmesi veya silinmesi) değiştiren veya bir &ouml;ğeyi basit&ccedil;e değiştiren kod bloğunu harici olarak senkronize etmeliyiz. Mevcut bir elemanın değerini ayarlamak yapısal bir değişiklik değildir.</p>\n\n<p><strong>Data growth</strong></p>\n\n<p>Hem ArrayList hem de Vector, bir Array kullanarak i&ccedil;eriklerini tutar. ArrayList&#39;e veya Vector&#39;e bir &ouml;ğe eklendiğinde, yer biterse nesnenin dahili dizisini genişletmesi gerekir. Bir Vector varsayılan olarak dizisinin boyutunu iki katına &ccedil;ıkarır, ArrayList ise dizi boyutunu y&uuml;zde 50 artırır.</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>', 'collectionlar', 'Collectionlar - TODO', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'checked;unchecked'),
('1cb9374e-4e52-4142-a1af-30000ef4a271', '<p><code>Spring</code> veya <code>Spring Boot</code> ile veritabanı sorgularını ger&ccedil;ekleştirmemizi sağlayan bir ara&ccedil;tır. Specificationlar, Criteria API&#39;sinin &uuml;st&uuml;ne inşa edilmiştir. Bir kriter sorgusu oluştururken, <code>Root</code>,&nbsp;<code>CriteraQuery</code>, ve&nbsp;<code>CriteriaBuilder</code> nesnelerini kendimiz kurmamız ve y&ouml;netmemiz gerekir.</p>\n\n<p>Aşağıdaki kodu inceleyelim;</p>\n\n<pre>\n<code class=\"language-java\">@Data\n@Entity\n@Table(name = \"activity\")\npublic class Activity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    private String accountId;\n    private String userId;\n    private LocalDateTime created;\n}</code></pre>\n\n<pre>\n<code class=\"language-java\">private Specification&lt;?&gt; getSpecifications() {\n	return (root, query, criteriaBuilder) -&gt; {\n		Predicate preAccountId = criteriaBuilder.equal(root.get(\"accountId\"), \"anilAccountId\");\n		Predicate preUserId = criteriaBuilder.equal(root.get(\"userId\"), \"anilUserId\");\n		Predicate preCreated = criteriaBuilder.and(\n			criteriaBuilder.greaterThanOrEqualTo(root.get(\"created\").as(LocalDateTime.class), LocalDateTime.now(ZoneId.systemDefault())),\n			criteriaBuilder.lessThanOrEqualTo(root.get(\"created\").as(LocalDateTime.class), LocalDateTime.now(ZoneId.systemDefault()).plusDays(7))\n		);\n		query.orderBy(criteriaBuilder.desc(root.get(\"created\")));\n		return criteriaBuilder.and(preAccountId, preUserId, preCreated);\n	};\n}</code></pre>\n\n<pre>\n<code class=\"language-java\">List&lt;Activity&gt; activityList = activityRepository.findAll((Specification&lt;Activity&gt;)getSpecifications());</code></pre>\n\n<p>Bu &ouml;rnek <code>Activity</code> Entity &uuml;zerinde aşağıdaki &ouml;zellikleri sağlayan t&uuml;m dataları filtreledik ve <code>created</code> alanına g&ouml;re <code>descending</code> order verdik,</p>\n\n<ul>\n	<li>accountId&#39;si &quot;<strong>anilAccountId</strong>&quot; olan,</li>\n	<li>userId&#39;si &quot;<strong>anilUserId</strong>&quot; olan,</li>\n	<li>created alanı ise <strong>bug&uuml;n ile 7 g&uuml;n sonrası</strong> olan,</li>\n</ul>\n\n<p><strong>Not:</strong> Repositorymizi&nbsp;<code>JpaSpecificationExecutor</code> interface&#39;inden extend etmeyi unutmamalıyız.</p>', 'spring-data-jpa-specifications', 'Spring Data JPA Specifications', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'JPA;Specifications'),
('1cb9374e-4e52-4142-a1af-30001ef4a271', '<p><code>@PreAuthorize</code>,&nbsp;<code>@RolesAllowed</code>&nbsp;ve&nbsp;<code>@Secured</code> &ouml;ğelerinin t&uuml;m&uuml;, <em>method</em> g&uuml;venliğini yapılandırmaya izin veren annotationlardır. Hem bireysel metodlara hem de sınıf d&uuml;zeyinde uygulanabilirler Method&nbsp;d&uuml;zeyinde g&uuml;venlik, <a href=\"https://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch08s06.html\" rel=\"noreferrer\">Spring AOP proxies</a>&#39;leri kullanılarak ger&ccedil;ekleştirilir.</p>\n\n<p><code>@PreAuthorize</code></p>\n\n<p>Spring Security 3 ile birlikte&nbsp;<code>@PreAuthorize</code>&nbsp;and&nbsp;<code>@PostAuthorize</code>&nbsp;desteklemiştir.</p>\n\n<p><em>Spring Expression Language (SpEL)</em> kullanılarak bir metoda erişim kısıtlamalarının belirlenmesine olanak tanır. Bu kısıtlamalar, metod y&uuml;r&uuml;t&uuml;lmeden &ouml;nce değerlendirilir ve kısıtlamalar yerine getirilmezse, metodun y&uuml;r&uuml;t&uuml;lmesinin reddedilmesine neden olabilir.</p>\n\n<p>Spring Security framework&#39;&uuml;n bir par&ccedil;asıdır. Kullanabilmek i&ccedil;in <code>@EnableGlobalMethodSecurity</code> annotationdaki&nbsp;<em><code>prePostEnabled</code></em> &ouml;zniteliğinin true olarak ayarlanması gerekir:</p>\n\n<pre>\n<code class=\"language-java\">@EnableGlobalMethodSecurity(prePostEnabled=true)</code></pre>\n\n<pre>\n<code class=\"language-java\">@PreAuthorize(\"hasRole(\'ROLE_VIEWER\') or hasRole(\'ROLE_EDITOR\')\") // OR, AND olabilir\npublic boolean isValidUsername(String username) {}</code></pre>\n\n<p><code>@RolesAllowed</code></p>\n\n<p>Kaynağı,&nbsp;<a href=\"https://jcp.org/en/jsr/detail?id=250\" rel=\"noreferrer\">JSR-250</a>&nbsp;Java g&uuml;venlik standardındadır. Bu a&ccedil;ıklama, yalnızca rol tabanlı g&uuml;venliği desteklediğinden <code>@PreAuthorize</code> ek a&ccedil;ıklamasından daha sınırlıdır. Kullanmak i&ccedil;in, bu a&ccedil;ıklamayı i&ccedil;eren kitaplığın, Spring Security&#39;nin bir par&ccedil;ası olmadığı i&ccedil;in sınıf yolunda olması gerekir. Ek olarak, <code>@EnableGlobalMethodSecurity</code> ek a&ccedil;ıklamasının <em><code>jsr250Enabled</code></em>&nbsp;&ouml;zniteliğinin true olarak ayarlanması gerekir:</p>\n\n<pre>\n<code class=\"language-java\">@EnableGlobalMethodSecurity(jsr250Enabled=true)</code></pre>\n\n<pre>\n<code class=\"language-java\">@RolesAllowed({ \"ROLE_VIEWER\", \"ROLE_EDITOR\" }) // OR ile seçilir\npublic boolean isValidUsername(String username) {\n    //...\n}</code></pre>\n\n<p><code>@Secured</code></p>\n\n<p>Metod g&uuml;venliğini yapılandırmak i&ccedil;in kullanılabilen eski bir Spring Security 2 annotationdır. Rol tabanlı g&uuml;venlikten fazlasını destekler, ancak g&uuml;venlik kısıtlamalarını belirtmek i&ccedil;in <em>Spring Expression Language (SpEL)</em> kullanımını desteklemez. Yeni uygulamalarda <code>@PreAuthorize</code>&nbsp;notunun bu anotasyon &uuml;zerinden kullanılması tavsiye edilir. Kullanılması i&ccedil;in&nbsp;<code>@EnableGlobalMethodSecurity</code> ek a&ccedil;ıklamasında <em><code>securedEnabled</code></em>&nbsp;&ouml;zniteliği etkinleştirilmesi gerekir:</p>\n\n<pre>\n<code class=\"language-java\">@EnableGlobalMethodSecurity(securedEnabled=true)</code></pre>\n\n<p><code>@Secured(&quot;ROLE_ADMIN&quot;)</code>&nbsp;annotation ile&nbsp;<code>@PreAuthorize(&quot;hasRole(&#39;ROLE_ADMIN&#39;)&quot;)</code> aynıdır ancak&nbsp;<code>@Secured({&quot;ROLE_USER&quot;,&quot;ROLE_ADMIN&quot;)</code>&nbsp;<em>ROLE_USER</em>&nbsp;<strong>VEYA</strong>&nbsp;<em>ROLE_ADMIN</em> olarak işlenir. <strong>VE</strong> operat&ouml;r&uuml;n&uuml; desteklemiyor.</p>\n\n<p><code>@Secured</code>&nbsp;ve&nbsp;<code>@RolesAllowed</code>&nbsp;aynı şeyi ifade eder ve farkı <code>@Secured</code>&nbsp;Spring&#39;e &ouml;zel bir annotationdır ancak&nbsp;<code>@RolesAllowed</code>&nbsp;Java standard annotationdır(JSR250).</p>\n\n<pre>\n<code class=\"language-java\">@Secured({ \"ROLE_VIEWER\", \"ROLE_EDITOR\" }) // OR ile seçilir\npublic boolean isValidUsername(String username) {\n    return userRoleRepository.isValidUsername(username);\n}</code></pre>\n\n<p><code>@PreFilter</code></p>\n\n<p>Metodu &ccedil;alıştırmadan &ouml;nce bir koleksiyon bağımsız değişkenini filtrelemek i&ccedil;in <code>@PreFilter</code> annotation&#39;ı&nbsp;kullanılır:</p>\n\n<pre>\n<code class=\"language-java\">@PreFilter(\"filterObject != authentication.principal.username\")\npublic String joinUsernames(List&lt;String&gt; usernames) {\n    return usernames.stream().collect(Collectors.joining(\";\"));\n}</code></pre>\n\n<p>Bu &ouml;rnekte, kimliği doğrulanan kullanıcı dışındaki t&uuml;m kullanıcı adlarını birleştiriyoruz. Burada, ifademizde, koleksiyondaki mevcut nesneyi temsil etmek i&ccedil;in <strong><em>filterObject</em>&nbsp;</strong>adını kullanıyoruz. Ancak, metodun bir koleksiyon t&uuml;r&uuml; olan birden fazla arg&uuml;manı varsa, hangi arg&uuml;manı filtrelemek istediğimizi belirtmek i&ccedil;in <em>filterTarget</em>&nbsp;&ouml;zelliğini kullanmamız gerekir:</p>\n\n<pre>\n<code class=\"language-java\">@PreFilter(value = \"filterObject != authentication.principal.username\", filterTarget = \"usernames\")\npublic String joinUsernamesAndRoles(List&lt;String&gt; usernames, List&lt;String&gt; roles) {\n    return usernames.stream().collect(Collectors.joining(\";\")) + \":\" + roles.stream().collect(Collectors.joining(\";\"));\n}</code></pre>\n\n<p>Aşağıdaki tablo, Spring Security 5 ile kullanılabilen g&uuml;venlik annotationlarının Spring Expression Language desteğini g&ouml;stermektedir:</p>\n\n<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px\">\n	<tbody>\n		<tr>\n			<td><strong>Security Annotation</strong></td>\n			<td><strong>SpEL Desteği</strong></td>\n		</tr>\n		<tr>\n			<td>@PreAuthorize</td>\n			<td>EVET</td>\n		</tr>\n		<tr>\n			<td>@PostAuthorize</td>\n			<td>EVET</td>\n		</tr>\n		<tr>\n			<td>@PreFilter</td>\n			<td>EVET</td>\n		</tr>\n		<tr>\n			<td>@PostFilter</td>\n			<td>EVET</td>\n		</tr>\n		<tr>\n			<td>@Secured</td>\n			<td>HAYIR</td>\n		</tr>\n		<tr>\n			<td>@RolesAllowed</td>\n			<td>HAYIR</td>\n		</tr>\n	</tbody>\n</table>', 'spring-security-annotations', 'Spring Security Annotations', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'PreAuthorize;RolesAllowed;PreFilter;Secured'),
('1cb9374e-4e52-4142-a1af-30002ef4a271', '<pre>\n<code class=\"language-java\">@Entity\n@Getter\n@Setter\n@Builder\n@NoArgsConstructor\n@Table(name = \"transactions\", uniqueConstraints = {\n    @UniqueConstraint(columnNames = {\"id\"})\n})\n@AllArgsConstructor\n@EntityListeners(Transaction.TransactionListeners.class)\npublic class Transaction{\n    @Id\n    @GeneratedValue(generator = \"UUID\")\n    @GenericGenerator(\n            name = \"UUID\",\n            strategy = \"org.hibernate.id.UUIDGenerator\"\n    )\n    @Column(name = \"id\", updatable = false, nullable = false)\n    private String id;\n\n    @Column\n    private String name;\n\n    public static class TransactionListeners {\n        @PrePersist\n        public void onPrePersist(final Transaction transaction) {\n            transaction.setId(UUID.randomUUID().toString());\n        }\n    }\n}\n</code></pre>\n\n<p>Bu bizim java&#39;nın bize sunduğu bir Entity sınıfı, g&ouml;r&uuml;ld&uuml;ğ&uuml; gibi,</p>\n\n<pre>\n<code class=\"language-java\">@EntityListeners(Transaction.TransactionListeners.class)</code></pre>\n\n<p>İle işaretlenmiş bir inner sınıfımız var, bu sınıf entity&#39;e herhangi bir işlem ger&ccedil;ekleştiğinde &ccedil;alışacak olan sınıftır. Ancak bu sınıf i&ccedil;erisinde herhangi bir bean&#39;e(reposiotory yada servis katmanı) erişmek istediğimizde ne olur?</p>\n\n<p>Mesela bu tablo&#39;ya bir kayıt eklendiğinde başka bir tabloda g&uuml;ncelleme işlemi yapmak istiyoruz? Bu durumda Spring Autowired gibi dependency injection yapamayacak &ccedil;&uuml;nk&uuml; burayı spring y&ouml;netmiyor. Yapmamız gereken ApplicationContext i&ccedil;erisinde bean&#39;i &ccedil;ekmemiz gerekecek.</p>\n\n<p>Bu durumda aşağıdaki servis ile işimizi yapabiliriz.</p>\n\n<pre>\n<code class=\"language-java\">@Service\npublic class ContextWrapper implements ApplicationContextAware {\n    private static ApplicationContext applicationContext;\n\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n\n    public static Object getBean (String beanId) {\n        return applicationContext.getBean(beanId);\n    }\n}</code></pre>\n\n<p>Bu kadar, yapmamız gereken tek şey;</p>\n\n<pre>\n<code class=\"language-java\">AccountRepository accountRepository = (AccountRepository) ContextWrapper.getBean(\"accountRepository\");</code></pre>\n\n<p>&nbsp;</p>', 'entity-listenerda-beanlere-erismek', 'Entity Listener\'da Bean\'lere erişmek', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'ApplicationContext;EntityListeners'),
('1cb9374e-4e52-4142-a1af-30003ef4a271', '<p>Bir filtre kullanarak, mapping y&ouml;ntemlerinin her biri i&ccedil;in manuel olarak yanıt eklemekten ka&ccedil;ınabiliriz.</p>\n\n<h3><strong>OncePerRequestFilter Implement Etme</strong></h3>\n\n<p>&Ouml;zel bir filtre oluşturmak i&ccedil;in ayrıca soyut sınıf&nbsp;<code>OncePerRequestFilter</code>&nbsp;extend edilir ve filtreye <code>@Component</code>&nbsp;annotation ekleriz. Her response&#39;a bir header ayarlamak i&ccedil;in, <code>HttpServletResponse</code>&nbsp;interface&#39;inin <code>addHeader()</code> y&ouml;ntemini kullanılırız.</p>\n\n<pre>\n<code class=\"language-java\">import org.springframework.stereotype.Component;\nimport org.springframework.web.filter.OncePerRequestFilter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@Component\npublic class FirstFilter extends OncePerRequestFilter {\n    @Override\n    protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain)throws ServletException, IOException {\n        httpServletResponse.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n        filterChain.doFilter(httpServletRequest, httpServletResponse);\n    }\n}</code></pre>\n\n<h3><strong>Implementing Filter Interface&nbsp;Implement Etme</strong></h3>\n\n<p>Ayrıca <code>Filter</code>&nbsp;aray&uuml;z&uuml;n&uuml; uygulayabilir ve filtreye, onu tanıması i&ccedil;in <code>@Component</code> gibi Spring stereotiplerinden biriyle a&ccedil;ıklama ekleyebiliriz. Her yanıta &ouml;zel başlık ayarlamak i&ccedil;in,&nbsp;<code>HttpServletResponse</code>&nbsp;interface&#39;inin&nbsp;<code>addHeader()</code> y&ouml;ntemini kullanılır.</p>\n\n<pre>\n<code class=\"language-java\">import org.springframework.stereotype.Component;\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@Component\npublic class FirstFilter implements Filter {\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException{\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpServletResponse res = (HttpServletResponse) response;\n        res.addHeader(\"Access-Control-Allow-Origin\", \"*\");\n        chain.doFilter(req, res);\n    }\n}</code></pre>', 'tum-responselara-header-ekleme', 'Tüm response\'lara Header ekleme', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'header'),
('1cb9374e-4e52-4142-a1af-30004ef4a271', '<h2 style=\"text-align:justify\"><strong>JPA (Java Persistence API) nedir?</strong></h2>\n\n<p style=\"text-align:justify\">JPA, Java nesnelerini ilişkisel bir veritabanına eşlemek i&ccedil;in Java standardıdır. JPA, ORM&nbsp;yaklaşımıdır. Geliştirici, JPA aracılığıyla, ilişkisel veritabanlarından Java nesnelerine crud(create/read/update/delete) işlemlerine izin verir. JPA, Java-EE ve Java-SE uygulamalarında kullanılabilir. JPA bir spesifikasyondur ve &ccedil;eşitli uygulamalar mevcuttur.</p>\n\n<h2 style=\"text-align:justify\"><strong>ORM (Objet Relational Mapping) nedir?</strong></h2>\n\n<p style=\"text-align:justify\">ORM, tamamen Entity olarak adlandırılan d&uuml;z Java Nesneleri bi&ccedil;imindeki verileri temsil etmek ve bunlara erişmekle ilgili olan JPA&#39;nın temelidir. Hibernate, EclipseLink ve Apache OpenJPA, Hibernate&#39;in daha pop&uuml;ler olduğu ve yaygın olarak kullanıldığı JPA uygulamalarından bazılarıdır.</p>\n\n<h2 style=\"text-align:justify\"><strong>Hibernate nedir?</strong></h2>\n\n<p style=\"text-align:justify\">Hibernate, Java ortamları i&ccedil;in bir ORM &ccedil;&ouml;z&uuml;m&uuml;d&uuml;r. Hibernate, uygulama etki alanı nesnelerini ilişkisel veritabanı tablolarıyla eşlemek i&ccedil;in bir &ccedil;er&ccedil;eve sağlayan Java tabanlı bir ORM aracıdır. Hibernate, JPA&#39;nın bir referans uygulamasını sağlar ve bu, onu gevşek birleştirme avantajlarıyla ORM aracı olarak m&uuml;kemmel bir se&ccedil;im haline getirir.&nbsp; Hibernate, Java tabanlı bir ORM teknolojisidir.<img src=\"/upload/files/orm_example.png\" style=\"height:188px; width:800px\" /></p>\n\n<p style=\"text-align:justify\">Buraya kadar yazılanlardan yola &ccedil;ıkarak JPA (Java Persistence Api) &lsquo;ın bir standart, Hibernate&rsquo;in ise bir JPA uygulaması olduğunu aklımızdan &ccedil;ıkarmayalım.</p>\n\n<h2 style=\"text-align:justify\"><strong>Spring Data JPA nedir?</strong></h2>\n\n<p style=\"text-align:justify\">Spring Data ailesinin bir &uuml;yesi olan&nbsp;Spring Data JPA,&nbsp;JPA tabanlı repository&#39;lerin&nbsp;kolayca uygulanmasını kolaylaştırır. Bu mod&uuml;l, JPA tabanlı veri erişim katmanları i&ccedil;in gelişmiş destek verir.</p>\n\n<p style=\"text-align:justify\">Spring Data sanıldığı aksine Hibernate gibi bir JPA uygulaması değildir. Sadece JPA uygulamamızın en &uuml;st katmanına ekstra soyut bir katman ekleyen bir k&uuml;t&uuml;phanedir.</p>\n\n<p style=\"text-align:justify\">Veri erişim teknolojilerini kullanan Spring destekli uygulamalar oluşturmayı kolaylaştırır. Bir uygulamanın veri erişim katmanını uygulamak, uzun s&uuml;redir k&uuml;lfetli olmuştur. Basit sorguları y&uuml;r&uuml;tmek, sayfalandırma ve denetleme yapmak i&ccedil;in &ccedil;ok fazla standart kod yazılmalıdır.</p>\n\n<p style=\"text-align:justify\">Spring Data JPA, &ccedil;abayı ger&ccedil;ekten ihtiya&ccedil; duyulan miktara indirerek veri erişim katmanlarının uygulanmasını &ouml;nemli &ouml;l&ccedil;&uuml;de iyileştirmeyi ama&ccedil;lamaktadır. Bir geliştirici olarak, &ouml;zel metodlarda dahil olmak &uuml;zere,&nbsp;repository interface&#39;ler&nbsp;yazarız ve Spring, uygulamayı otomatik tanır.</p>\n\n<h2 style=\"text-align:justify\"><strong>Spring Data JPA vs Hibernate</strong></h2>\n\n<p style=\"text-align:justify\">Spring Data JPA kullanarak aşağıdaki CrudRepository uygulamasını d&uuml;ş&uuml;nelim:</p>\n\n<pre>\n<code class=\"language-java\">import bookservice.model.Author;\nimport org.springframework.data.repository.CrudRepository;\n\npublic interface AuthorRepository extends CrudRepository {}</code></pre>\n\n<p style=\"text-align:justify\">CrudRepository aray&uuml;z&uuml;n&uuml; basit&ccedil;e genişleterek Spring, aşağıdaki depo y&ouml;ntemlerini otomatik olarak uygulayacaktır:</p>\n\n<pre>\n<code class=\"language-bash\">save()\nsaveAll()\nfindById()\nexistsById()\nfindAll()\nfindAllById()\ncount()\ndeleteById()\ndelete()\ndeleteAll()</code></pre>\n\n<p style=\"text-align:justify\">Nesnelerin veritabanında kalmasını son derece kolaylaştırıyor...</p>\n\n<pre>\n<code class=\"language-java\">Author author = new Author();\nrepo.save(author); //save to database\nList authors = repo.findAll(); //find all authors</code></pre>\n\n<p style=\"text-align:justify\">Spring Data JPA kullanmasaydık, nesneleri veritabanında kalıcı hale getirmek i&ccedil;in daha fazla standart kod yazmamız gerekirdi ...</p>\n\n<pre>\n<code class=\"language-java\">EntityManagerFactory emfactory = Persistence.createEntityManagerFactory(\"Hibernate\");\n\nEntityManager entitymanager = emfactory.createEntityManager();\nentitymanager.getTransaction().begin();\n\nAuthor author = new Author();\n\nentitymanager.persist(author);\nentitymanager.getTransaction().commit();\n\nentitymanager.close();\nemfactory.close();</code></pre>\n\n<p style=\"text-align:justify\">Entity Manager, işlemleri ger&ccedil;ekleştirme ve kapatma ile ilgili kullanıldığına&nbsp;dikkat edin? Bu, Spring Data JPA&#39;nın ka&ccedil;ınmaya yardımcı olduğu kod t&uuml;r&uuml;d&uuml;r.</p>\n\n<p style=\"text-align:justify\">Spring Data JPA, bir JPA sağlayıcısı ile &ccedil;alışmayı kolaylaştıran bir dizi bağımlılıktır. Hibernate, birka&ccedil; JPA sağlayıcısından biridir. Bu, Spring Data JPA&#39;yı Hibernate&#39;i kullanmadan kullanabileceğiniz anlamına gelir.</p>\n\n<blockquote>\n<p style=\"text-align:justify\">Diyelim ki uygulamamız i&ccedil;in spring + hibernate kullanıyoruz. Artık hibernate&#39;in SessionFactory&#39;sini kullanarak crud işlemler i&ccedil;in dao aray&uuml;z&uuml;ne ve uygulamasına ihtiyacımız var. &Ccedil;alışan sınıfı i&ccedil;in dao sınıfı yazdığınızı varsayalım daha sonra uygulamamızda başka herhangi bir varlık i&ccedil;in benzer işlem yazmamız gerekebilir. Yani burada g&ouml;rebileceğimiz &ccedil;ok sayıda ortak kod var. Şimdi Spring data jpa, repositoryleri(crudrepository, jparepository) genişleterek dao aray&uuml;zlerini tanımlamamıza izin veriyor, b&ouml;ylece &ccedil;alışma zamanında size dao uygulaması sağlıyor. Artık dao uygulaması yazmanıza gerek yok. spring data jpa bu şekilde hayatınızı kolaylaştırıyor.</p>\n</blockquote>\n\n<h2 style=\"text-align:justify\"><strong>SONU&Ccedil;</strong></h2>\n\n<p style=\"text-align:justify\">Hibernate, Java nesnelerini ilişkisel veritabanı tablolarıyla eşleyen bir JPA sağlayıcısı ve ORM&#39;dir. Spring Data JPA, JPA sağlayıcısı ile &ccedil;alışmayı daha az ayrıntılı hale getiren bir soyutlamadır. Spring Data JPA&#39;yı kullanarak Hibernate gibi bir JPA sağlayıcısının y&ouml;netiminde yer alan bir&ccedil;ok standart kodu ortadan kaldırabilirsiniz.</p>', 'hibernate-vs-spring-data-jpa', 'Hibernate vs Spring Data JPA', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Hibernate;Spring Data JPA'),
('1cb9374e-4e52-4142-a1af-30005ef4a271', '<p>Spring Boot JDBC, JPA/Hibernate, JOOQ gibi SQL tabanlı veri erişim teknolojileri ile &ccedil;alışmayı kolaylaştırır.&nbsp;DataSource, pool kabiliyeti, transactionManager, JdbcTemplate, NamedParameterJdbcTemplate gibi noktalarda otomatik konfig&uuml;rasyon sağlar. Aktive etmek i&ccedil;in jdbc veya data-jpa starter&#39;ına ihtiya&ccedil; vardır</p>\n\n<pre>\n<code class=\"language-bash\">&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n\n<h3><strong>DataSource Konfig&uuml;rasyonu</strong></h3>\n\n<p>Spring Boot veritabanı bağlantılarını y&ouml;netmek i&ccedil;in javax.sql.DataSource tipinde bir bean&#39;ı otomatik olarak tanımlamaktadır Veritabanı bağlantı ayarları dataSource bean&#39;ine &ouml;zel property&#39;ler ile yapılır</p>\n\n<pre>\n<code class=\"language-bash\">spring.datasource.url=jdbc:h2:tcp://localhost/~/test\nspring.datasource.username=sa\nspring.datasource.password=\nspring.datasource.driver-class-name=org.h2.Driver</code></pre>\n\n<h3><strong>Embedded DB Desteği</strong></h3>\n\n<p>Geliştirme s&uuml;recinde veriyi hafızada tutarak &ccedil;alışan g&ouml;m&uuml;l&uuml; veritabanları ile &ccedil;alışmak daha pratik olmaktadır. Veri kalıcı olarak kadedilmediği i&ccedil;in uygulama her başladığında populate edilmekte, uygulama sonlandığında da kaybedilmektedir. Spring Boot H2, HSQL, Derby g&ouml;m&uuml;l&uuml; veritabanları ile &ccedil;alışmayı destekler.&nbsp;G&ouml;m&uuml;l&uuml; veritabanı konfig&uuml;rasyonunun otomatik olarak ger&ccedil;ekleşebilmesi i&ccedil;in hem g&ouml;m&uuml;l&uuml; veritabanı k&uuml;t&uuml;phanesine, hem de jdbc veya data-jpa starter&#39;larından birisine ihtiya&ccedil; vardır.</p>\n\n<pre>\n<code class=\"language-bash\">&lt;dependencies&gt;\n	&lt;dependency&gt;\n		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n		&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n	&lt;/dependency&gt;\n	&lt;dependency&gt;\n		&lt;groupId&gt;com.h2database&lt;/groupId&gt;\n		&lt;artifactId&gt;h2&lt;/artifactId&gt;\n		&lt;scope&gt;runtime&lt;/scope&gt;\n	&lt;/dependency&gt;\n&lt;/dependencies&gt;</code></pre>\n\n<h3><strong>H2 Web Console</strong></h3>\n\n<p>Spring Boot, H2&#39;nin web console&#39;unu otomatik olarak devreye sokar. Bunun i&ccedil;in;</p>\n\n<ul>\n	<li>Geliştirilen uygulamanın web tabanlı olması,</li>\n	<li>H2&#39;nin classpath&#39;de olması,</li>\n	<li>Spring Boot Dev Tools&#39;un kullanılması</li>\n	<li>Dev Tools kullanılmasa da H2 console devreye alınabilir.\n	<ul>\n		<li>\n		<pre>\n<code class=\"language-bash\">spring.h2.console.enabled=true</code></pre>\n		</li>\n	</ul>\n	</li>\n	<li>Default path&#39;i /h2-console&#39;dur, değiştirilebilir.\n	<ul>\n		<li>\n		<pre>\n<code class=\"language-bash\">spring.h2.console.path=/h2-console</code></pre>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<h3><strong>Connection Pool Kabiliyeti</strong></h3>\n\n<p>Spring Boot &uuml;retim ortamları i&ccedil;in &ldquo;pooling&rdquo; kabiliyeti de sağlamaktadır. Default olarak HikariCP tercih edilir. İkinci olarak classpath&#39;de Tomcat-Jdbc&#39;ye<br />\nbakılır. &Uuml;&ccedil;&uuml;nc&uuml; olarak Commons DBCP aranır. Son olarak da Commons DBCP2 tercih edilir.</p>\n\n<p>İstenirse bu algortima uygulamaya g&ouml;re &ouml;zelleştirilebilir.</p>\n\n<ul>\n	<li>\n	<pre>\n<code class=\"language-bash\">spring.datasource.type=com.zaxxer.hikari.HikariDataSource</code></pre>\n	</li>\n</ul>\n\n<p>Her bir pooling algoritmasının kendine ait property&#39;leri de mevcuttur.</p>\n\n<ul>\n	<li>\n	<pre>\n<code class=\"language-bash\">spring.datasource.tomcat.*\nspring.datasource.hikari.*\nspring.datasource.dbcp2.*</code></pre>\n	</li>\n</ul>\n\n<h3><strong>JNDI veya Custom DataSource</strong></h3>\n\n<p>Spring Boot uygulaması bir uygulama sunucusuna deploy edilecek ise JNDI &uuml;zerinden bu sunucudaki dataSource&#39;u da kullanması sağlanabilir</p>\n\n<pre>\n<code class=\"language-bash\">spring.datasource.jndi-name=java:comp/env/TestDB</code></pre>\n\n<p>İstenirse tamamen uygulamaya &ouml;zel bir dataSource bean tanımı da yapılabilir. Bu durumda Spring Boot dataSource ve pooling konfig&uuml;rasyonunda tamamen devre dışı kalacaktır.</p>\n\n<h3><strong>JDBC&nbsp;ile &Ccedil;alışmak</strong></h3>\n\n<ul>\n	<li>JDBC ile &ccedil;alışmak i&ccedil;in jdbc-starter&#39;ına ihtiya&ccedil; vardır.</li>\n	<li>Spring Boot <strong>JdbcTemplate</strong> ve <strong>NamedParameterJdbcTemplate</strong> bean&#39;larını otomatik olarak tanımlar.&nbsp;</li>\n</ul>\n\n<pre>\n<code class=\"language-java\">@Repository\npublic class OwnerDaoJdbcImpl implements OwnerDao {\n	@Autowired\n	private JdbcTemplate jdbcTemplate;\n	@Autowired\n	private NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n}</code></pre>\n\n<h3><strong>JPA/Hibernate ile &Ccedil;alışmak</strong></h3>\n\n<ul>\n	<li>JPA ile &ccedil;alışabilmek i&ccedil;in data-jpa starter&#39;ına ihtiya&ccedil; vardır.</li>\n	<li>Spring Boot JPA desteği Spring Data projesi &uuml;zerine kuruludur.</li>\n	<li><strong>EntityManagerFactory</strong> bean tanımı otomatik olarak yapılır.</li>\n	<li>Spring Boot doğrudan Hibernate &uuml;zerinden &ccedil;alışmayı desteklemediği i&ccedil;in SessionFactory bean tanımı mevcut değildir.</li>\n	<li>JPA/Hibernate property&#39;leri <strong>application.properties</strong> i&ccedil;erisinden uygulamaya g&ouml;re &ouml;zelleştirilebilir.\n	<ul>\n		<li>\n		<pre>\n<code class=\"language-bash\">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect\nspring.jpa.properties.hibernate.show_sql=true\nspring.jpa.properties.hibernate.format_sql=true\nspring.jpa.properties.hibernate.use_sql_comments=true\n</code></pre>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<h3><strong>JPA Auto Scan Kabiliyeti</strong></h3>\n\n<ul>\n	<li>Entity sınıflarını tespit etmek i&ccedil;in @EnableAutoConfiguration veya @SpringBootApplication anotasyonuna sahip sınıfın bulunduğu paket ve alt paketleri taranır.</li>\n	<li>Benzer bi&ccedil;imde Spring Data Repository veya CrudRepository aray&uuml;zlerinden t&uuml;reyen uygulamaya &ouml;zel aray&uuml;zler de otomatik olarak tespit edilmektedir</li>\n</ul>\n\n<h3><strong>JPA ile Otomatik Şema Y&ouml;netimi</strong></h3>\n\n<ul>\n	<li>Sadece g&ouml;m&uuml;l&uuml; veritabanı kullanımı durumunda JPA ile veritabanı otomatik olarak yaratılacaktır.</li>\n	<li>Connection tipi H2, HSQLDB, DERBY ise g&ouml;m&uuml;l&uuml; veritabanı olarak kabul edilir.</li>\n	<li>G&ouml;m&uuml;l&uuml; olmayan veritabanı kullanımında da bu &ouml;zelliği aktive etmek i&ccedil;in,\n	<ul>\n		<li>\n		<pre>\n<code class=\"language-java\">spring.jpa.hibernate.ddl-auto=create-drop</code></pre>\n		</li>\n	</ul>\n	</li>\n	<li>Bu tanım aşağıdaki tanımı her zaman ezer,\n	<ul>\n		<li>\n		<pre>\n<code class=\"language-bash\">spring.jpa.generate-ddl=true</code></pre>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<h3><strong>Open EntityManagerin View</strong></h3>\n\n<ul>\n	<li>Spring Boot Hibernate ile &ccedil;alışırken lazy hatalarının &ouml;n&uuml;ne ge&ccedil;mek i&ccedil;in default olarak OpenEntityManagerInViewInterceptor tanımlar.</li>\n	<li>İstenirse devre dışı bırakılabilir.\n	<ul>\n		<li>\n		<pre>\n<code class=\"language-bash\">spring.jpa.open-in-view=false</code></pre>\n		</li>\n	</ul>\n	</li>\n	<li>Hibernate 5.x i&ccedil;in tercih edilen y&ouml;ntemenable lazy load no trans &ouml;zelliğidir.\n	<ul>\n		<li>\n		<pre>\n<code class=\"language-apache\">spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true</code></pre>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<h3><strong>Sample Data Population</strong></h3>\n\n<ul>\n	<li>Spring Boot classpath&#39;de schema.sql ve data.sql script dosyaları mevcut ise bu dosyaların i&ccedil;indeki sql ifadelerini bootstrap sırasında &ccedil;alıştıracaktır.</li>\n	<li>Dosyaların lokasyonu veya isimleri uygulamaya g&ouml;re &ouml;zelleştirilebilir.\n	<ul>\n		<li>\n		<pre>\n<code class=\"language-bash\">spring.datasource.schema=classpath:/schema.sql\nspring.datasource.data=classpath:/data.sql</code></pre>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<h3><strong>Sample Data Population</strong></h3>\n\n<ul>\n	<li>Eğer classpath&#39;de mevcut ise <strong>schema-$ {platform}.sql </strong>ve <strong>data-${platform}.sql </strong>dosyalarındaki ifadeler de &ccedil;alıştırılacaktır.</li>\n	<li>${platform} değişkeninin değeri application.properties i&ccedil;erisindeki tanımdan &ccedil;&ouml;z&uuml;mlenir,\n	<ul>\n		<li>\n		<pre>\n<code class=\"language-bash\">spring.datasource.platform=all\n// hsqldb,h2,oracle,mysql,postgresql gibi değerler yazılabilir. Bizim belirlediğimiz bir değerde olabilir</code></pre>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<h3><strong>Sample Data Population</strong></h3>\n\n<ul>\n	<li>Hibernate&#39;de bootstrap sırasında eğer ddl-auto değeri create veya create-drop durumunda classpath&#39;de import.sql isimli bir dosya mevcut ise bu dosyadaki sql ifadelerini &ccedil;alıştırır.</li>\n</ul>\n\n<h3><strong>Veritabanı Init S&uuml;recindeki İşlemlerin Sıralaması</strong></h3>\n\n<ul>\n	<li>schema-${platform}.sql</li>\n	<li>schema.sql</li>\n	<li>data-${platform}.sql</li>\n	<li>data.sql</li>\n	<li>ddl-auto değerine g&ouml;re schema değişiklikleri</li>\n	<li>ddl-auto değeri create|create-drop ise import.sql</li>\n</ul>\n\n<h3><strong>Data Initialization&rsquo;ın Devre Dışı Bırakılması</strong></h3>\n\n<p>İstenirse veritabanı initialization işlemi devre dışı bırakılabilir,&nbsp;</p>\n\n<pre>\n<code class=\"language-apache\">spring.datasource.initialization-mode=never\n// Alabileceği değerler: always, embedded, never</code></pre>\n\n<h3><strong>DB Migration Desteği</strong></h3>\n\n<ul>\n	<li>Schema.sql ve data.sql ile veritabanında incremental değişiklikler yaparak ilerlemek m&uuml;mk&uuml;n değildir.</li>\n	<li>Spring Boot gelişmiş DB migration ihtiya&ccedil;ları i&ccedil;in flyway ve liquibase ara&ccedil;larını desteklemektedir.</li>\n	<li>Flyway doğrudan SQL ifadeleri &uuml;zerinden &ccedil;alışır.</li>\n	<li>Liquibase ise kendine ait vendor bağımsız bir DSL&rsquo;e sahiptir</li>\n	<li>Devreye almak i&ccedil;in ilgili k&uuml;t&uuml;phaneleri pom.xml&rsquo;e eklemek yeterlidir.\n	<ul>\n		<li>\n		<pre>\n<code class=\"language-bash\">&lt;dependency&gt;\n	&lt;groupId&gt;org.flywaydb&lt;/groupId&gt;\n	&lt;artifactId&gt;flyway-core&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n	&lt;groupId&gt;org.liquibase&lt;/groupId&gt;\n	&lt;artifactId&gt;liquibase-core&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<h3><strong>Flyway</strong></h3>\n\n<ul>\n	<li>Flyway migration SQL dosyaları classpath&rsquo;de db/migration dizini altına yer almalıdır.</li>\n	<li>Dosyaların formatı V&lt;version&gt;__&lt;desc&gt;.sql şeklinde olmalıdır.\n	<ul>\n		<li>V1__schema.sql</li>\n		<li>V2__data.sql</li>\n		<li>...</li>\n	</ul>\n	</li>\n	<li>Migration işlemleri ile ilgili takip DB&rsquo;de flyway_schema_history isimli tablo i&ccedil;erisinde ger&ccedil;ekleştirilir.</li>\n</ul>\n\n<h3><strong>Liquibase</strong></h3>\n\n<p>classpath:/db/changelog/db.changelog-master.yaml</p>\n\n<pre>\n<code class=\"language-bash\">databaseChangeLog:\n	- changeSet:\n		id: 1\n		db:\n			- createTable:\n				tableName: person\n				columns:\n					- column:\n						name: id\n						type: int\n						constraints:\n						primaryKey: true\n						nullable: false\n					- column:\n						name: first_name\n						type: varchar(255)\n	- changeSet:\n		id: 2\n		db:\n			- addColumn:\n				tableName: person\n				columns:\n					- column:\n						name: last_name\n						type: varchar(255)</code></pre>\n\n<p>&nbsp;</p>', 'spring-boot-ve-veritabani-islemleri', 'Spring Boot ve Veritabanı İşlemleri', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'JDBC;JPA;Hibernate'),
('1cb9374e-4e52-4142-a1af-30006ef4a271', '<p>Spring Security kabiliyetlerini devreye almak i&ccedil;in &ouml;ncelikle security starter&#39;ı tanımlı olmalıdır.</p>\n\n<pre>\n<code class=\"language-apache\">&lt;dependency&gt;\n	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n	&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n<ul>\n	<li>Default olarak b&uuml;t&uuml;n HTTP endpoint&#39;leri g&uuml;venlik altına alınmıştır.</li>\n	<li>Default olarak password&#39;&uuml; rastgele belirlenmiş ve lNFO log d&uuml;zeyinde console&#39;a yazılan user isimli bir kullanıcı mevcuttur.</li>\n	<li>Bu kullanıcı adını ve password&#39;&uuml; ve rollerini application.properties&#39;den değiştirmek m&uuml;mk&uuml;nd&uuml;r.\n	<ul>\n		<li>\n		<pre>\n<code class=\"language-bash\">security.user.name=user\nsecurity.user.password=secret\nsecurity.user.role=USER,ACTUATOR</code></pre>\n		</li>\n	</ul>\n	</li>\n	<li>HSTS, XSS, CSRF gibi &ouml;zellikler devreye alınmıştır.</li>\n	<li>Default olarak aşağıdaki statik web resource path&#39;leri public resource (unsecure) olarak erişilmektedir.\n	<ul>\n		<li>/css/**</li>\n		<li>/js/**</li>\n		<li>/images/**</li>\n		<li>/webjars/**</li>\n		<li>**/favicon.ico</li>\n	</ul>\n	</li>\n</ul>\n\n<h3><strong>Default Security Konfig&uuml;rasyonu</strong></h3>\n\n<ul>\n	<li>Default web app security konfig&uuml;rasyonunu &ouml;zelleşitirmek i&ccedil;in <strong>WebSecurityConfigurerAdapter</strong> sınıfından t&uuml;reyen bir konfig&uuml;rasyon sınıfı yazılmalıdır.</li>\n	<li>Default konfig&uuml;rasyonu tamamen devre dışı bırakmak i&ccedil;in <strong>@EnableWebSecurity</strong> eklenmelidir.</li>\n</ul>\n\n<pre>\n<code class=\"language-java\">@Configuration\n@EnableWebSecurity\npublic class PetClinicSecurityConfig extends WebSecurityConfigurerAdapter {\n...\n}</code></pre>\n\n<h3><strong>Form Tabanlı Login- Overview</strong></h3>\n\n<pre>\n<code class=\"language-java\">// http://localhost:8080/login.html\n@Controller\npublic class LoginFormController {\n	@RequestMapping(value=\"/login.html\", method=RequestMethod.GET)\n	public ModelAndView loginPage() {\n		ModelAndView mav = new ModelAndView();\n		mav.setViewName(\"login\");\n		return mav;\n	}\n}\n// application.properties içerisinde\n// spring.mvc.view.prefix=/WEB-INF/jsp/\n// spring.mvc.view.suffix=.jsp</code></pre>\n\n<pre>\n<code class=\"language-html\">// /WEB-INF/jsp/login.jsp\n&lt;html&gt;\n	&lt;body&gt;\n		&lt;form action=\"login\" method=\"post\"&gt;\n			Username:&lt;input name=\"username\" type=\"text\" /&gt; &lt;br/&gt;\n			Password:&lt;input name=\"password\" type=\"password\" /&gt; &lt;br/&gt;\n			&lt;input type=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\"/&gt;\n			&lt;input type=\"submit\" value=\"Login\"/&gt;\n		&lt;/form&gt;\n	&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n\n<h3><strong>Logout</strong></h3>\n\n<ul>\n	<li>Spring Security&rsquo;nin default ayarlarında logout ve CSRF kabiliyetleri aktiftir.</li>\n	<li>Default logout URI&rsquo;ı /logout şeklindedir.</li>\n	<li>Ancak CSRF, /logout URI&rsquo;ına HTTP GET ile erişime izin vermez.</li>\n	<li>Dolayısı ile logout işlemi i&ccedil;in bir HTML form kullanmak ve POST metodu ile web isteği g&ouml;ndermek gerekecektir.</li>\n</ul>\n\n<pre>\n<code class=\"language-html\">&lt;html&gt;\n	&lt;body&gt;\n		...\n		&lt;form action=\"logout\" method=\"post\"&gt;\n			&lt;input type=\"submit\" value=\"Logout\"&gt;\n			&lt;input type=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\"&gt;\n		&lt;/form&gt;\n	&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n\n<h3><strong>Beni Hatırla</strong></h3>\n\n<pre>\n<code class=\"language-html\">&lt;html&gt;\n	&lt;body&gt;\n		...\n		&lt;form action=\"login\" method=\"post\"&gt;\n			Username:&lt;input name=\"username\" type=\"text\" /&gt; &lt;br/&gt;\n			Password:&lt;input name=\"password\" type=\"password\" /&gt; &lt;br/&gt;\n			Remember Me:&lt;input name=\"remember-me\" type=\"checkbox\"&gt; &lt;br/&gt;\n			&lt;inputtype=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\"/&gt;\n			&lt;input type=\"submit\" value=\"Login\"/&gt;\n		&lt;/form&gt;\n	&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n\n<pre>\n<code class=\"language-java\">@Configuration\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter{\n	@Autowired\n	private UserDetailsService userDetailsService;\n	@Override\n	protected void configure(HttpSecurity http) throws Exception {\n		...\n		http.rememberMe().userDetailsService(userDetailsService);\n	}\n}</code></pre>\n\n<h3><strong>HTTP Basic Auth</strong></h3>\n\n<pre>\n<code class=\"language-java\">@Configuration\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter {\n	@Override\n	protected void configure(HttpSecurity http) throws Exception {\n		...\n		http.httpBasic();\n	}\n}</code></pre>\n\n<h3><strong>H2 Console&rsquo;a Erişim</strong></h3>\n\n<p>H2 Console&rsquo;un kendine ait bir authentication mekanizması olduğu i&ccedil;in spring security&rsquo;nin dışında bırakılması gerekir</p>\n\n<pre>\n<code class=\"language-java\">@Configuration\n@Order(value=0)\npublic class H2SecurityConfigurationextends WebSecurityConfigurerAdapter {\n	@Override\n	protected void configure(HttpSecurity http) throws Exception {\n		http.antMatcher(\"/h2-console/**\");\n		http.authorizeRequests().anyRequest().permitAll();\n		http.csrf().disable();\n		http.headers().frameOptions().disable();\n	}\n}</code></pre>\n\n<h3><strong>Web Kaynaklarının Yetkilendirilmesi</strong></h3>\n\n<pre>\n<code class=\"language-java\">@Configuration\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter {\n	@Override\n	protected void configure(HttpSecurity http) throws Exception {\n		http.authorizeRequests()\n			.antMatchers( \"/**/favicon.ico\", \"/css/**\", \"js/**\", \"/images/**\", \"/webjars/**\", \"/login.html\").permitAll()\n			.antMatchers(\"/rest/**\").access(\"hasRole(\'EDITOR\')\")\n			.antMatchers(\"/actuator/**\").access(\"hasRole(\'ADMIN\')\")\n			.anyRequest().authenticated();\n	}\n}</code></pre>\n\n<h3><strong>Metot D&uuml;zeyinde Yetkilendirme</strong></h3>\n\n<p>Metot d&uuml;zeyinde yetkilendirmeyi devreye almak i&ccedil;in <strong>@EnableGlobalMethodSecurity</strong> anotasyonuna sahip bir konfig&uuml;rasyon sınıfı olmalıdır</p>\n\n<pre>\n<code class=\"language-java\">@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)\npublic class PetClinicSecurityConfiguration {\n	...\n}</code></pre>\n\n<pre>\n<code class=\"language-java\">@Service\npublic class PetClinicServiceImpl implements PetClinicService{\n	@PreAuthorize(\"hasAnyRole(\'ROLE_USER\',\'ROLE_EDITOR\')\")\n	public List&lt;Owner&gt; findOwners() {\n		return ownerRepository.findAll();\n	}\n	@PreAuthorize(\"hasRole(\'ROLE_EDITOR\') and hasIpAddress(192.168.1.0/24)\")\n	public void createOwner(Owner owner) {\n		ownerRepository.create(owner);\n	}\n	...\n}</code></pre>\n\n<h3><strong>Kullanıcı Bilgilerinin Veritabanından Alınması</strong></h3>\n\n<pre>\n<code class=\"language-java\">@Configuration\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter{\n	...\n	@Autowired\n	private DataSource dataSource;\n\n	@Override\n	protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n		auth.jdbcAuthentication().dataSource(dataSource);\n        // auth.jdbcAuthentication()\n        // .usersByUsernameQuery(usersByUsernameQuery)\n        // .authoritiesByUsernameQuery(authoritiesByUsernameQuery)\n        // .groupAuthoritiesByUsername(groupAuthoritiesByUsername)...\n	}\n}</code></pre>\n\n<h3><strong>Kriptolu Şifre Kullanımı</strong></h3>\n\n<ul>\n	<li>Spring Security şifrelerin DB&#39;de kriptolu olarak saklanmasını sağlar.</li>\n	<li>Şifreleri kriptolamak i&ccedil;in değişik algoritmalar kullanılabilir.\n	<ul>\n		<li>bcrypt, pbkdf2, scrypt, md4, sha...</li>\n	</ul>\n	</li>\n	<li>Bunların hepsi tek y&ouml;nl&uuml; algoritmalardır.</li>\n	<li>Kimliklendirme sırasında kullanıcının girdiği şifre algoritmaya g&ouml;re kriptolanarak DB&#39;deki kriptolu değer ile karşılaştırılır.</li>\n</ul>\n\n<h3><strong>Oturum Y&ouml;netimi</strong></h3>\n\n<ul>\n	<li>Tomcat Web Container&rsquo;ın session timeout değeri default 30 dk&rsquo;dır.</li>\n	<li>Application.properties i&ccedil;erisinden değiştirilebilir.\n	<ul>\n		<li>\n		<pre>\n<code class=\"language-bash\">server.session.timeout=60</code></pre>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<pre>\n<code class=\"language-java\">@Configuration\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter {\n	@Override\n	protected void configure(HttpSecurity http) throws Exception {\n		...\n	}\n	http.sessionManagement()\n		.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)\n		.maximumSessions(1)\n		.maxSessionsPreventsLogin(false)\n		.expiredUrl(\"/login\");\n\n	@Bean\n	public ServletListenerRegistrationBean&lt;HttpSessionEventPublisher&gt;\n	httpSessionEventPublisher() {\n		return new ServletListenerRegistrationBean&lt;HttpSessionEventPublisher&gt;(new HttpSessionEventPublisher());\n	}\n}</code></pre>', 'spring-boot-ve-guvenlik', 'Spring Boot ve Güvenlik', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'security'),
('1cb9374e-4e52-4142-a1af-30007ef4a271', '<p><a href=\"https://www.testcontainers.org/\" target=\"_blank\">Testcontainers</a>, Docker konteynerlerini JUnit testlerine kolaylıkla entegre etmeye izin veren bir Java k&uuml;t&uuml;phanesidir.</p>\n\n<h2>Bağımlılıklar</h2>\n\n<p>Testcontainers&#39;ı kullanmak i&ccedil;in aşağıdaki bağımlılıkları <code>pom.xml</code>&#39;e eklenmeli (Maven tabanlı proje varsayılarak):</p>\n\n<pre>\n<code class=\"language-bash\">&lt;properties&gt;\n    &lt;org.testcontainers.version&gt;1.12.5&lt;/org.testcontainers.version&gt;\n&lt;/properties&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;\n    &lt;artifactId&gt;testcontainers&lt;/artifactId&gt;\n    &lt;version&gt;${org.testcontainers.version}&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;\n    &lt;artifactId&gt;VERİTABANI&lt;/artifactId&gt;\n    &lt;version&gt;${org.testcontainers.version}&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre>\n\n<p>VERİTABANI, postgresql, mysql, mariadb&#39;den biridir.</p>\n\n<blockquote>\n<p>Not: Testcontainers, JUnit 5 (Jupiter) eklentisi sağlar, ancak bu eklentide sunulan senaryoda gerekli olmayacaktır.</p>\n</blockquote>\n\n<h2>Veri Kaynağı Yapılandırması</h2>\n\n<p>Spring Boot testleri i&ccedil;in Testcontainers&#39;ı yapılandırma adımları:</p>\n\n<ul>\n	<li>Driver&#39;ı Testcontainers JDBC proxy s&uuml;r&uuml;c&uuml;s&uuml; olan <code>org.testcontainers.jdbc.ContainerDatabaseDriver</code> olarak ayarlanmalı. Bunun amacı veri kaynağı başlatıldığında gerekli Docker konteynerini başlatmaktan sorumlu olacaktır.</li>\n	<li>Veritabanınız i&ccedil;in diyalekti&nbsp;a&ccedil;ık&ccedil;a ayarlanmalı&nbsp;aksi takdirde uygulamayı başlatırken hata alırız. Uygulamada <em>JPA</em> kullandığınızda bu adım gereklidir.(<em>Spring Data JPA&nbsp;</em>aracılığıyla)</li>\n	<li>JDBC URL&#39;sini <code>jdbc:tc:&lt;database-image&gt;:&lt;version&gt;:///</code> olarak ayarlanmalı&nbsp;b&ouml;ylece Testcontainers hangi veritabanı g&ouml;r&uuml;nt&uuml;s&uuml;n&uuml; kullanacağını bilir.</li>\n</ul>\n\n<h3>PostgreSQL yapılandırması:</h3>\n\n<pre>\n<code class=\"language-apache\">spring.datasource.driver-class-name=org.testcontainers.jdbc.ContainerDatabaseDriver\nspring.datasource.url=jdbc:tc:postgresql:9.6:///\nspring.jpa.database-platform=org.hibernate.dialect.PostgreSQL9Dialect\n</code></pre>\n\n<h3>MySQL yapılandırması:</h3>\n\n<pre>\n<code class=\"language-bash\">spring.datasource.driver-class-name=org.testcontainers.jdbc.ContainerDatabaseDriver\nspring.datasource.url=jdbc:tc:mysql:8:///\nspring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect\n</code></pre>\n\n<h3>MariaDB yapılandırması:</h3>\n\n<pre>\n<code class=\"language-bash\">spring.datasource.driver-class-name=org.testcontainers.jdbc.ContainerDatabaseDriver\nspring.datasource.url=jdbc:tc:mariadb:10.3:///\nspring.jpa.database-platform=org.hibernate.dialect.MariaDB103Dialect\n</code></pre>\n\n<blockquote>\n<p>Veritabanı yapılandırması hakkında daha fazla bilgiyi şu adresteki resmi belgelerde bulunabilir: <a href=\"https://www.testcontainers.org/modules/databases/\" target=\"_blank\">https://www.testcontainers.org/modules/databases/</a></p>\n</blockquote>\n\n<h2>Test veritabanını Testcontainers ile&nbsp;başlatma</h2>\n\n<p>Veritabanını Testcontainers tarafından y&uuml;klenen komut dosyasıyla başlatabilirsiniz. Dosya, doğrudan sınıf yolundan veya herhangi bir konumdan y&uuml;klenebilir. Yapılacak tek şey, JDBC URL&#39;sini değiştirmektir:</p>\n\n<pre>\n<code class=\"language-bash\">spring.datasource.url=jdbc:tc:postgresql:9.6:///?TC_INITSCRIPT=file:src/main/resources/init_db.sql</code></pre>\n\n<p>yada</p>\n\n<pre>\n<code class=\"language-bash\">spring.datasource.url=jdbc:tc:postgresql:9.6:///?TC_INITSCRIPT=classpath:init_db.sql\n</code></pre>\n\n<h2>@DataJpaTest</h2>\n\n<p>TC&#39;yi <code>@DataJpaTest</code>&#39;te kullanmak i&ccedil;in, uygulama tanımlı (otomatik yapılandırılmış) veri kaynağının kullanıldığından emin olmanız gerekir. Testinize, aşağıda g&ouml;sterildiği gibi <code>@AutoConfigureTestDatabase</code>&nbsp;ile a&ccedil;ıklama ekleyerek bunu kolayca yapabilirsiniz:</p>\n\n<pre>\n<code class=\"language-java\">@DataJpaTest\n@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)\npublic class OwnerRepositoryTests {\n\n    @Autowired\n    private OwnerRepository ownerRepository;\n\n    @Test\n    void findAllReturnsJohnDoe() { // as defined in tc-initscript.sql\n        var owners = ownerRepository.findAll();\n        assertThat(owners.size()).isOne();\n        assertThat(owners.get(0).getFirstName()).isEqualTo(\"John\");\n        assertThat(owners.get(0).getLastName()).isEqualTo(\"Doe\");\n    }\n}</code></pre>\n\n<h2>@SpringBootTest</h2>\n\n<p><code>@SpringBootTest</code>, uygulama tanımlı veri kaynağını kullanır, bu nedenle ek değişiklik gerekmez.</p>\n\n<pre>\n<code class=\"language-java\">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@AutoConfigureMockMvc\npublic class OwnerResourceTests {\n\n    @Autowired\n    WebApplicationContext wac;\n\n    @Test\n    void findAllReturnsJohnDoe() throws Exception {\n        given().webAppContextSetup(wac)\n        .when().get(\"/owners\")\n        .then().status(HttpStatus.OK)\n               .body(\"_embedded.owners.firstName\", containsInAnyOrder(\"John\"),\n                     \"_embedded.owners.lastName\", containsInAnyOrder(\"Doe\"));\n    }\n}</code></pre>', 'testcontainers-postgresql-mysql-mariadb', 'Testcontainers / PostgreSQL, MySQL, MariaDB', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Testcontainers;PostgreSQL;MySQL;MariaDB'),
('1cb9374e-4e52-4142-a1af-30008ef4a271', '<p>Testcontainer, verilen Docker Image bilgilerine g&ouml;re ortamda Docker container ayağa kaldırıp testlerimize başlamamıza olanak sağlayan bir k&uuml;t&uuml;phanedir. İ&ccedil;eriğinde DB, Couchbase, InfluxDB, Elasticsearch, Kafka vb. farklı bileşenlerin testleri i&ccedil;in &ouml;nceden hazırlanmış ve hale eklenmeye devam eden componentler barındırmakla birlikte docker image name ve version vererek de kendimiz container ayağa kaldırabiliyoruz.</p>\n\n<p>Başlıca eklememiz gereken k&uuml;t&uuml;phaneler ancak ihtia&ccedil; halinde&nbsp;powermock,&nbsp;jupiter veya junit kullanılabilir.</p>\n\n<pre>\n<code class=\"language-bash\">&lt;dependency&gt;\n	&lt;groupId&gt;com.github.stefanbirkner&lt;/groupId&gt;\n	&lt;artifactId&gt;system-rules&lt;/artifactId&gt;\n	&lt;version&gt;1.17.2&lt;/version&gt;\n	&lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n	&lt;groupId&gt;org.testcontainers&lt;/groupId&gt;\n	&lt;artifactId&gt;testcontainers&lt;/artifactId&gt;\n	&lt;version&gt;1.11.0&lt;/version&gt;\n	&lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>İlk &ouml;nce testlerimizde configurasyon yapacağımız custom bir annotation oluşturalım ve inceleyelim,</p>\n\n<pre>\n<code class=\"language-java\">@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@ActiveProfiles(value = {\"integration-test\"})\n@ContextConfiguration(\n    initializers = {RabbitMqAwareInitializer.class, RedisContainerConfig.class},\n    classes = IntegrationTestConfig.class\n)\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest(webEnvironment = WebEnvironment.MOCK)\n@AutoConfigureMockMvc\npublic @interface SpringBootTestConfig {}</code></pre>\n\n<hr />\n<p><code>@Target</code>: Annotation kullanım aralığını ayarlar ve ElementType&#39;a g&ouml;re a&ccedil;ıklama kullanılabilir aralığının numaralandırma k&uuml;mesini belirtir.</p>\n\n<p><code>ElementType.ANNOTATION_TYPE</code>, annotation&#39;ın @interface tarafından yazıldığını, aksi takdirde bir hata bildirildiğini belirtir. Benzer şekilde, yaygın olarak kullanılan <code>ElementType.METHOD</code>, a&ccedil;ıklamanın metod olduğu anlamına gelir, aksi takdirde bir hata bildirilir.</p>\n\n<p>ElementType kullanımı;</p>\n\n<table border=\"1\">\n	<tbody>\n		<tr>\n			<td>Tip</td>\n			<td>Annotation scope</td>\n		</tr>\n		<tr>\n			<td>TYPE</td>\n			<td>Sınıf, interface veya enum bildirimi</td>\n		</tr>\n		<tr>\n			<td>FIELD</td>\n			<td>Alan bildirimleri ve enum sabitleri</td>\n		</tr>\n		<tr>\n			<td>METHOD</td>\n			<td>method</td>\n		</tr>\n		<tr>\n			<td>PARAMETER</td>\n			<td>parametre</td>\n		</tr>\n		<tr>\n			<td>CONSTRUCTOR</td>\n			<td>Construction metod</td>\n		</tr>\n		<tr>\n			<td>LOCAL_VARIABLE</td>\n			<td>Local değişken</td>\n		</tr>\n		<tr>\n			<td>ANNOTATION_TYPE</td>\n			<td>Annotation tipi (@interface tarafından değiştirilen t&uuml;r)</td>\n		</tr>\n		<tr>\n			<td>PACKAGE</td>\n			<td>Kurulum paketi beyanı</td>\n		</tr>\n		<tr>\n			<td>TYPE_PARAMETER</td>\n			<td>Tip parametresi bildirimi</td>\n		</tr>\n		<tr>\n			<td>TYPE_USE</td>\n			<td>Tek tip kullan</td>\n		</tr>\n	</tbody>\n</table>\n\n<hr />\n<p><code>@Retention</code>, RetentionPolicy enum t&uuml;r&uuml;n&uuml;n sabitiyle birlikte, yorumun ne kadar s&uuml;reyle tutulması gerektiğini belirtir.&nbsp;&nbsp;<code>RetentionPolicy</code> yorumları tutmak i&ccedil;in &ccedil;eşitli stratejileri a&ccedil;ıklar.</p>\n\n<table border=\"1\">\n	<tbody>\n		<tr>\n			<td>&nbsp;</td>\n			<td>A&ccedil;ıklama</td>\n		</tr>\n		<tr>\n			<td>SOURCE</td>\n			<td>Derleyici yorumu drop eder.</td>\n		</tr>\n		<tr>\n			<td>CLASS</td>\n			<td>Derleyici dosyada g&uuml;nl&uuml;ğe kaydedilir ve varsayılan &ccedil;alışma zamanı sanal makine saklaması gerektirmez.</td>\n		</tr>\n		<tr>\n			<td>RUNTIME</td>\n			<td>Derleyici bir dosyaya kaydedilir ve kolay okuma i&ccedil;in sanal makine &ccedil;alışma zamanı tarafından tutulur.</td>\n		</tr>\n	</tbody>\n</table>\n\n<hr />\n<p><code>@ActiveProfiles</code>; Spring integration testinde <code>ApplicationContext</code>&#39;i y&uuml;klerken profilleri etkinleştirmek i&ccedil;in kullanılan sınıf d&uuml;zeyinde bir a&ccedil;ıklamadır. Aşağıdaki &ouml;zellikleri vardır.</p>\n\n<ul>\n	<li><strong>profiles</strong>: Etkinleştirilecek profilleri belirtir.</li>\n	<li><strong>resolver</strong>: Profilleri programlı olarak etkinleştirmek i&ccedil;in <code>ActiveProfilesResolver</code>&#39;ı belirtir.</li>\n	<li><strong>value</strong>: <code>profiles</code> &ouml;ğesinin takma adıdır</li>\n	<li><strong>inheritProfiles</strong>: Etkin profillerin &uuml;st sınıftan devralınıp devralınmayacağına karar veren Boolean değeridir. Varsayılan değeri true.</li>\n</ul>\n\n<hr />\n<p><code>@ContextConfiguration</code>:</p>\n\n<p>Spring entegrasyonu testi i&ccedil;in bir <code>ApplicationContext</code> y&uuml;kler. <code>ApplicationContext</code>&#39;i XML kaynağı veya <code>@Configuration</code> ile a&ccedil;ıklamalı JavaConfig kullanarak y&uuml;kleyebilir. Ayrıca <code>@Component</code>,&nbsp;<code>@Service</code>,&nbsp;<code>@Repository</code> vb. ile a&ccedil;ıklamalı bir bileşenleri y&uuml;kleyebilir. Ayrıca <code>javax.inject</code> ile anootated edilmiş sınıfları da y&uuml;kleyebiliriz. Aşağıdaki &ouml;ğelere sahiptir.</p>\n\n<ul>\n	<li><strong>classes</strong>: <code>@Configuration</code> ile tanımlanmış&nbsp;sınıflar, <code>ApplicationContext</code>&#39;i y&uuml;klemek i&ccedil;in atanır.</li>\n	<li><strong>inheritInitializers</strong>: Test &uuml;st sınıflarından bağlam başlatıcıların devralınıp devralınmayacağına karar veren bir Boolean değeri. Varsayılan true</li>\n	<li><strong>inheritLocations</strong>: Test &uuml;st sınıflarından resource konumlarının veya annotate edilmiş&nbsp;sınıfların devralınıp devralınmayacağına karar veren Boolean değeri. Varsayılan true</li>\n	<li><strong>initializers</strong>: <code>ConfigurableApplicationContext</code>&#39;i başlatan uygulama bağlamı başlatıcı sınıflarını belirtiriz.</li>\n	<li><strong>loader</strong>: <code>ApplicationContext</code>&#39;i y&uuml;klemek i&ccedil;in <code>ContextLoader</code> veya <code>SmartContextLoader</code> sınıfımızı belirtiyoruz.</li>\n	<li><strong>locations</strong>: <code>ApplicationContext</code>&#39;i y&uuml;klemek i&ccedil;in resource konumlarını belirtiriz.</li>\n	<li><strong>name</strong>: Bu konfig&uuml;rasyon tarafından temsil edilen bağlam hiyerarşi seviyesinin adıdır.</li>\n	<li><strong>value</strong>: <code>locations</code> &ouml;ğesinin diğer adıdır.</li>\n</ul>\n\n<p>Bizim &ouml;rneğimizde&nbsp;<code>RabbitMqAwareInitializer</code> ve&nbsp;<code>RedisContainerConfig</code> isminde 2 adet başlatıcımız bulunmaktadır. Ayrıca runtime&#39;da&nbsp; loadTimeWeaver bean&#39;i inject etmek i&ccedil;in gerekli sınıflarımız var.</p>\n\n<p><code>RabbitMqAwareInitializer</code></p>\n\n<pre>\n<code class=\"language-java\">import com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport org.junit.Rule;\nimport org.junit.contrib.java.lang.system.EnvironmentVariables;\nimport org.springframework.boot.test.context.TestConfiguration;\nimport org.springframework.context.ApplicationContextInitializer;\nimport org.springframework.context.ConfigurableApplicationContext;\nimport org.testcontainers.containers.GenericContainer;\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\nimport static org.junit.Assert.assertNotNull;\n\n@TestConfiguration public class RabbitMqAwareInitializer\n    implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {\n    public static Channel rabbitmq;\n    public static int rabbitmqPort = 5672;\n    public static int rabbitmqManagementPort = 15672;\n\n    public static final GenericContainer&lt;?&gt; rabbitmqContainer;\n    @Rule public static EnvironmentVariables env = new EnvironmentVariables();\n\n    static {\n        rabbitmqContainer = new GenericContainer&lt;&gt;(\"rabbitmq:3.7-management\");\n        rabbitmqContainer.withExposedPorts(rabbitmqPort);\n        rabbitmqContainer.withExposedPorts(rabbitmqManagementPort);\n        rabbitmqContainer.start();\n        env.set(\"RABBIT_HOST\", rabbitmqContainer.getContainerIpAddress());\n        env.set(\"RABBIT_PORT\", String.valueOf(rabbitmqContainer.getMappedPort(rabbitmqPort)));\n        env.set(\"RABBIT_MANAGEMENT_PORT\", String.valueOf(rabbitmqContainer.getMappedPort(rabbitmqManagementPort)));\n        env.set(\"RABBIT_USERNAME\", \"guest\");\n        env.set(\"RABBIT_PASSWD\", \"guest\");\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost(System.getenv(\"RABBIT_HOST\"));\n        factory.setPort(Integer.parseInt(System.getenv(\"RABBIT_PORT\")));\n        factory.setUsername(System.getenv(\"RABBIT_USERNAME\"));\n        factory.setPassword(System.getenv(\"RABBIT_PASSWD\"));\n        try {\n            Connection connection = factory.newConnection();\n            rabbitmq = connection.createChannel();\n        } catch (IOException | TimeoutException e) {\n            e.printStackTrace();\n        }\n        assertNotNull(rabbitmq);\n    }\n    @Override\n    public void initialize(ConfigurableApplicationContext configurableApplicationContext){}\n}</code></pre>\n\n<p><code>RedisContainerConfig</code></p>\n\n<pre>\n<code class=\"language-java\">import org.junit.Rule;\nimport org.junit.contrib.java.lang.system.EnvironmentVariables;\nimport org.springframework.boot.test.context.TestConfiguration;\nimport org.springframework.context.ApplicationContextInitializer;\nimport org.springframework.context.ConfigurableApplicationContext;\nimport org.testcontainers.containers.GenericContainer;\nimport redis.clients.jedis.Jedis;\nimport java.util.HashMap;\nimport java.util.Map;\nimport static org.junit.Assert.assertNotNull;\n\n@TestConfiguration public class RedisContainerConfig\n    implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {\n\n    public static Jedis jedis;\n\n    public static int redisPort = 6379;\n\n    public static final GenericContainer&lt;?&gt; redisContainer;\n\n    @Rule public static EnvironmentVariables env = new EnvironmentVariables();\n\n    static {\n        //Configure containers\n        redisContainer = new GenericContainer&lt;&gt;(\"redis:5.0.4\");\n        redisContainer.withExposedPorts(redisPort);\n        redisContainer.start();\n\n        // Configure desired environment variables\n        env.set(\"REDIS_HOST\", redisContainer.getContainerIpAddress());\n        env.set(\"REDIS_PORT\", String.valueOf(redisContainer.getFirstMappedPort()));\n\n        // Configure clients to interact with the containers\n        jedis =\n            new Jedis(System.getenv(\"REDIS_HOST\"), Integer.parseInt(System.getenv(\"REDIS_PORT\")));\n        assertNotNull(jedis);\n    }\n\n    public static void addRedis(String key, Map&lt;String, String&gt; hash) {\n        jedis.hmset(\"key\", \"value\");\n    }\n\n    @Override public void initialize(ConfigurableApplicationContext applicationContext) {}\n}</code></pre>\n\n<p><code>@IntegrationTestConfig</code></p>\n\n<pre>\n<code class=\"language-java\">import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Profile;\nimport org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver;\n\n@Configuration\n@Profile(\"integration-test\")\n@ComponentScan(value = \"com.app\")\npublic class IntegrationTestConfig {\n    @Bean\n    public InstrumentationLoadTimeWeaver loadTimeWeaver()  throws Throwable {\n        InstrumentationLoadTimeWeaver loadTimeWeaver = new InstrumentationLoadTimeWeaver();\n        return loadTimeWeaver;\n    }\n}</code></pre>\n\n<hr />\n<p><code>@SpringJUnit4ClassRunner</code></p>\n\n<p>Spring&#39;in <strong><em>TestContextManager</em></strong>&#39;ını bir JUnit testine yerleştiren JUnit4&#39;&uuml;n <em>ClassRunner</em>&#39;ının bir uygulamasıdır.</p>\n\n<p><em>TestContextManager</em>, Spring&nbsp;<em>TestContext</em>&nbsp;framework&#39;&uuml;n&uuml;n giriş noktasıdır ve bu nedenle bir JUnit test sınıfında Spring&nbsp;<em>ApplicationContext</em>&nbsp;ve dependency injection&#39;i y&ouml;netir. B&ouml;ylece,&nbsp;<em>SpringJUnit4ClassRunner</em>&nbsp;geliştiricilerin controller&nbsp;ve repository&nbsp;gibi Spring bileşenleri i&ccedil;in entegrasyon testleri uygulamasına olanak tanır.</p>\n\n<hr />\n<p><code>@SpringBootTest</code></p>\n\n<p>Testlerimizde kullanılacak <em>ApplicationContext</em>&#39;i oluşturarak &ccedil;alışır. &Ccedil;alışma&nbsp;ortamımızı yapılandırmak i&ccedil;in <em>@SpringBootTest</em>&#39;in <em>webEnvironment</em>&nbsp;niteliğini kullanabiliriz; kapsayıcının mock bir sunucu uygulaması ortamında &ccedil;alışması i&ccedil;in burada <em>WebEnvironment.MOCK</em> kullanıyoruz.</p>\n\n<p>Adından da anlaşılacağı gibi, entegrasyon testleri, uygulamanın farklı katmanlarını entegre etmeye odaklanır. Bu aynı zamanda hi&ccedil;bir mock data olmadığı anlamına gelir.</p>\n\n<p>İdeal olarak, entegrasyon testlerini &uuml;nit&nbsp;testlerinden ayrı tutmalı ve &uuml;nite testleriyle birlikte &ccedil;alıştırmamalıyız. Bunu, yalnızca entegrasyon testlerini &ccedil;alıştırmak i&ccedil;in farklı bir profil kullanarak yapabiliriz.</p>\n\n<hr />\n<p><code>@AutoConfigureMockMvc</code>:</p>\n\n<p><code>MockMvc</code>&#39;yi yapılandırmak istediğimizde kullanırız.&nbsp;<code>MockMvc</code>&nbsp;ile ilgili t&uuml;m otomatik yapılandırmayı etkinleştirir.</p>\n\n<hr />\n<p>Bu tanımlamalardan sonra herhangi integration testini uygulamak istediğimiz class yukarıdaki annotation&#39;ı tanımlamamız yeterli olacaktır. Spring RabbitMq ve Redis&#39;i local docker&#39;ımızda ayağa kaldıracaktır.</p>', 'integration-testlerinde-rabbitmq-ve-redis-setup', 'Integration Testlerinde RabbitMq ve Redis Setup', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'RabbitMq;Redis'),
('1cb9374e-4e52-4142-a1af-30009ef4a271', '<p>Dependency injection, bir uygulamadaki sınıflar arasında gevşek bağlantı(loose coupling) uygulamaya y&ouml;nelik bir yaklaşımdır. Bağımlılıkları enjekte etmenin farklı yolları vardır ve bu makale neden yapıcı enjeksiyonunun tercih edilen yol olması gerektiğini a&ccedil;ıklamaktadır.</p>\n\n<h2>Dependency injection nedir?</h2>\n\n<p><code>Dependency</code>: Bir nesne, işlemlerini ger&ccedil;ekleştirmek i&ccedil;in genellikle diğer sınıfların nesnelerine ihtiya&ccedil; duyar. Bu nesnelere bağımlılıklar diyoruz.</p>\n\n<p><code>Injection</code>: Bir nesneye gerekli bağımlılıkları sağlama s&uuml;reci.</p>\n\n<p>Bu nedenle dependency injection, kontrol&uuml;n tersine &ccedil;evrilmesinin (inversion of control, IoC) uygulanmasına yardımcı olur. Bu, bağımlılık nesnelerini oluşturan sınıf yerine, nesne oluşturma ve bağımlılıkları enjekte etme sorumluluğunun framework&#39;e (yani Spring) verildiği anlamına gelir.</p>\n\n<p>Aşağıdakilerle bağımlılık enjeksiyonu uygulayabiliriz:</p>\n\n<ul>\n	<li>yapıcı tabanlı enjeksiyon(constructor-based),</li>\n	<li>ayarlayıcı tabanlı enjeksiyon(setter-based),</li>\n	<li>alan bazlı enjeksiyon(field-based).</li>\n</ul>\n\n<h2>Constructor Injection</h2>\n\n<p>Sınıf i&ccedil;in gereken bağımlılıklar yapıcıya bağımsız değişkenler olarak sağlanır:</p>\n\n<pre>\n<code class=\"language-java\">@Component\nclass Cake {\n\n  private Flavor flavor;\n\n  Cake(Flavor flavor) {\n    Objects.requireNonNull(flavor);\n    this.flavor = flavor;\n  }\n\n  Flavor getFlavor() {\n    return flavor;\n  }\n  ...\n}</code></pre>\n\n<p>Spring 4.3&#39;ten &ouml;nce, constructor&#39;a bir <code>@Autowired</code> ek a&ccedil;ıklaması eklememiz gerekiyordu. Daha yeni s&uuml;r&uuml;mlerde, sınıfın yalnızca bir yapıcı metodu&nbsp;varsa bu isteğe bağlıdır. Yukarıdaki <code>Cake</code>&nbsp;sınıfında, yalnızca bir kurucumuz olduğundan, <code>@Autowired</code> a&ccedil;ıklamasını belirtmemize gerek yoktur. Aşağıdaki iki kurucu &ouml;rneğini d&uuml;ş&uuml;n&uuml;n:</p>\n\n<pre>\n<code class=\"language-java\">@Component\nclass Sandwich {\n\n  private Topping toppings;\n  private Bread breadType;\n\n  Sandwich(Topping toppings) {\n    this.toppings = toppings;\n  }\n\n  @Autowired\n  Sandwich(Topping toppings, Bread breadType) {\n    this.toppings = toppings;\n    this.breadType = breadType;\n  }\n  ...\n}</code></pre>\n\n<p>Birden &ccedil;ok yapıcı metoda&nbsp;sahip bir sınıfımız olduğunda, <code>@Autowired</code> a&ccedil;ıklamasını herhangi bir kurucuya a&ccedil;ık&ccedil;a eklememiz gerekir, b&ouml;ylece Spring, bağımlılıkları enjekte etmek i&ccedil;in hangi kurucunun kullanılacağını bilir.</p>\n\n<h2>Setter Injection</h2>\n\n<p>Gerekli bağımlılıkları sınıfa alan parametreleri olarak injeckte ediyoruz ve değerler, &ouml;zelliklerin &quot;setter&quot;&nbsp;y&ouml;ntemleri kullanılarak ayarlanıyor. Setter metodlarını&nbsp;<code>@Autowired</code> a&ccedil;ıklama ile a&ccedil;ıklamalıyız. <code>Cake</code> sınıfı, <code>Topping</code> t&uuml;r&uuml;nde bir nesne gerektirir. <code>Topping</code> nesnesi, bu &ouml;zelliğin ayarlayıcı y&ouml;nteminde bir arg&uuml;man olarak sağlanır:</p>\n\n<pre>\n<code class=\"language-java\">@Component\nclass Cookie {\n  private Topping toppings;\n\n  @Autowired\n  void setTopping(Topping toppings) {\n    this.toppings = toppings;\n  }\n\n  Topping getTopping() {\n    return toppings;\n  }\n  ...\n}</code></pre>\n\n<p>Spring, <code>@Autowired</code> a&ccedil;ıklamasını bulacak ve ayarlayıcıyı bağımlılığı enjekte etmesi i&ccedil;in &ccedil;ağıracaktır.</p>\n\n<h2>Field Injection</h2>\n\n<p>Spring, gerekli bağımlılıkları doğrudan <code>@Autowired</code> a&ccedil;ıklama ile a&ccedil;ıklama ekleme alanlarına atar. Bu &ouml;rnekte, Spring&#39;in <code>Topping</code> bağımlılığını alan enjeksiyonu yoluyla enjekte etmesine izin veriyoruz:</p>\n\n<pre>\n<code class=\"language-java\">@Component\nclass IceCream {\n  @Autowired\n  private Topping toppings;\n\n  Topping getToppings() {\n    return toppings;\n  }\n\n  void setToppings(Topping toppings) {\n    this.toppings = toppings;\n  }\n}</code></pre>\n\n<h2>Field ve Setter Enjeksiyonlarının Birleşimi</h2>\n\n<p><code>@Autowired</code>&#39;ı her ikisine de bir alan ve bir ayarlayıcı eklersek ne olur? Spring, bağımlılığı enjekte etmek i&ccedil;in hangi y&ouml;ntemi kullanacak?</p>\n\n<pre>\n<code class=\"language-java\">@Component\nclass Pizza {\n  @Autowired\n  private Topping toppings;\n\n  Topping getToppings() {\n    return toppings;\n  }\n\n  @Autowired\n  void setToppings(Topping toppings) {\n    this.toppings = toppings;\n  }\n}</code></pre>\n\n<p>Yukarıdaki &ouml;rnekte, hem &quot;set&quot; fonksiyonuna&nbsp;hem de alana <code>@Autowired</code> a&ccedil;ıklamasını ekledik. Bu durumda Spring, setter&nbsp;enjeksiyon y&ouml;ntemini kullanarak bağımlılık enjekte eder. Kodu daha az okunabilir hale getireceğinden enjeksiyon t&uuml;rlerini tek bir sınıfta karıştırmanın k&ouml;t&uuml; bir uygulama olduğunu unutmayın.</p>\n\n<h2>Neden Constructor Injection Kullanmalıyım?</h2>\n\n<p>Artık farklı enjeksiyon t&uuml;rlerini g&ouml;rd&uuml;ğ&uuml;m&uuml;ze g&ouml;re, yapıcı enjeksiyon kullanmanın bazı avantajlarından ge&ccedil;elim.</p>\n\n<h2>T&uuml;m Gerekli Bağımlılıklar Başlatma Zamanında Mevcuttur</h2>\n\n<p>Objeyi yapıcı metod &ccedil;ağrıdığında oluştururuz. Yapıcı metod gerekli t&uuml;m bağımlılıkları parametre olarak beklerse, o zaman sınıfın bağımlılıkları enjekte edilmeden asla somutlaştırılmayacağından %100 emin olabiliriz.</p>\n\n<p><strong>IoC konteyneri, yapıcı metoda sağlanan t&uuml;m arg&uuml;manların yapıcıya aktarılmadan &ouml;nce kullanılabilir olmasını sağlar.</strong> Bu, k&ouml;t&uuml; ş&ouml;hretli <code>NullPointerException</code>&#39;ı &ouml;nlemeye yardımcı olur.</p>\n\n<p>Yapıcı enjeksiyonu son derece kullanışlıdır, &ccedil;&uuml;nk&uuml; gerekli t&uuml;m bağımlılıkların y&uuml;klenip y&uuml;klenmediğini kontrol etmek i&ccedil;in her yerde ayrı bir iş mantığı yazmak zorunda olmadığımız i&ccedil;in kod karmaşıklığı basitleştirilir.</p>\n\n<blockquote>\n<h4>İsteğe Bağlı Bağımlılıklar Ne Olacak?</h4>\n\n<p>Ayarlayıcı(setter) enjeksiyonu ile Spring, bir ayarlayıcı y&ouml;ntemine <code>@Autowired(required=false)</code> ekleyerek isteğe bağlı bağımlılıkları belirlememizi sağlar. <code>required=false</code> t&uuml;m yapıcı bağımsız değişkenlerine uygulanacağından bu, yapıcı ekleme ile m&uuml;mk&uuml;n değildir.</p>\n\n<p>Java&#39;nın <code>Optional</code> t&uuml;r&uuml;n&uuml; kullanarak yapıcı enjeksiyonu ile isteğe bağlı bağımlılıklar sağlamaya devam edebiliriz.</p>\n</blockquote>\n\n<h3>Code Smell&#39;leri tanımlama</h3>\n\n<p>Constructor Injection, beanlerimizin &ccedil;ok fazla başka nesneye bağımlı olup olmadığını belirlememize yardımcı olur. Kurucumuzun &ccedil;ok sayıda arg&uuml;manı varsa, bu sınıfımızın &ccedil;ok fazla sorumluluğu olduğunun bir işareti olabilir. Sorunların uygun şekilde ayrılmasını daha iyi ele almak i&ccedil;in kodumuzu yeniden d&uuml;zenlemeyi d&uuml;ş&uuml;nmek isteyebiliriz.</p>\n\n<h2>Testlerde Hataların &Ouml;nlenmesi</h2>\n\n<p>Yapıcı enjeksiyonu, birim testleri yazmayı basitleştirir. Yapıcı, bizi t&uuml;m bağımlılıklar i&ccedil;in ge&ccedil;erli nesneler sağlamaya zorlar. Mockito gibi mocking k&uuml;t&uuml;phaneleri kullanarak, daha sonra kurucuya aktarabileceğimiz sahte nesneler oluşturabiliriz.</p>\n\n<p>Elbette ayarlayıcılar(setter) aracılığıyla da mock dataları&nbsp;verebiliriz, ancak bir sınıfa yeni bir bağımlılık eklersek, testte ayarlayıcıyı &ccedil;ağırmayı unutabiliriz, bu da potansiyel olarak testte bir <code>NullPointerException</code>&#39;a neden olur. Yapıcı enjeksiyonu, test senaryolarımızın yalnızca t&uuml;m bağımlılıklar mevcut olduğunda y&uuml;r&uuml;t&uuml;lmesini sağlar.</p>\n\n<h2>Değişmezlik</h2>\n\n<p>Yapıcı enjeksiyonu, sabit nesneler oluşturmaya yardımcı olur &ccedil;&uuml;nk&uuml; bir yapıcının imzası, nesneleri oluşturmanın tek olası yoludur. Bir bean oluşturduğumuzda, artık bağımlılıklarını değiştiremeyiz. Ayarlayıcı enjeksiyonu ile, oluşturulduktan sonra bağımlılığı enjekte etmek m&uuml;mk&uuml;nd&uuml;r, bu da diğer şeylerin yanı sıra &ccedil;ok iş par&ccedil;acıklı bir ortamda iş par&ccedil;acığı g&uuml;venli olmayabilen ve değişkenliklerinden dolayı hata ayıklaması daha zor olan değişken nesnelere yol a&ccedil;ar.</p>\n\n<h2>Sonu&ccedil;</h2>\n\n<p>Constructor injection, kodu daha sağlam hale getirir. <code>NullPointerException</code>&#39;ı ve diğer hataları &ouml;nleyerek değişmez nesneler oluşturmamızı sağlar.</p>', 'neden-constructor-injection-kullanmaliyiz', 'Neden Constructor Injection Kullanmalıyız?', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Constructor Injection;Setter Injection;Field Injection'),
('1cb9374e-4e52-4142-a1af-30010ef4a271', '<h3><strong>Benzerlikler;</strong></h3>\n\n<p>Vurgulamaya değer ilk nokta, <code>BeanDefinition</code> i&ccedil;in otomatik tarama algılama ve <code>dependency injection</code> ile ilgili olarak t&uuml;m bu annotation&#39;ların (yani, @Component, @Service, @Repository, @Controller) aynı olmasıdır. Birini diğerinin yerine kısmen kullanabiliriz ve yine de yolumuza devam edebiliriz.</p>\n\n<h3><strong>Farklılıklar;</strong></h3>\n\n<h4><strong>@Component</strong></h4>\n\n<p>Bu, sınıfın bir spring component olduğunu belirten genel ama&ccedil;lı bir stereotip annotation&#39;dır.</p>\n\n<p>&Ouml;zel olan şey; <code>&lt;context:component-scan&gt;</code>&nbsp;yalnızca <code>@Component</code>&#39;i tarar ve genel olarak <code>@Controller</code>,&nbsp;<code>@Service</code> ve <code>@Repository</code> aramaz. Kendilerine <code>@Component</code> ile annotate edildiğinde taranırlar. G&ouml;r&uuml;ld&uuml;ğ&uuml; gibi her <code>@Controller</code>,&nbsp;<code>@Service</code> ve <code>@Repository</code> birer <code>@Component</code>&#39;tır.</p>\n\n<pre>\n<code class=\"language-java\">@Component\npublic @interface Service {}\n\n@Component\npublic @interface Repository {}\n\n@Component\npublic @interface Controller {}</code></pre>\n\n<p>Bu nedenle <code>@Controller</code>,&nbsp;<code>@Service</code> ve <code>@Repository</code>&#39;nin <code>@Component</code>&#39;in &ouml;zel t&uuml;rleri olduğunu s&ouml;ylemek yanlış olmaz. <code>&lt;context:component-scan&gt;</code> onları alır ve takip eden sınıflarını, sanki <code>@Component</code> ile a&ccedil;ıklama eklenmiş gibi, bean olarak kaydeder. Custom tanımlanmış annotation&#39;lar da taranır, &ccedil;&uuml;nk&uuml; kendilerine <code>@Component</code> notu eklenir, bu da <code>@Component</code>&nbsp;oldukları anlamına gelir.</p>\n\n<h4><strong>@Repository</strong></h4>\n\n<p>Bu, sınıfın bir <code>data repository</code> olduğunu belirtmek i&ccedil;indir.&nbsp;<code>DAO</code>&nbsp;(Data Access Objects) denir, DB&#39;ye direkt erişirler.</p>\n\n<p><code>@Repository</code>&#39;nin g&ouml;revi, platforma &ouml;zel istisnaları yakalamak ve bunları Spring&#39;in birleştirilmiş denetlenmemiş istisnalarından(unified unchecked exception) biri olarak yeniden atmaktır. Bunun i&ccedil;in, Spring&#39;in uygulama bağlamına aşağıdaki gibi eklememiz gereken <code>PersistenceExceptionTranslationPostProcessor</code> ile sağlanır:</p>\n\n<pre>\n<code class=\"language-xml\">&lt;bean class=\"org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor\"/&gt;\n</code></pre>\n\n<p>Bu bean son işlemcisi, <code>@Repository</code> ile a&ccedil;ıklamalı herhangi bir fasulyeye bir danışman ekler, b&ouml;ylece platforma &ouml;zg&uuml; istisnalar yakalanır ve ardından Spring&#39;in denetlenmeyen veri erişimi istisnalarından biri olarak yeniden g&ouml;nderilir.</p>\n\n<h4><strong>@Controller</strong></h4>\n\n<p>Belirli bir sınıfın bir controller rol&uuml;ne hizmet ettiğini g&ouml;sterir.</p>\n\n<p>Aynı g&ouml;r&uuml;nseler bile, bu ek a&ccedil;ıklamayı <code>@Service</code>&nbsp;veya&nbsp;<code>@Repository</code> gibi başkalarıyla değiştiremeyiz. Dispatcher, <code>@Controller</code> ile a&ccedil;ıklamalı sınıfları tarar ve i&ccedil;lerinde&nbsp;<code>@RequestMapping</code> annoationları algılar ve&nbsp;yalnızca sınıfları <code>@Controller</code> ile a&ccedil;ıklamalı olan class&#39;ların metodları ile kullanabiliriz, <code>@Component</code>,&nbsp;<code>@Service</code>,&nbsp;<code>@Repository</code>&nbsp;ile &ccedil;alışmayacaktır.</p>\n\n<h4><strong>@Service</strong></h4>\n\n<p>İş mantığını tutar ve veri katmanına(repository) giden istekleri y&ouml;netir.</p>\n\n<h4><strong>Sonu&ccedil;</strong></h4>\n\n<p>Yukarıdakine benzer şekilde, gelecekte Spring, katmanlama kurallarına dayalı olarak <code>@Service</code>,&nbsp;<code>@Controller</code>&nbsp;ve&nbsp;<code>@Repository</code> i&ccedil;in &ouml;zel işlevler ekleyebilir. Bu nedenle, projeyi katmanlar doğrultusunda kullanmak her zaman iyi bir fikirdir.</p>', 'at-component-vs-at-repository-vs-at-service-vs-at-controller', '@Component vs @Repository vs @Service vs @Controller', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Component;Repository;Controller;Service'),
('1cb9374e-4e52-4142-a1af-30011ef4a271', '<h3><strong>Entegrasyon ve Birim Testleri</strong></h3>\n\n<p>Spring Boot, ApplicationContext&#39;i oluşturarak &ccedil;alışacak entegrasyon ve birim testlerinin yazılmasını da kolaylaştırır. Aktive etmek i&ccedil;in test starter&#39;ın eklenmesi yeterlidir.</p>\n\n<pre>\n<code class=\"language-bash\">&lt;dependency&gt;\n	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n	&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n<pre>\n<code class=\"language-java\">@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class IntegrationTests {\n	@Autowired\n	private Service service;\n	@Autowired\n	private WebApplicationContext wac;\n	@Test\n	public void testFindOwners() {\n		List&lt;Owner&gt; owners = service.findOwners();\n		MatcherAssert.assertThat(owners.size(), Matchers.equalTo(10));\n	}\n}</code></pre>\n\n<h3><strong>Entegrasyon Testleri ve REST Servislerine Erişim</strong></h3>\n\n<ul>\n	<li>Spring Boot entegrasyon testini &ccedil;alıştırırken web container&rsquo;ıda g&ouml;m&uuml;l&uuml; olarak &ccedil;alıştırabilmektedir.</li>\n	<li>Bu sayede uygulamanın web katmanına erişimi engerasyon testleri &uuml;zerinden kontrol etmek m&uuml;mk&uuml;n olmaktadır.</li>\n	<li>Ayrıca <strong>TestRestTemplate</strong> isimli yardımcı bir sınıftan bean ile REST servislerine erişim de entegrasyon testlerine tabi tutulabilmektedir.</li>\n</ul>\n\n<pre>\n<code class=\"language-java\">@RunWith(SpringRunner.class)\n@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)\npublic class ControllerIntTests {\n	@LocalServerPort\n	private int port;\n\n	@Autowired\n	private TestRestTemplate testRestTemplate; // Spring RestTemplate sınıfının üzerine ilave kabiliyetler koyar.\n\n	private URL base;\n\n	@Before\n	public void setUp() throws Exception {\n		base = new URL(\"http://localhost:\" + port + \"/welcome\");\n	}\n	@Test\n	public void testWelcome() throws IOException {\n		String response = testRestTemplate.getForObject(base.toString(), String.class);\n		MatcherAssert.assertThat(response, Matchers.containsString(\"Hello World!\"));\n	}\n}</code></pre>\n\n<h3><strong>Mock Mvc ile Controller Metotlarının Test Edilmesi</strong></h3>\n\n<ul>\n	<li>Spring Boot classpath&rsquo;de Servlet API sınıfları mevcut ise default olarak Mock nesnelerden oluşan bir Servlet Container ortamı oluşturmaktadır.</li>\n	<li>Bu ortam &uuml;zerinden Tomcat gibi herhangi bir web container olmaksızın MVC controller metotları entegrasyon testlerine tabi tutulabilir</li>\n</ul>\n\n<pre>\n<code class=\"language-java\">@RunWith(SpringRunner.class)\n@AutoConfigureMockMvc\n@SpringBootTest(webEnvironment=WebEnvironment.MOCK)\n// WebApplicationContext\'i Mock Servlet ortamı ile oluşturur,\n// eğer Servlet API sınıfları classpath\'de mevcut değil ise normal bir ApplicationContext oluşturur.\npublic class ControllerUnitTests {\n	@Autowired\n	private MockMvc mvc; //@AutoConfigureMockMvc annotation ile MockMvc nesnesinin otomatik konfigürasyonunu gerçekleştirir\n\n	@Test\n	public void testWelcome() throws Exception {\n		mvc.perform(MockMvcRequestBuilders.get(\"/hello\")\n			.accept(MediaType.APPLICATION_JSON))\n			.andExpect(MockMvcResultMatchers.status().isOk())\n			.andExpect(MockMvcResultMatchers.content()\n			.string(Matchers.containsString(\"Hello World!\")));\n	}\n}</code></pre>\n\n<h2><strong>Mockito.mock()</strong></h2>\n\n<p><code>Mockito.mock()</code>&nbsp;metodu, bir sınıfın veya bir interface&#39;in&nbsp;mock bir nesnesini oluşturmamızı sağlar.</p>\n\n<pre>\n<code class=\"language-java\">@Test\npublic void givenCountMethodMocked_WhenCountInvoked_ThenMockedValueReturned() {\n    UserRepository localMockRepository = Mockito.mock(UserRepository.class);\n    Mockito.when(localMockRepository.count()).thenReturn(111L);\n\n    long userCount = localMockRepository.count();\n\n    Assert.assertEquals(111L, userCount);\n    Mockito.verify(localMockRepository).count();\n}</code></pre>\n\n<h2><strong>Mockito&#39;nun&nbsp;@Mock&nbsp;Annotation</strong></h2>\n\n<p>Bu annotation, <code>Mockito.mock()</code>&nbsp;y&ouml;ntemi i&ccedil;in bir kısaltmadır. Ayrıca, onu sadece bir test sınıfında kullanmalıyız. <code>Mockito.mock()</code>&nbsp; y&ouml;nteminden farklı olarak, bu ek a&ccedil;ıklamayı kullanmak i&ccedil;in Mockito annotation&#39;ı&nbsp;etkinleştirmemiz gerekir.</p>\n\n<p>Bunu testi &ccedil;alıştırmak i&ccedil;in <code>MockitoJUnitRunner</code>&#39;ı kullanarak veya <code>MockitoAnnotations.initMocks() </code>y&ouml;ntemini a&ccedil;ık&ccedil;a &ccedil;ağırarak yapabiliriz. <code>MockitoJUnitRunner</code> kullanan bir &ouml;rneğe bakalım:</p>\n\n<pre>\n<code class=\"language-java\">@RunWith(MockitoJUnitRunner.class)\npublic class MockAnnotationUnitTest {\n\n    @Mock\n    UserRepository mockRepository;\n\n    @Test\n    public void givenCountMethodMocked_WhenCountInvoked_ThenMockValueReturned() {\n        Mockito.when(mockRepository.count()).thenReturn(123L);\n\n        long userCount = mockRepository.count();\n\n        Assert.assertEquals(123L, userCount);\n        Mockito.verify(mockRepository).count();\n    }\n}</code></pre>\n\n<p>Kodu daha okunaklı hale getirmenin yanı sıra, <code>@Mock</code>, bir problem durumunda problem&#39;i&nbsp;alan adı hata mesajında g&ouml;r&uuml;nd&uuml;ğ&uuml; i&ccedil;in bulmayı kolaylaştırır&nbsp;</p>\n\n<pre>\n<code class=\"language-bash\">Wanted but not invoked:\nmockRepository.count();\n-&gt; at org.baeldung.MockAnnotationTest.testMockAnnotation(MockAnnotationTest.java:22)\nActually, there were zero interactions with this mock.\n\n  at org.baeldung.MockAnnotationTest.testMockAnnotation(MockAnnotationTest.java:22)\n</code></pre>\n\n<p>Ayrıca <code>@InjectMocks</code>&nbsp;ile birlikte kullanıldığında, kurulum kodu miktarını &ouml;nemli &ouml;l&ccedil;&uuml;de azaltabilir.</p>\n\n<h2><strong>@MockBean&nbsp;Annotation</strong></h2>\n\n<p>Spring uygulama bağlamına mock nesneler eklemek i&ccedil;in <code>@MockBean</code>&nbsp;kullanabiliriz. Mock nesne, uygulama bağlamında aynı t&uuml;rden herhangi bir mevcut bean&#39;nin yerini alacaktır.</p>\n\n<p>Aynı t&uuml;rden bir bean tanımlanmamışsa, yeni bir tane eklenecektir. Bu a&ccedil;ıklama, belirli bir bean&#39;nin&nbsp;mock edilmesi gereken entegrasyon testlerinde kullanışlıdır. Bu a&ccedil;ıklamayı kullanmak i&ccedil;in, testi &ccedil;alıştırmak &uuml;zere <code>SpringRunner</code>&#39;ı kullanmalıyız:</p>\n\n<pre>\n<code class=\"language-java\">@RunWith(SpringRunner.class)\npublic class MockBeanAnnotationIntegrationTest {\n\n    @MockBean\n    UserRepository mockRepository;\n\n    @Autowired\n    ApplicationContext context;\n\n    @Test\n    public void givenCountMethodMocked_WhenCountInvoked_ThenMockValueReturned() {\n        Mockito.when(mockRepository.count()).thenReturn(123L);\n\n        UserRepository userRepoFromContext = context.getBean(UserRepository.class);\n        long userCount = userRepoFromContext.count();\n\n        Assert.assertEquals(123L, userCount);\n        Mockito.verify(mockRepository).count();\n    }\n}</code></pre>\n\n<p>Annotation&#39;ı bir alanda kullandığımızda, uygulama bağlamında kayıtlı olmanın yanı sıra, sahte alana da enjekte edilecektir. Bu, yukarıdaki kodda belirgindir.</p>\n\n<p>Burada, <code>count</code> y&ouml;ntemini saplamak i&ccedil;in enjekte edilen <code>UserRepository</code> mock&#39;unu kullandık. Daha sonra, ger&ccedil;ekten mock bean olduğunu doğrulamak i&ccedil;in uygulama bağlamındaki bean&#39;i kullandık.</p>', 'spring-boot-ve-test', 'Spring Boot ve Test', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'test;mock;MockBean'),
('1cb9374e-4e52-4142-a1af-30012ef4a271', '<h3><strong>Spring Web MVC</strong></h3>\n\n<p>Spring Web MVC framework, Model-View-Controller (MVC) mimarisi,&nbsp;esnek&nbsp;bağlı(loosely coupled) web uygulamaları geliştirmek i&ccedil;in kullanılabilen hazır bileşenler sağlar. MVC modeli, uygulamanın farklı y&ouml;nlerini (giriş mantığı, iş mantığı ve UI mantığı) ayırırken bu &ouml;ğeler arasında gevşek bir bağlantı sağlar.</p>\n\n<ul>\n	<li><strong>Model</strong>, uygulama verilerini kapsamaktadır ve genel olarak bunlar POJO&#39;dan oluşacaktır.</li>\n	<li><strong>View</strong>, model verilerinin işlenmesinden sorumludur ve genel olarak, m&uuml;şterinin tarayıcısının yorumlayabileceği HTML &ccedil;ıktısını &uuml;retir.</li>\n	<li><strong>Controller</strong>, kullanıcı taleplerini işlemekten ve uygun bir model oluşturmaktan ve bunu işleme i&ccedil;in g&ouml;r&uuml;n&uuml;me ge&ccedil;irmekten sorumludur.</li>\n</ul>\n\n<p><strong>DispatcherServlet</strong></p>\n\n<p>DispatcherServlet default olarak b&uuml;t&uuml;n web isteklerini yakalayacak bi&ccedil;imde tanımlıdır.&nbsp;<strong>application.properties</strong>&#39;de bir tanım ile sadece belirli web isteklerini ele alması sağlanabilir.</p>\n\n<pre>\n<code class=\"language-bash\">server.servlet-path=/mvc/*</code></pre>\n\n<p>Spring Web model-view-controller (MVC) framework, t&uuml;m HTTP isteklerini ve yanıtlarını işleyen bir <code>DispatcherServlet</code> etrafında tasarlanmıştır. Spring Web MVC DispatcherServlet&#39;in istek işleme iş akışı aşağıdaki şemada g&ouml;sterilmektedir.</p>\n\n<p><img alt=\"\" src=\"/upload/files/spring_dispatcherservlet.png\" style=\"height:331px; width:554px\" /></p>\n\n<p>DispatcherServlet&#39;e gelen bir HTTP isteğine karşılık gelen olaylar dizisi aşağıdadır.</p>\n\n<ul>\n	<li>Bir HTTP isteği aldıktan sonra <em>DispatcherServlet</em>, uygun Denetleyiciyi &ccedil;ağırmak i&ccedil;in <em>HandlerMapping</em>&#39;e başvurur.</li>\n	<li><em>Controller</em> talebi alır ve kullanılan GET veya POST y&ouml;ntemine g&ouml;re uygun hizmet y&ouml;ntemlerini &ccedil;ağırır. Service metodu, model verilerinde tanımlanan iş mantığına g&ouml;re ayarlar ve view adını <em>DispatcherServlet</em>&#39;e d&ouml;nd&uuml;r&uuml;r.</li>\n	<li><em>DispatcherServlet</em>, istek i&ccedil;in tanımlanmış view&#39;i almak i&ccedil;in <em>ViewResolver</em>&#39;dan yardım alır.</li>\n	<li>View sonlandırıldığında, <em>DispatcherServlet</em> model verilerini nihayet tarayıcıda oluşturulan g&ouml;r&uuml;n&uuml;me aktarır.</li>\n</ul>\n\n<p>Yukarıda belirtilen bileşenlerin t&uuml;m&uuml;, yani HandlerMapping, Controller ve ViewResolver&nbsp;web uygulamaları i&ccedil;in gerekli bazı ekstra &ouml;zelliklere sahip d&uuml;z ApplicationContext&#39;in bir uzantısı olan <em>WebApplicationContext</em> par&ccedil;alarıdır.</p>\n\n<p>Spring Boot ile web uygulamaları ve REST servisleri geliştirmek i&ccedil;in <strong>web starter</strong>&#39;ının eklenmesi yeterlidir. <code>pom.xml</code>&#39;deki bu tanım <code>DispatcherServlet</code> ve diğer pek &ccedil;ok Web MVC &ouml;zelliğini devreye sokar.</p>\n\n<pre>\n<code class=\"language-bash\">&lt;dependency&gt;\n	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n<h3><strong>Server Port ve Context Path Ayarları</strong></h3>\n\n<p>Spring Boot web uygulamasını varsayılan durumda 8080 portunda ve / URI path&rsquo;inden erişilecek bi&ccedil;imde deploy eder. Bu ayarlar <strong>application.properties</strong> i&ccedil;erisinden değiştirilebilir.</p>\n\n<pre>\n<code class=\"language-bash\">server.port=8081\nserver.context-path=/customPath</code></pre>\n\n<h3><strong>Statik Web Resource&#39;larına Erişim</strong></h3>\n\n<p>Eğer bir web isteği <code>@RequestMapping</code> ile eşleşmemiş ise statik web resource olarak &ccedil;&ouml;z&uuml;mlenir. Bunun i&ccedil;in default olarak sırası ile classpath&#39;deki <code>META-INF/resources</code>, <code>resources</code>, <code>static</code> veya <code>public</code> dizinlerine, yada <code>ServletContext</code> root dizinine bakılır. İstenirse bu lokasyonlar <strong>application.properties</strong>&#39;den &ouml;zelleştirilebilir</p>\n\n<pre>\n<code class=\"language-apache\">spring.resources.static-locations=classpath:/webresources</code></pre>\n\n<p>Default olarak statik resource&#39;lara yapılan istekler <code>/**</code> &ouml;r&uuml;nt&uuml;s&uuml; ile eşleştirilir. İstenirse bu <strong>application.properties</strong>&#39;deki tanımla değiştirilebilir</p>\n\n<pre>\n<code class=\"language-bash\">spring.mvc.static-path-pattern=/resources/**\n</code></pre>\n\n<p>&nbsp;Spring Boot ayrıca webjars formatındaki jar dosyalarının i&ccedil;erisindeki resource&#39;lara <code>/webjars/**</code> &ouml;r&uuml;nt&uuml;s&uuml; ile erişim imkanı da sunar</p>\n\n<h3><strong>Index.html ve Favicon</strong></h3>\n\n<p>Spring Boot <em>index.html</em>&#39;i statik web resource&#39;larının bulunduğu lokasyonlardan sunmaktadır. <em>favicon.ico</em> dosyasını da belirtilen lokasyonlardan ve root classpath&#39;den aramaktadır. Eğer bu dosyalar mevcut ise uygulamanın default home sayfası ve favicon ikonu olarak kullanılırlar.</p>\n\n<h3><strong>Spring Boot ve JSP</strong></h3>\n\n<p>Java Server Pages (JSP) Kurumsal Java d&uuml;nyasının ilk standard UI teknolojisidir. Dinamik web sayfaları geliştirmek i&ccedil;in kullanılır. Hala yaygın bi&ccedil;imde kullanılmaktadır. Ancak web container&rsquo;ların executable JAR i&ccedil;erisinde yer alan JSP sayfalarına erişiminde sorunlar olabilmektedir.</p>\n\n<p>Spring Boot&rsquo;un &ouml;nerisi dinamik web sayfaları i&ccedil;in JSP yerine Thymeleaf, FreeMarker gibi template engine&rsquo;ler kullanılmasıdır.&nbsp;Ancak web container olarak Tomcat kullanıyorsanız k&uuml;&ccedil;&uuml;k bir ayarlama sonrası JSP teknolojisi ile rahatlıkla &ccedil;alışabilirsiniz.</p>\n\n<h3><strong>JSP Kullanmak İ&ccedil;in Yapılması Gerekenler</strong></h3>\n\n<p>&nbsp;JSP sayfaları <code>src/main/webapp</code> dizini altında bir lokasyonda oluşturulmalıdır. Dolayısı ile projenin packaging tipi war olmalıdır.</p>\n\n<pre>\n<code class=\"language-apache\">&lt;packaging&gt;war&lt;/packaging&gt;</code></pre>\n\n<p>Tomcat ile &ccedil;alışırken jasper compiler&#39;ın classpath&#39;de yer alması gerekir.</p>\n\n<pre>\n<code class=\"language-apache\">&lt;dependency&gt;\n	&lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;\n	&lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>JSP sayfaları i&ccedil;erisinde JSTL vs kullanılıyor ise JSTL k&uuml;t&uuml;phanesi projenin classpath&#39;inde yer almalıdır.</p>\n\n<pre>\n<code class=\"language-apache\">&lt;dependency&gt;\n	&lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n	&lt;artifactId&gt;jstl&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>&nbsp;JSP sayfalarını &ccedil;&ouml;z&uuml;mleyen ViewResolver&#39;a prefix ve suffix olarak aşağıdaki değerler verilebilir.</p>\n\n<pre>\n<code class=\"language-apache\">spring.mvc.view.prefix=/WEB-INF/jsp/\nspring.mvc.view.suffix=.jsp\n</code></pre>\n\n<h3><strong>Spring Boot ve JSP Kısıtları</strong></h3>\n\n<p>Undertow server, JSP sayfalarını desteklememektedir. <code>error.jsp</code> şeklinde bir sayfa default error view yerine ge&ccedil;meyecektir.</p>\n\n<h3><strong>Spring Boot ve Template Kullanımı</strong></h3>\n\n<p>Spring Boot view teknolojisi olarak JSP yerine template engine&#39;ler ile &ccedil;alışmayı &ouml;nermektedir. Dinamik web sayfaları i&ccedil;in default olarak aşağıdaki template engine&#39;ler i&ccedil;in otomatik konfig&uuml;rasyon imkanı sunar.</p>\n\n<ul>\n	<li>Thymeleaf</li>\n	<li>FreeMarker</li>\n	<li>Groovy</li>\n	<li>Mustache</li>\n</ul>\n\n<h3><strong>Spring Boot ve Template Kullanımı</strong></h3>\n\n<p>Bunların ilgili starter&#39;ını eklemek yeterlidir.</p>\n\n<pre>\n<code class=\"language-apache\">&lt;dependency&gt;\n	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n	&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>Default olarak template dosyaları <code>classpath:/templates</code> isimli bir lokasyondan y&uuml;klenir. İstenirse bu lokasyon ve suffix&#39;ler &ouml;zelleştirilebilir.</p>\n\n<pre>\n<code class=\"language-apache\">spring.thymeleaf.prefix=classpath:/templates/\nspring.thymeleaf.suffix=.html\n</code></pre>\n\n<p>Şablon motoru ile ilgili starter eklendiğinde view resolution kabiliyeti de otomatik olarak devreye girer. Starter tanımını pom.xml&rsquo;den &ccedil;ıkarmadan şablonun view resolution kabiliyeti devre dışı bırakılabilir.</p>\n\n<pre>\n<code class=\"language-bash\">spring.thymeleaf.enabled=true\n</code></pre>\n\n<h3><strong>Şablonların &Ouml;n Bellekten Erişilmesi</strong></h3>\n\n<p>Şablon dosyalarının i&ccedil;eriği &ouml;n bellekte tutulabilmektedir. Bu davranış şablon motorunun varsayılan tanımına g&ouml;re devre dışı bırakılabilir veya devreye alınabilir.</p>\n\n<pre>\n<code class=\"language-apache\">spring.thymeleaf.cache=true\n</code></pre>\n\n<h3><strong>Spring Boot ve Hata Sayfaları</strong></h3>\n\n<p>HTTP stat&uuml; kodlarına karşılık gelen custom hata sayfaları oluşturmak i&ccedil;in statik web resource lokasyonları altında <code>/error</code> isimli bir dizin oluşturulmalıdır. Bu dizin altında stat&uuml; koduna karşılık gelen html sayfa oluşturulmalıdır. Hata sayfaları dinamik i&ccedil;eriğe de sahip olabilir. Bu durumda <code>/error</code> dizini <code>classpath:/templates</code> altında yer almalıdır.</p>\n\n<h3><strong>Default White Label Hata Sayfası</strong></h3>\n\n<p>Eğer stat&uuml; koduna karşılık gelen bir hata sayfası mevcut değil ise Spring Boot whitelabel hata sayfası &ccedil;ıkarır.</p>\n\n<h3><strong>Servlet, Filter veya EventListener Tanımlamak</strong></h3>\n\n<p>Uygulamaya &ouml;zel Servlet, Filter veya EventListener tanımlamak da m&uuml;mk&uuml;nd&uuml;r. Yazılan <code>Servlet</code>, <code>Filter</code> veya <code>EventListener</code> sınıfları <code>@WebServlet</code>, <code>@WebFilter</code>, <code>@WebListener</code> anotasyonları ile işaretlenmelidir. Ayrıca uygulamanın konfig&uuml;rasyon sınıfında da <code>@ServletComponentScan</code> anotasyonu kullanılmalıdır.</p>\n\n<pre>\n<code class=\"language-java\">@WebServlet(urlPatterns=\"/pcs\")\npublic class PetClinicServlet extends HttpServlet {\n	@Override\n	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n		resp.getWriter().write(\"pcs...\");\n	}\n}</code></pre>\n\n<pre>\n<code class=\"language-java\">@WebFilter(urlPatterns=\"/*\")\npublic class Filter implements Filter {\n	...\n	@Override\n	public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException {\n		try {\n			System.out.println(\"before...\");\n			arg2.doFilter(arg0, arg1);\n		} finally {\n			System.out.println(\"after...\");\n		}\n	}\n}</code></pre>\n\n<pre>\n<code class=\"language-java\">@WebListener\npublic class HttpSessionListener implements HttpSessionListener {\n	@Override\n	public void sessionCreated(HttpSessionEvent se) {\n		System.out.println(\"Session created :\" + se.getSession().getId());\n	}\n	@Override\n	public void sessionDestroyed(HttpSessionEvent se) {\n		System.out.println(\"Session destroyed :\" + se.getSession().getId());\n	}\n}</code></pre>\n\n<pre>\n<code class=\"language-java\">@SpringBootApplication\n@ServletComponentScan // Bunu ekledik\npublic class Application {\n	...\n}</code></pre>\n\n<p>3rd party sınıflarda <code>@WebServlet</code>, <code>@WebFilter</code> veya <code>@WebListener</code> anotasyonları kullanmamış olabilir. Bu gibi durumlarda konfig&uuml;rasyon sınıfı i&ccedil;erisinde <code>ServletRegistrationBean</code>, <code>FilterRegistrationBean</code>, veya <code>ServletListenerRegistrationBean</code> sınıfları ile aynı şekilde servlet, filter veya listener tanımlanabilir.</p>\n\n<pre>\n<code class=\"language-java\">@Configuration\npublic class CustomConfiguration {\n	@Bean\n	public ServletRegistrationBean pcs() {\n		return new ServletRegistrationBean(new CustomServlet(), \"/pcs\");\n	}\n	@Bean\n	public FilterRegistrationBean pcsFilter() {\n		FilterRegistrationBean bean = new FilterRegistrationBean(new Filter());\n		bean.setUrlPatterns(Arrays.asList(\"/*\"));\n		bean.setOrder(Ordered.HIGHEST_PRECEDENCE);\n		return bean;\n	}\n	@Bean\n	public ServletListenerRegistrationBean pcsListener() {\n		return new ServletListenerRegistrationBean&lt;&gt;(new HttpSessionListener());\n	}\n}</code></pre>\n\n<h3><strong>Statik Web Resource&rsquo;ları ve Cache Busting</strong></h3>\n\n<p>CSS, JS gibi statik resource&rsquo;lar tarayıcı tarafında cache&rsquo;lenerek m&uuml;teakip isteklerde sunucuya erişmeden kullanıcıya hızlıca g&ouml;sterilebilirler. Geliştirme ortamında bu &ouml;zellik, ilgili dosyalarda yapılmış değişikliklerin g&ouml;r&uuml;nt&uuml;lenmesini engelleyecektir. Spring Boot bu problemi aşmak i&ccedil;in <code>cache busting</code> kabiliyeti sunar.</p>\n\n<pre>\n<code class=\"language-html\">&lt;head&gt;\n    &lt;link rel=\"stylesheet\" type=\"text/css\" th:href=\"@{/css/custom.css}\"/&gt;\n&lt;/head&gt;</code></pre>\n\n<p>y&uuml;klenirken...</p>\n\n<pre>\n<code class=\"language-html\">&lt;head&gt;\n   &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/custom-2a2d595e6ed9a0b24f027f2b63b134d6.css\"/&gt;\n&lt;/head&gt;</code></pre>\n\n<h3><strong>Cache Busting&rsquo;in Devreye Alınması</strong></h3>\n\n<p>Devreye almak i&ccedil;in application.properties&rsquo;de ilgili property tanımı yapılmalıdır.</p>\n\n<pre>\n<code class=\"language-apache\">spring.resources.chain.strategy.content.enabled=true\nspring.resources.chain.strategy.content.paths=/**\n</code></pre>\n\n<p>Cache Busting&rsquo;i arka planda ger&ccedil;ekleştiren <code>ResourceUrlEncodingFilter</code>&rsquo;dır. Spring Boot Thymeleaf ve FreeMarker template engine&rsquo;leri devreye alındığında bu filter&rsquo;ı da otomatik aktive eder. JSP veya diğer template engine&rsquo;ler i&ccedil;in <code>ResourceUrlEncodingFilter</code>&rsquo;ın projeye manuel bi&ccedil;imde dahil edilmesi gerekir.</p>\n\n<h3><strong>ResourceUrlEncodingFilter&rsquo;ın Manuel Konfig&uuml;rasyonu</strong></h3>\n\n<pre>\n<code class=\"language-java\">@Configuration\npublic class FilterConfiguration {\n	@Bean\n	public FilterRegistrationBean resourceUrlEncodingFilter() {\n		FilterRegistrationBean bean = new FilterRegistrationBean(new ResourceUrlEncodingFilter());\n		bean.setUrlPatterns(Arrays.asList(\"/*\"));\n		bean.setOrder(Ordered.HIGHEST_PRECEDENCE);\n		return bean;\n	}\n}</code></pre>\n\n<h3><strong>JS Dosyaları ve Cache Busting</strong></h3>\n\n<p>Angular, Bootstrap, JQuery gibi JS teknolojileri ile &ccedil;alışırken ise JS dosyalarında resource path&rsquo;e statik versiyon prefix&rsquo;i eklenir.</p>\n\n<pre>\n<code class=\"language-apache\">spring.resources.chain.strategy.fixed.enabled=true\nspring.resources.chain.strategy.fixed.paths=/js/lib/\nspring.resources.chain.strategy.fixed.version=v12\n</code></pre>\n\n<pre>\n<code class=\"language-javascript\">$.getScript(\'/js/lib/mymodule.js\', function(){\n	window.alert(\'module loaded!\');\n});</code></pre>\n\n<p>y&uuml;klenirken...</p>\n\n<pre>\n<code class=\"language-javascript\">$.getScript(\'/v12/js/lib/mymodule.js\', function(){\n	window.alert(\'module loaded!\');\n});</code></pre>\n\n<h3><strong>Spring MVC &Ouml;zelleştirmeleri</strong></h3>\n\n<p>Spring Boot, Spring MVC ile ilgili pek &ccedil;ok &ouml;zelliği otomatik olarak devreye almaktadır. Bazı durumlarda bu konfig&uuml;rasyona uygulama spesifik ilaveler, &ouml;rneğin interceptor, formatter, view controller, yapmak gerekebilir. Bunun i&ccedil;in WebMvcConfigurerAdapter sınıfından t&uuml;reyen bir konfig&uuml;rasyon sınıfı yazmak yeterlidir.</p>\n\n<pre>\n<code class=\"language-java\">@Configuration\npublic class CustomMvcConfig extends WebMvcConfigurerAdapter {\n	...\n}</code></pre>\n\n<p>Spring MVC konfig&uuml;rasyonunu tamemen manuel yapmak, Spring Boot&#39;un otomatik konfig&uuml;rasyonunu devreden &ccedil;ıkarmak i&ccedil;in konfig&uuml;rasyon sınıfının &uuml;zerine <code>@EnableWebMvc</code> anotasyonu da eklenmelidir.</p>\n\n<pre>\n<code class=\"language-java\">@Configuration\n@EnableWebMvc\npublic class CustomMvcConfig extends WebMvcConfigurerAdapter {\n	...\n}</code></pre>', 'spring-boot-ve-web-mvc', 'Spring Boot ve Web MVC', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'web;mvc'),
('1cb9374e-4e52-4142-a1af-30013ef4a271', '<p>Spring Boot&#39;un &ccedil;ıkış hedeflerinden birisi de mikroservis mimarisine uygun headless web uygulamaları geliştirmektir.</p>\n\n<pre>\n<code class=\"language-java\">@RestController\npublic class RestController {\n	@RequestMapping(\"/hello\")\n	public String hello() {\n		return \"Hello World!\";\n	}\n}</code></pre>\n\n<p><strong>RestTemplate Konfig&uuml;rasyonu</strong></p>\n\n<ul>\n	<li>\n	<p>Uzaktaki REST servislerini &ccedil;ağırmak i&ccedil;in RestTemplate sınıfı kullanılabilir.</p>\n	</li>\n	<li>\n	<p>RestTemplate nesneleri kullanım yerlerine g&ouml;re farklı ayarlarla oluşturulduklarından Spring Boot genel ama&ccedil;lı bir RestTemplate bean&#39;i sunmaz.</p>\n	</li>\n	<li>\n	<p>Bunun yerine RestTemplateBuilder bean&#39;i sunarak RestTemplate&#39;ın konfig&uuml;rasyonu kullanılan yerde yapılabilir.</p>\n	</li>\n</ul>\n\n<p><strong>RestTemplateBuilder Kullanımı</strong></p>\n\n<p>RestTemplateBuilder sayesinde, &ouml;rneğin gerekli HttpMessageConverter nesneleri, HTTP basic auth vs RestTemplate instance&#39;larına kolayca uygulanır.</p>\n\n<pre>\n<code class=\"language-java\">@Service\npublic class CustomService {\n	private RestTemplate restTemplate;\n\n	@Autowired\n	public CustomService(RestTemplateBuilder restTemplateBuilder) {\n		restTemplate = restTemplateBuilder\n						.basicAuthorization(\"user\", \"secret\")\n						.defaultMessageConverters()\n						.build();\n		// ...\n	}\n}</code></pre>\n\n<p><strong>Response Content Tipinin Belirlemesi</strong></p>\n\n<ul>\n	<li>\n	<p>Spring REST servis &ccedil;ağrılarında istemci sunucudan resource&rsquo;u hangi formatta d&ouml;nmesi gerektiğini aşağıdaki y&ouml;ntemlerden birisi ile belirtebilir.</p>\n\n	<ul>\n		<li>\n		<p><strong>Request URI</strong>&rsquo;ının uzantısı</p>\n		</li>\n		<li>\n		<p><strong>format</strong> isimli bir request parametresinin değeri</p>\n		</li>\n		<li>\n		<p><strong>Accept</strong> Request Header&rsquo;ı</p>\n		</li>\n	</ul>\n	</li>\n	<li>\n	<p>Spring Boot default olarak sadece &ldquo;accept request header&rdquo;ı devreye alır.</p>\n	</li>\n</ul>\n\n<p><strong>Request URI&rsquo;ının Uzantısı</strong></p>\n\n<p>Devreye almak i&ccedil;in application.properties i&ccedil;erisinde aşağıdaki property tanımları yapılmalıdır.</p>\n\n<pre>\n<code class=\"language-bash\">spring.mvc.contentnegotiation.favor-path-extension=true\nspring.mvc.pathmatch.use-suffix-pattern=true</code></pre>\n\n<p><strong>Format Request Parametresi</strong></p>\n\n<p>Devreye almak i&ccedil;in application.properties i&ccedil;erisinde aşağıdaki property tanımı yapılmalıdır.</p>\n\n<pre>\n<code class=\"language-bash\">spring.mvc.contentnegotiation.favor-parameter=true</code></pre>\n\n<p><strong>Hypermedia As The Engine Of Application State (HATEOAS)</strong></p>\n\n<p>Bir rest servisinin response &uuml;zerinden t&uuml;m i&ccedil;erik bilgilerini g&ouml;rebildiğimiz başka bir kaynağa ya da d&ouml;k&uuml;mana gerek kalmadan kullanabilmeye olanak sağlayan bir ara&ccedil;tır. &Ouml;rnek verecek olursam bir kişinin kaydını getirmek i&ccedil;in rest &uuml;zerinden gelen cevabın i&ccedil;erisinde o restin diğer yapabileceği t&uuml;m yeteneklerinde g&ouml;r&uuml;lebileceği bir yapı sağlamaktadır. Projemizde başka Rest işlemleri eklediysek silme, g&uuml;ncelleme gibi işlemleri yapabilmek i&ccedil;in hangi rest yolunun kullanılması gerektiği gibi bilgileri g&ouml;r&uuml;nt&uuml;ler.</p>\n\n<p><strong>Spring Boot ve HATEOAS</strong></p>\n\n<ul>\n	<li>\n	<p>RESTful API geliştirenler i&ccedil;in Spring HATEOAS&#39;ın otomatik konfig&uuml;rasyonunu yapar.</p>\n	</li>\n	<li>\n	<p>Aktive etmek i&ccedil;in hateoas starter&#39;ı pom.xml&rsquo;e eklenmelidir</p>\n\n	<ul>\n		<li>\n		<pre>\n<code class=\"language-bash\">&lt;dependency&gt;\n	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n	&lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n		</li>\n	</ul>\n	</li>\n</ul>\n\n<pre>\n<code class=\"language-java\">// Lombok olduğunu varsayalım\n@Entity\n@Getter\n@Setter\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Student extends ResourceSupport {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private Long studentId;\n    private String firstName;\n    private String lastName;\n}</code></pre>\n\n<pre>\n<code class=\"language-java\">@RestController\npublic class StudentController {\n\n    @Autowired\n    StudentService studentService;\n\n    @GetMapping(value = \"/student/{id}\", produces = {\"application/hal+json\"})\n    public Resource&lt;Student&gt; getStudent(@PathVariable(value = \"id\", required = true) Long id) {\n        Student student = studentService.getStudentById(id)\n        student.add(linkTo(methodOn(StudentController.class).getStudent(id)).withSelfRel().withType(\"GET\"));\n        return new Resource&lt;Student&gt;(student);\n    }\n\n    @GetMapping(value = \"/student\", produces = {\"application/hal+json\"})\n    public Resources&lt;Student&gt; getStudents() {\n\n        List&lt;Student&gt; students = studentService.getAllStudent();\n        for (Student student : students) {\n            Long studentId = student.getStudentId();\n            student.add(linkTo(methodOn(StudentController.class).getStudent(studentId)).withRel(\"get_student\").withType(\"GET\"));\n            student.add(linkTo(methodOn(StudentController.class).deleteStudent(studentId)).withRel(\"delete_student\").withType(\"DELETE\"));\n        }\n\n        Link link = linkTo(methodOn(StudentController.class).getStudents()).withSelfRel().withType(\"GET\");\n        return new Resources&lt;Student&gt;(students, link);\n    }\n\n    @DeleteMapping(value = \"/student/{id}\", produces = {\"application/hal+json\"})\n    public Resource&lt;Student&gt; deleteStudent(@PathVariable(value = \"id\", required = true) Long id) {\n\n        Optional&lt;Student&gt; student = studentService.getStudentById(id);\n\n        studentService.deleteStudentById(id);\n        Student student = new Student();\n        student.add(linkTo(methodOn(StudentController.class).getStudents()).withRel(\"get_students\").withType(\"GET\"));\n        return new Resource&lt;Student&gt;(student);\n    }\n}</code></pre>\n\n<p>RestControllerimiz&rsquo;e&nbsp;HATEOAS yeteneklerini controllerimizde kullanarak ekliyoruz.</p>\n\n<pre>\n<code class=\"language-java\">student.add(linkTo(methodOn(StudentController.class).getStudent(studentId)).withRel(\"get_student\").withType(\"GET\"));\nstudent.add(linkTo(methodOn(StudentController.class).deleteStudent(studentId)).withRel(\"delete_student\").withType(\"DELETE\"));</code></pre>\n\n<p>Yukarıdaki satırlar Rest servisimizinden HATEOAS &ouml;zelliğini kullanarak Rest servisimizin &ouml;zelliklerini tanımlayarak istek yapacak kişiye bu bilgilerin g&ouml;nderilmesini sağlamaktayız. Bu satırları a&ccedil;ıklayayım.</p>\n\n<p><strong>methodOn:&nbsp;</strong>Gelen isteğin kullanılacağı class ve hangi metodun hangi parametre alarak işlem yapacağını belirtir.</p>\n\n<p><strong>with_rel:</strong>&nbsp;Metod ile ilgili referans tanımlaması yapılır.</p>\n\n<p><strong>withType:</strong>&nbsp;Hangi Rest tipinde olduğunun tanımı yapılmaktadır.İstek yapan kişiye bilgi vermek i&ccedil;in kullanılır.</p>\n\n<p>Sonu&ccedil; olarak cevap olarak d&ouml;nen rest servisinde şu şekilde bilgiler g&ouml;z&uuml;k&uuml;r.</p>\n\n<pre>\n<code class=\"language-json\">\"studentList\": [\n            {\n                \"studentId\": 1,\n                \"firstName\": \"Anıl\",\n                \"lastName\": \"Şenocak\",\n                \"_links\": {\n                    \"get_student\": {\n                        \"href\": \"http://localhost:8080/student/1\",\n                        \"type\": \"GET\"\n                    },\n                    \"delete_student\": {\n                        \"href\": \"http://localhost:8080/student/1\",\n                        \"type\": \"DELETE\"\n                    }\n                }\n            },\n        ]\n    },\n    \"_links\": {\n        \"self\": {\n            \"href\": \"http://localhost:8080/students\",\n            \"type\": \"GET\"\n        }\n    }\n}</code></pre>\n\n<p>&nbsp;</p>', 'spring-boot-ve-rest', 'Spring Boot ve REST', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'rest'),
('1cb9374e-4e52-4142-a1af-30014ef4a271', '<h2><strong>Spring Nedir?</strong></h2>\n\n<p><strong>Spring framework</strong>, Java uygulamaları geliştirmek i&ccedil;in kapsamlı altyapı desteği sağlar. Dependency Injection gibi bazı g&uuml;zel &ouml;zelliklere sahiptir ve bu mod&uuml;ller, bir uygulamanın geliştirme s&uuml;resini b&uuml;y&uuml;k &ouml;l&ccedil;&uuml;de azaltabilir.</p>\n\n<ul>\n	<li>Spring JDBC</li>\n	<li>Spring MVC</li>\n	<li>Spring Security</li>\n	<li>Spring AOP</li>\n	<li>Spring ORM</li>\n	<li>Spring Test</li>\n</ul>\n\n<p>POJO tabanlı bir programlama modeli sunar. &ldquo;<strong>Program to interface</strong>&rdquo; yaklaşımını temel ilke kabul etmiştir. Test edilebilirlik her noktada &ouml;n plandadır. Mod&uuml;ler bir frameworkt&uuml;r, sadece ihtiya&ccedil; duyulan mod&uuml;ller istenilen kapsamda kullanılabilir.&nbsp;Uygulama kodunun framework&rsquo;e bağımlı olmasına gerek duyulmaz, dolayısı ile istilacı değildir!</p>\n\n<p>&Ouml;rneğin, Java web geliştirmenin ilk zamanlarında, bir veri kaynağına bir kayıt eklemek i&ccedil;in &ccedil;ok sayıda standart kod yazmamız gerekiyordu. Spring JDBC mod&uuml;l&uuml;n&uuml;n <em>JDBCTemplate</em>&#39;ini kullanarak, onu yalnızca birka&ccedil; konfig&uuml;rasyonla birka&ccedil; satır koda indirgeyebiliriz.</p>\n\n<p><strong>ApplicationContext T&uuml;rleri</strong><br />\nSpring Framework farklı ApplicationContext implemantasyonlarına sahiptir. Standalone uygulamalarda genellikle ClassPathXmlApplicationContext kullanılır. Web uygulamalarında ise WebApplicationContext kullanılır.</p>\n\n<pre>\n<code class=\"language-java\">ApplicationContext context = new ClassPathXmlApplicationContext(\"beans-dao.xml\", \"beans-service.xml\");\n// ApplicationContext yaratılır , Container bu aşamadan itibaren kullanıma hazırdır</code></pre>\n\n<pre>\n<code class=\"language-java\">PetClinicService service = context.getBean(\"petClinicService\", PetClinicService.class);\n// Bean lookup ile ilgili bean\'a erişilir</code></pre>\n\n<pre>\n<code class=\"language-java\">List vets = service.getVets();\n// Artık bean\'ler uygulama içerisinde istenildiği gibi kullanılabilir</code></pre>\n\n<h3><strong>JVM ve Spring Container İlişkisi</strong></h3>\n\n<p>Aslında Spring Container veya diğer adı ile ApplicationContext&#39;de JVM i&ccedil;erisinde bir Java nesnesidir.&nbsp;Standalone veya web tabanlı Java uygulaması i&ccedil;erisinde bir yerde ApplicationContext oluşturulur. ApplicationContext i&ccedil;erisinde de uygulamanın diğer Java nesneleri yaratılır ve y&ouml;netilir.</p>\n\n<p>JVM i&ccedil;erisinde hedefimiz m&uuml;mk&uuml;n olduğunca fazla sayıda nesnenin Spring Container tarafından y&ouml;netilmesidir, b&ouml;ylece bu nesneler Spring&#39;in sunduğu kabiliyetlerden yararlanabilirler. Ancak JVM i&ccedil;erisinde Spring Container tarafından y&ouml;netilemeyecek nesneler de olacaktır. Spring tarafından y&ouml;netilmeyen nesnelerde ApplicationContext lookup yaparak Spring Container&#39;daki nesnelere erişilebilir</p>\n\n<h2><strong>Spring Boot Nedir?</strong></h2>\n\n<p>Temelde Spring &ccedil;er&ccedil;evesinin bir uzantısıdır ve bir Spring uygulamasını kurmak i&ccedil;in gerekli olan temel konfig&uuml;rasyonlarını ortadan kaldırır. Daha hızlı ve daha verimli bir geliştirme ekosisteminin yolunu a&ccedil;an Spring platformunun kararlı bir g&ouml;r&uuml;n&uuml;m&uuml;n&uuml; alır.</p>\n\n<p>İşte Spring Boot&#39;daki &ouml;zelliklerden sadece birka&ccedil;ı:</p>\n\n<ul>\n	<li>Derleme ve uygulama yapılandırmasını basitleştirmek i&ccedil;in d&uuml;ş&uuml;n&uuml;lm&uuml;ş &quot;başlangı&ccedil;&quot; bağımlılıkları</li>\n	<li>Uygulama dağıtımında karmaşıklığı &ouml;nlemek i&ccedil;in g&ouml;m&uuml;l&uuml; sunucu</li>\n	<li>&Ouml;l&ccedil;&uuml;mler, Durum denetimi ve harici yapılandırma</li>\n	<li>Spring işlevselliği i&ccedil;in otomatik yapılandırma - m&uuml;mk&uuml;n olduğunda</li>\n</ul>\n\n<h3><strong>Spring Boot Ne Değildir?</strong></h3>\n\n<ul>\n	<li>Spring Boot bir uygulama sunucusu veya web container değildir, ama tomcat gibi web container&rsquo;ları g&ouml;m&uuml;l&uuml; olarak &ccedil;alıştırabilir.</li>\n	<li>JSR spesifikasyonlarını implement etmez, ama Hibernate gibi pek &ccedil;ok JSR implemantasyonunun kullanımını kolaylaştırır.</li>\n	<li>Hi&ccedil;bir şekilde otomatik kod &uuml;retmez, konfig&uuml;rasyonu otomatik hale getirir</li>\n</ul>\n\n<h3><strong>Spring Boot Platform</strong></h3>\n\n<ul>\n	<li><code>Sunum Katmanı</code>:&nbsp;Spring Web MVC, Spring WebFlow,Spring Web Services, Spring Session...</li>\n	<li><code>Servis Katmanı</code>:&nbsp;Spring Core Container, Spring AOP, Spring Security, Spring Integration, Spring Cloud...</li>\n	<li><code>Veri Katmanı</code>:&nbsp;Spring Data, Spring Batch, Spring AMQP, Spring LDAP, JPA/Hibernate, JDBC, JOOQ...</li>\n</ul>\n\n<pre>\n<code class=\"language-java\">&lt;project...&gt;\n	...\n	&lt;build&gt;\n		&lt;plugins&gt;\n			&lt;plugin&gt;\n				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n			&lt;/plugin&gt;\n		&lt;/plugins&gt;\n	&lt;/build&gt;\n&lt;/project&gt;\n// Executeable jar/war oluşturmayı sağlar Kullanabilmek için maven 3.2 üstü ile çalışmak gerekir</code></pre>\n\n<h3><strong>SpringBootConfiguration</strong></h3>\n\n<ul>\n	<li><code>@Configuration</code> anotasyonundan t&uuml;rer.</li>\n	<li>Uygulamalarda sadece bir tane <code>@SpringBootConfiguration</code><strong>&nbsp;</strong>anotasyonuna sahip sınıf yer almalıdır.</li>\n	<li><code>@SpringBootApplication</code> anotasyonu diğer kabiliyetlerin yanında bu anotasyonu da barındırdığı i&ccedil;in genellikle o kullanılır.</li>\n</ul>\n\n<h4><strong>EnableAutoConfiguration</strong></h4>\n\n<ul>\n	<li>Uygulamadaki Spring ApplicationContext&#39;in otomatik olarak konfig&uuml;rasyonunu sağlar.</li>\n	<li>Spring Boot kabiliyetlerini devreye alan auto-configuration sınıflarını classpath&#39;de tespit ederse devreye alır.</li>\n	<li><code>@EnableAutoConfiguration</code> sınıfının yer aldığı paket &ouml;zel &ouml;neme sahiptir.</li>\n	<li>Bu paket ve alt paketleri uygulamaya ait Spring bean&#39;larını ve JPA entity sınıflarını tespit etmek i&ccedil;in taranır</li>\n</ul>\n\n<h4><strong>Logging</strong></h4>\n\n<ul>\n	<li>Spring Boot log altyapısı olarak <strong>logback</strong>, <strong>log4j2</strong> ve <strong>java.util.logging</strong> k&uuml;t&uuml;phanelerini desteklemektedir.</li>\n	<li>Default olarak <em>logback </em>kullanılmaktadır.</li>\n	<li>Spring Boot i&ccedil;erisinde log API&#39;si olarak Apache Commons Logging API kullanılmaktadır.</li>\n	<li>Dolayısı ile yukarıda bahsedilen herhangi bir log k&uuml;t&uuml;phanesine ge&ccedil;iş sadece konfig&uuml;rasyon değişikliği ile ger&ccedil;ekleşecektir.</li>\n	<li>Application.properties i&ccedil;erisinde logger&#39;lar ve log d&uuml;zeyleri, log &ccedil;ıktısının formatı, log dosyalarının lokasyonu vb y&ouml;netilebilir.\n	<ul>\n		<li>\n		<pre>\n<code class=\"language-bash\">logging.level.root=INFO\nlogging.level.org.hibernate.type=TRACE\nlogging.level.org.springframework.web=DEBUG</code></pre>\n		</li>\n	</ul>\n	</li>\n	<li>Kullanılan log altyapısına g&ouml;re ilgili log konfig&uuml;rasyon dosyaları classpath&#39;den y&uuml;klenebilir.\n	<ul>\n		<li>\n		<pre>\n<code class=\"language-bash\">logging.config=logback-spring.xml\n// logback-spring.xml, logback.xml, log4j2-spring.xml, log4j2.xml, logging.properties\n</code></pre>\n		</li>\n	</ul>\n	</li>\n	<li>Log &ccedil;ıktısı default console&#39;a yazılır, ancakistenirse log dosyalarına da yazılabilir\n	<ul>\n		<li>\n		<pre>\n<code class=\"language-bash\">logging.file=petclinic.log\nlogging.path=/tmp\n// logging.file tanımlı ise path devreye girmez, sadece path tanimli oldugu durumda ise spring.log isimli log dosyasi belirtilen dizinde olusturulur\n</code></pre>\n		</li>\n	</ul>\n	</li>\n	<li>Log property tanımları fiziksel log altyapısından bağımsızdır.</li>\n</ul>\n\n<h2><strong>Spring ve Spring Boot Arasındaki Fark</strong></h2>\n\n<h3><strong>Framework</strong></h3>\n\n<p>Spring, a&ccedil;ık kaynaklı ve hafiftir ve kurumsal uygulamalar oluşturmak i&ccedil;in uygundur. Spring Boot ise REST API&#39;leri geliştirmek i&ccedil;in uygun olan Spring framework uzantısıdır. Spring&#39;deki uygulamalar gevşek(loosely coupled) bir şekilde birleştirilirken, Spring Boot bağımsızdır/standalone.</p>\n\n<h3><strong>HTTP Basic Authentication</strong></h3>\n\n<p>Spring ve Spring Boot&#39;un g&uuml;venlik yapılandırmalarını, yani varsayılan HTTP Temel kimlik doğrulamasını&nbsp;etkinleştirmek i&ccedil;in &ccedil;eşitli bağımlılıkların ve yapılandırmaların etkinleştirilmesi gerekmektedir.</p>\n\n<p>Spring s&ouml;z konusu olduğunda, bir uygulamada varsayılan HTTP Temel kimlik doğrulamasını etkinleştirmek i&ccedil;in hem standart spring-security-web hem de spring-security-config bağımlılıkları gereklidir.</p>\n\n<p>Sonraki adım, WebSecurityConfigurerAdapter olan bir sınıf ekleyerek <code>@EnableWebSecurity</code> annotation&#39;ı etkinleştirmektir:</p>\n\n<ul>\n	<li>G&uuml;venliği etkinleştirmek i&ccedil;in bellek i&ccedil;i kimlik doğrulamasını kullanmak gerekir.</li>\n</ul>\n\n<p>Spring gibi, bu bağımlılıklar Spring Boot durumunda bile dahil edilmelidir. Bununla birlikte, bu, yalnızca geri kalanı otomatik olarak halledecek olan spring-boot-starter-security bağımlılığı tanımlanarak yapılabilir.</p>\n\n<h3><strong>Minimum Dependencies</strong></h3>\n\n<p>Spring, bir web uygulamasının oluşturulmasında belirli sayıda bağımlılık gerektirir. Bunlar:</p>\n\n<pre>\n<code class=\"language-bash\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n    &lt;version&gt;5.2.9.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n    &lt;version&gt;5.2.9.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>Spring&#39;in aksine, Spring Boot bir web uygulamasını &ccedil;alışır duruma getirmek i&ccedil;in yalnızca bir bağımlılık gerektirir:</p>\n\n<pre>\n<code class=\"language-bash\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;version&gt;2.4.4&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n\n<p>Diğer t&uuml;m bağımlılıklar, derleme sırasında son arşive otomatik olarak eklenir. Bir başka g&uuml;zel &ouml;rnek de test k&uuml;t&uuml;phaneleridir. Genellikle Spring Test, JUnit, Hamcrest ve Mockito k&uuml;t&uuml;phanelerini kullanırız. Bir Spring projesinde, t&uuml;m bu k&uuml;t&uuml;phaneleri bağımlılıklar olarak eklemeliyiz. Alternatif olarak, Spring Boot&#39;ta bu kitaplıkları otomatik olarak dahil etmek i&ccedil;in yalnızca test i&ccedil;in başlangı&ccedil; bağımlılığına ihtiyacımız var.</p>\n\n<p>Spring Boot, farklı Spring mod&uuml;lleri i&ccedil;in bir dizi başlangı&ccedil; bağımlılığı sağlar. En sık kullanılanlardan bazıları şunlardır: <em>spring-boot-starter-data-jpa</em></p>\n\n<ul>\n	<li><em>spring-boot-starter-security</em></li>\n	<li><em>spring-boot-starter-test</em></li>\n	<li><em>spring-boot-starter-web</em></li>\n	<li><em>spring-boot-starter-thymeleaf</em></li>\n</ul>\n\n<p>Yeni başlayanların tam listesi i&ccedil;in ayrıca <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter\">Spring documentation</a>&nbsp;de g&ouml;z atın.</p>\n\n<h2><strong>Spring Yapılandırma</strong></h2>\n\n<p>Hem Spring hem de Spring Boot kullanarak bir JSP web uygulaması oluşturabiliriz. Spring, dağıtık sunucu uygulamasını, eşlemeleri ve diğer destekleyici yapılandırmaları tanımlamayı gerektirir. Bunu <em>web.xml</em>&nbsp;dosyasını veya <em>Initializer</em> sınıfını kullanarak yapabiliriz:</p>\n\n<pre>\n<code class=\"language-java\">public class MyWebAppInitializer implements WebApplicationInitializer {\n    @Override\n    public void onStartup(ServletContext container) {\n        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();\n        context.setConfigLocation(\"com.github.senocak\");\n\n        container.addListener(new ContextLoaderListener(context));\n\n        ServletRegistration.Dynamic dispatcher = container.addServlet(\"dispatcher\", new DispatcherServlet(context));\n\n        dispatcher.setLoadOnStartup(1);\n        dispatcher.addMapping(\"/\");\n    }\n}</code></pre>\n\n<p>Ayrıca bir <code>@Configuration</code>&nbsp;sınıfına <code>@EnableWebMvc</code> ek annotation&#39;ı eklememiz ve controller&#39;dan&nbsp;d&ouml;nd&uuml;r&uuml;len view&#39;leri &ccedil;&ouml;zmek i&ccedil;in bir view-resolver tanımlamamız gerekir:</p>\n\n<pre>\n<code class=\"language-java\">@EnableWebMvc\n@Configuration\npublic class ClientWebConfig implements WebMvcConfigurer {\n   @Bean\n   public ViewResolver viewResolver() {\n      InternalResourceViewResolver bean = new InternalResourceViewResolver();\n      bean.setViewClass(JstlView.class);\n      bean.setPrefix(\"/WEB-INF/view/\");\n      bean.setSuffix(\".jsp\");\n      return bean;\n   }\n}</code></pre>\n\n<p>Buna karşılık, Spring Boot, web başlatıcıyı ekledikten sonra işlerin y&uuml;r&uuml;mesi i&ccedil;in yalnızca birka&ccedil; &ouml;zelliğe ihtiya&ccedil; duyar:</p>\n\n<pre>\n<code class=\"language-bash\">spring.mvc.view.prefix=/WEB-INF/jsp/\nspring.mvc.view.suffix=.jsp</code></pre>\n\n<p>Yukarıdaki Spring yapılandırmasının t&uuml;m&uuml;, <code>auto-configuration</code>&nbsp;adı verilen bir işlemle <em><strong>Spring</strong>&nbsp;<strong>Boot web starter</strong></em> eklenerek otomatik olarak dahil edilir. Bunun anlamı, Spring Boot&#39;un uygulamada bulunan dependencies&#39;lere, properties&#39;lere ve bean&#39;lere bakması ve bunlara dayalı yapılandırmayı etkinleştirmesidir. Elbette, kendi &ouml;zel yapılandırmamızı eklemek istersek, Spring Boot otomatik yapılandırması geri &ccedil;ekilecektir.</p>\n\n<h2><strong>&Ouml;ny&uuml;kleme</strong></h2>\n\n<p>Servlet, Spring ve Spring Boot&#39;ta uygulama &ouml;ny&uuml;klemeyi ayıran şeydir. <strong>web.xml</strong> veya <strong>SpringServletContainerInitializer</strong>, Spring durumunda &ouml;ny&uuml;kleme giriş noktası olarak kullanılır. Oysa Spring Boot bir uygulamayı sadece Servlet 3 ile &ouml;ny&uuml;kleyebilir.</p>\n\n<h3><strong>Spring &Ouml;ny&uuml;kleme?</strong></h3>\n\n<p>Spring, hem eski <em>web.xml</em>&nbsp;&ouml;ny&uuml;kleme y&ouml;ntemini hem de en son Servlet 3+ y&ouml;ntemini destekler. Web.xml yaklaşımını adım adım g&ouml;relim:</p>\n\n<ul>\n	<li>Sunucu(Servlet kapsayıcısı) <em>web.xml</em>&#39;yi okur.</li>\n	<li><em>web.xml</em>&#39;de tanımlanan <em>DispatcherServlet</em>, konteyner tarafından başlatılır.</li>\n	<li><em>DispatcherServlet</em>, <em>WEB-INF/{servletName}-servlet.xml</em> dosyasını okuyarak <em>WebApplicationContext</em> oluşturur.</li>\n	<li>Son olarak, <em>DispatcherServlet</em> uygulama bağlamında tanımlanan bean&#39;leri&nbsp;kaydeder.</li>\n</ul>\n\n<p>Servlet 3+ yaklaşımını kullanarak Spring&#39;in nasıl &ouml;ny&uuml;klendiği:</p>\n\n<ol>\n	<li>Konteyner, <em>ServletContainerInitializer</em> uygulayan sınıfları arar ve &ccedil;alıştırır.</li>\n	<li><em>SpringServletContainerInitializer</em>, <em>WebApplicationInitializer</em> uygulayan t&uuml;m sınıfları bulur.</li>\n	<li><em>WebApplicationInitializer</em>, bağlamı XML veya <em>@Configuration</em> sınıflarıyla oluşturur.</li>\n	<li><em>WebApplicationInitializer</em>, &ouml;nceden oluşturulan bağlamla <em>DispatcherServlet</em>&#39;i oluşturur.</li>\n</ol>\n\n<h3><strong>Spring Boot &Ouml;ny&uuml;kleme?</strong></h3>\n\n<p>Bir Spring Boot uygulamasının giriş noktası, <strong><em>@SpringBootApplication</em></strong> ile not verilen sınıftır:</p>\n\n<pre>\n<code class=\"language-java\">@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}</code></pre>\n\n<p>Spring Boot varsayılan olarak uygulamayı &ccedil;alıştırmak i&ccedil;in g&ouml;m&uuml;l&uuml; bir container kullanır. Bu durumda Spring Boot, katıştırılmış bir web sunucusunu başlatmak i&ccedil;in <em>public static void main</em>&nbsp;noktasını kullanır.</p>\n\n<p>Ayrıca, <em>Servlet</em>, <em>Filter</em> ve <em>ServletContextInitializer</em> bean&#39;lerinin uygulama bağlamından g&ouml;m&uuml;l&uuml; servlet konteynerine bağlanmasını da sağlar.</p>\n\n<p>Spring Boot&#39;un bir başka &ouml;zelliği de, Main-class&#39;ın aynı paketteki veya alt paketlerindeki t&uuml;m sınıfları bileşenler i&ccedil;in otomatik olarak taramasıdır.</p>\n\n<p>Ek olarak, Spring Boot, harici bir container&#39;da bir web arşivi olarak dağıtma se&ccedil;eneği sunar. Bu durumda, <em>SpringBootServletInitializer</em>&#39;ı genişletmemiz gerekiyor:</p>\n\n<pre>\n<code class=\"language-java\">@SpringBootApplication\npublic class Application extends SpringBootServletInitializer {\n    // ...\n}</code></pre>\n\n<p>Burada harici sunucu uygulaması konteyneri, web arşivinin META-INF dosyasında tanımlanan Ana sınıfı arar ve <em>SpringBootServletInitializer</em>, <em>Servlet</em>, <em>Filter</em> ve <em>ServletContextInitializer</em>&#39;ın bağlanmasıyla ilgilenir.</p>\n\n<h2><strong>Dağıtım</strong></h2>\n\n<p>Hem Spring hem de Spring Boot, paketlemede en yaygın olarak kullanılan Maven ve Gradle desteği gibi teknolojileri desteklemeleri bakımından benzerdir. Ancak, dağıtım s&uuml;reci her iki framework&#39;de farklıdır.</p>\n\n<p>&Ouml;rneğin, Spring Boot Maven Plugin, Maven&#39;de Spring Boot desteği sağlar. Ayrıca y&uuml;r&uuml;t&uuml;lebilir jar veya war arşivlerinin paketlenmesine ve bir uygulamanın &quot;n-place&quot; &ccedil;alıştırılmasına izin verir.</p>\n\n<p>Spring Boot&#39;un Spring&#39;e g&ouml;re bir&ccedil;ok avantajı vardır:</p>\n\n<ul>\n	<li>G&ouml;m&uuml;l&uuml; container&nbsp;i&ccedil;in destek var</li>\n	<li><strong><em>Java -jar </em></strong>komutunu kullanarak, jar&#39;lar bağımsız olarak &ccedil;alıştırılabilir.</li>\n	<li>Jar i&ccedil;erisindeki conflictler, ona yol a&ccedil;an bağımlılıklar kaldırılarak &ouml;nlenebilir.</li>\n	<li>Aktif profilleri tanımlayabilirsiniz</li>\n	<li>Spring Boot Maven Plugin, y&uuml;r&uuml;t&uuml;lebilir jar veya war arşivlerini destekler ve bir uygulamayı &quot;in-place&quot; &ccedil;alıştırmanıza olanak tanır</li>\n	<li>Rastgele bağlantı noktası oluşturma yoluyla basitleştirilmiş entegrasyon testleri</li>\n</ul>\n\n<h2><strong>Spring Boot&#39;un&nbsp;Spring&#39;e&nbsp;Avantajları</strong></h2>\n\n<ol>\n</ol>\n\n<ul>\n	<li>Daha hızlı uygulama &ouml;ny&uuml;klemesine katkıda bulunan varsayılan yapılandırmalar vardır</li>\n	<li>Spring Boot, daha basit ve verimli derleme ve uygulama yapılandırması i&ccedil;in Spring&rsquo;in &quot;starter&quot; bağımlılıklarına ilişkin fikirli bir bakış a&ccedil;ısına sahip</li>\n	<li>Kolay entegrasyona izin veren &ccedil;ok sayıda başlangı&ccedil; projesi olduğundan, s&uuml;r&uuml;mler s&ouml;z konusu olduğunda hi&ccedil;bir sorun yoktur. Bunlardan bazıları\n	<ul>\n		<li>spring-boot-starter-web</li>\n		<li>spring-boot-starter-data-jpa</li>\n		<li>spring-boot-starter-test</li>\n		<li>spring-boot-starter-security</li>\n		<li>spring-boot-starter-thymeleaf&nbsp;i&ccedil;erir.</li>\n	</ul>\n	</li>\n	<li>Tomcat veya jetty gibi g&ouml;m&uuml;l&uuml; sunucular, bir uygulamayı &ccedil;alıştırmak i&ccedil;in a&ccedil;ık sunuculara ihtiya&ccedil; duyan Spring&#39;e kıyasla y&uuml;r&uuml;tmeyi kolaylaştırır.</li>\n	<li>Zamanı azaltan ve &uuml;retkenliği artıran standart kodlardan ka&ccedil;ınırsınız. Spring uygulamaları &ccedil;ok fazla kod satırı gerektirir</li>\n	<li>Spring Boot, Spring gibi bir dağıtım tanımlayıcısına ihtiya&ccedil; duymaz</li>\n</ul>\n\n<h2><strong>Sonu&ccedil;</strong></h2>\n\n<p>Spring Boot, geleneksel Spring&#39;in t&uuml;m &ouml;zelliklerini i&ccedil;erir ve yine de uygulama geliştirmeyi &ccedil;ok daha kolay hale getirir. T&uuml;m Spring Boot &ouml;zellikleri otomatik olarak yapılandırıldığı i&ccedil;in, bir uygulamayı Spring&#39;e kıyasla &ccedil;ok daha kısa s&uuml;rede &ccedil;alışır duruma getirebilirsiniz</p>', 'spring-vs-spring-boot', 'Spring vs Spring Boot', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-09 10:40:45', '2022-09-09 10:40:45', 'Spring;SpringBoot'),
('7a5ca48e-f120-42c4-942c-120afef81252', 'Officiis voluptatibus consequuntur qui soluta. Error ea eos architecto omnis voluptatum. Aliquam mollitia amet voluptates rem. Impedit libero eligendi et facilis voluptatem dolorem.', 'Forward-Accounts-Officer', 'Forward Accounts Officer', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-10 06:34:12', '2022-09-10 06:34:12', 'up'),
('908ec290-6f9b-40b9-8754-42ee3b911c4b', 'Nemo sunt blanditiis officiis exercitationem beatae nobis aut ipsam molestias. Est sit quia illo quia et. Dolores minus quis necessitatibus similique quisquam ducimus et. Non voluptatibus corrupti quas velit dolores expedita. Nesciunt distinctio et quia dolor ad ut numquam omnis harum. Odit non sint aut doloremque et sint ut et rerum.', 'Investor-Program-Analyst', 'Investor Program Analyst', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-10 06:33:04', '2022-09-10 06:33:04', 'intranet'),
('a84ed5f4-a3fa-4d7d-a7d1-1d6e7779f86b', 'Consequatur quia voluptas quisquam quibusdam dolor corporis provident modi est. Voluptatum cupiditate eaque architecto aut aut molestiae qui quis aliquam. Id voluptas repellat perferendis suscipit autem. Sit eos nobis quasi officia reiciendis. Ab ipsam aut reiciendis ut eius quos odit pariatur. Unde eligendi nobis optio architecto deserunt fugit.', 'Human-Infrastructure-Specialist', 'Human Infrastructure Specialist', '2cb9374e-4e52-4142-a1af-16144ef4a27d', '2022-09-10 06:38:02', '2022-09-10 06:38:02', 'structure');
-- --------------------------------------------------------
-- Table structure for table `post_category`
CREATE TABLE `post_category` (
    `post_id` varchar(255) NOT NULL,
    `category_id` varchar(255) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
INSERT INTO `post_category` (`post_id`, `category_id`) VALUES
('1cb9374e-4e52-4142-a1af-10000ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf014'),
('1cb9374e-4e52-4142-a1af-10001ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf014'),
('1cb9374e-4e52-4142-a1af-10002ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf014'),
('1cb9374e-4e52-4142-a1af-10003ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf014'),
('1cb9374e-4e52-4142-a1af-10004ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf014'),
('1cb9374e-4e52-4142-a1af-10005ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf014'),
('1cb9374e-4e52-4142-a1af-10006ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf014'),
('1cb9374e-4e52-4142-a1af-20000ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20001ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20002ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20003ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20004ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20005ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20006ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20007ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20008ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20009ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20010ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20011ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20012ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20013ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20014ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20015ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20016ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20017ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20018ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20019ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20020ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20021ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20022ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20023ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20024ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20025ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-20026ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf013'),
('1cb9374e-4e52-4142-a1af-30000ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf012'),
('1cb9374e-4e52-4142-a1af-30001ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf012'),
('1cb9374e-4e52-4142-a1af-30002ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf012'),
('1cb9374e-4e52-4142-a1af-30003ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf012'),
('1cb9374e-4e52-4142-a1af-30004ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf012'),
('1cb9374e-4e52-4142-a1af-30005ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf012'),
('1cb9374e-4e52-4142-a1af-30006ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf012'),
('1cb9374e-4e52-4142-a1af-30007ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf012'),
('1cb9374e-4e52-4142-a1af-30008ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf012'),
('1cb9374e-4e52-4142-a1af-30009ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf012'),
('1cb9374e-4e52-4142-a1af-30010ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf012'),
('1cb9374e-4e52-4142-a1af-30011ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf012'),
('1cb9374e-4e52-4142-a1af-30012ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf012'),
('1cb9374e-4e52-4142-a1af-30013ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf012'),
('1cb9374e-4e52-4142-a1af-30014ef4a271', '34d807ce-a348-4f18-bbf6-99ba090bf012'),
('908ec290-6f9b-40b9-8754-42ee3b911c4b', '34d807ce-a348-4f18-bbf6-99ba090bf012'),
('7a5ca48e-f120-42c4-942c-120afef81252', '34d807ce-a348-4f18-bbf6-99ba090bf012'),
('a84ed5f4-a3fa-4d7d-a7d1-1d6e7779f86b', '34d807ce-a348-4f18-bbf6-99ba090bf012');
-- --------------------------------------------------------
-- Table structure for table `roles`
CREATE TABLE `roles` (
    `id` varchar(255) NOT NULL,
    `name` varchar(60) DEFAULT NULL,
    `created_at` datetime DEFAULT NULL,
    `updated_at` datetime DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
INSERT INTO `roles` (`id`, `name`, `created_at`, `updated_at`) VALUES
('599215808072077311', 'ROLE_USER', '2022-09-09 10:40:44', '2022-09-09 10:40:44'),
('599215808072077312', 'ROLE_ADMIN', '2022-09-09 10:40:44', '2022-09-09 10:40:44');
-- --------------------------------------------------------
-- Table structure for table `users`
CREATE TABLE `users` (
    `id` varchar(255) NOT NULL,
    `email` varchar(40) DEFAULT NULL,
    `username` varchar(15) DEFAULT NULL,
    `name` varchar(40) DEFAULT NULL,
    `password` varchar(100) DEFAULT NULL,
    `created_at` datetime DEFAULT NULL,
    `updated_at` datetime DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
INSERT INTO `users` (`id`, `email`, `username`, `name`, `password`, `created_at`, `updated_at`) VALUES
('2cb9374e-4e52-4142-a1af-16144ef4a27d', 'anil1@senocak.com', 'asenocakUser', 'asenocak2', '$2a$10$znsjvm5Y06ZJmpaWGHmmNu4iDJYhk369LR.R3liw2T4RjJcnt9c12', '2022-09-09 10:40:44', '2022-09-09 10:40:44'),
('3cb9374e-4e52-4142-a1af-16144ef4a27d', 'anil2@senocak.com', 'asenocakAdmin', 'Kiley', '$2a$10$znsjvm5Y06ZJmpaWGHmmNu4iDJYhk369LR.R3liw2T4RjJcnt9c12', '2022-09-09 10:40:44', '2022-09-09 10:40:44');
-- --------------------------------------------------------
-- Table structure for table `user_roles`
CREATE TABLE `user_roles` (
    `user_id` varchar(255) NOT NULL,
    `role_id` varchar(255) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

INSERT INTO `user_roles` (`user_id`, `role_id`) VALUES
('2cb9374e-4e52-4142-a1af-16144ef4a27d', '599215808072077311'),
('3cb9374e-4e52-4142-a1af-16144ef4a27d', '599215808072077312');

-- Indexes for table `categories`
ALTER TABLE `categories`
    ADD PRIMARY KEY (`id`),
    ADD UNIQUE KEY `slug` (`slug`);

-- Indexes for table `comments`
ALTER TABLE `comments`
    ADD PRIMARY KEY (`id`),
    ADD KEY `FKh4c7lvsc298whoyd4w9ta25cr` (`post_id`);

-- Indexes for table `posts`
ALTER TABLE `posts`
    ADD PRIMARY KEY (`id`),
    ADD KEY `FK5lidm6cqbc7u4xhqpxm898qme` (`user_id`);

-- Indexes for table `post_category`
ALTER TABLE `post_category`
    ADD KEY `FKkifam22p4s1nm3bkmp1igcn5w` (`post_id`),
    ADD KEY `FKm6cfovkyqvu5rlm6ahdx3eavj` (`category_id`);

-- Indexes for table `roles`
ALTER TABLE `roles`
    ADD PRIMARY KEY (`id`),
    ADD UNIQUE KEY `name` (`name`);

-- Indexes for table `users`
ALTER TABLE `users`
    ADD PRIMARY KEY (`id`),
    ADD UNIQUE KEY `email` (`email`),
    ADD UNIQUE KEY `username` (`username`);

-- Indexes for table `user_roles`
ALTER TABLE `user_roles`
    ADD PRIMARY KEY (`user_id`,`role_id`),
    ADD KEY `FKh8ciramu9cc9q3qcqiv4ue8a6` (`role_id`);

-- Constraints for table `comments`
ALTER TABLE `comments`
    ADD CONSTRAINT `FKh4c7lvsc298whoyd4w9ta25cr` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`);

-- Constraints for table `posts`
ALTER TABLE `posts`
    ADD CONSTRAINT `FK5lidm6cqbc7u4xhqpxm898qme` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`);

-- Constraints for table `post_category`
ALTER TABLE `post_category`
    ADD CONSTRAINT `FKkifam22p4s1nm3bkmp1igcn5w` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`),
    ADD CONSTRAINT `FKm6cfovkyqvu5rlm6ahdx3eavj` FOREIGN KEY (`category_id`) REFERENCES `categories` (`id`);

-- Constraints for table `user_roles`
ALTER TABLE `user_roles`
    ADD CONSTRAINT `FKh8ciramu9cc9q3qcqiv4ue8a6` FOREIGN KEY (`role_id`) REFERENCES `roles` (`id`),
    ADD CONSTRAINT `FKhfh9dx7w3ubf1co1vdev94g3f` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`);
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
